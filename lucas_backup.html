<!DOCTYPE html>
<!-- saved from url=(0032)http://localhost:8000/lucas.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucas - Audio-Reactive Visual Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #hotkey-legend {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            color: #fff;
            font-size: 10px;
            z-index: 1001;
            font-family: monospace;
            min-width: 220px;
        }
        
        #hotkey-legend h4 {
            margin: 0 0 8px 0;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        
        #hotkey-legend .hotkey-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            padding: 2px 0;
        }
        
        #hotkey-legend .hotkey-item:last-child {
            margin-bottom: 0;
        }
        
        #hotkey-legend .hotkey-key {
            color: #0af;
            font-weight: 600;
            min-width: 60px;
        }
        
        #hotkey-legend .hotkey-desc {
            color: #bbb;
            text-align: right;
            flex: 1;
        }
        
        #status-indicators {
            position: fixed;
            top: 10px;
            left: 10px;
            margin-top: 0;
            display: flex;
            gap: 4px;
            font-size: 9px;
            z-index: 1002;
            pointer-events: none;
        }
        
        #status-indicators span {
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        #ux-toolbox {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            color: #fff;
            font-size: 10px;
            z-index: 1003;
            font-family: monospace;
            min-width: 220px;
            max-width: 280px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
        }
        
        #ux-toolbox h4 {
            margin: 0 0 8px 0;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        
        #ux-toolbox .control-group {
            margin-bottom: 10px;
        }
        
        #ux-toolbox .control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 9px;
            color: #bbb;
            font-weight: 500;
        }
        
        #ux-toolbox .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        #ux-toolbox .control-row input[type="range"] {
            flex: 1;
        }
        
        #ux-toolbox .value {
            min-width: 50px;
            font-size: 9px;
            color: #0af;
            text-align: right;
        }
        
        #dev-toolbox {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            color: #fff;
            min-width: 280px;
            max-width: 320px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 11px;
        }
        
        #dev-toolbox h3 {
            margin: 0 0 10px 0;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        .section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-header::after {
            content: '▾';
            font-size: 10px;
            color: #777;
        }
        
        .section-header.collapsed::after {
            content: '▸';
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 10px;
            color: #bbb;
            font-weight: 500;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-row input[type="range"] {
            flex: 1;
            margin: 0;
        }
        
        .control-row .value {
            font-size: 10px;
            color: #888;
            font-family: monospace;
            min-width: 45px;
            text-align: right;
            padding: 2px 4px;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: text;
            user-select: text;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .control-row .value:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #555;
        }
        
        .control-row .value:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #0af;
            color: #fff;
        }
        
        .resolution-btn.active {
            background: #0af !important;
            color: #000 !important;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 2px;
        }
        
        .control-group .value {
            font-size: 10px;
            color: #888;
            font-family: monospace;
            padding: 2px 4px;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: text;
            user-select: text;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .control-group .value:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #555;
        }
        
        .control-group .value:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #0af;
            color: #fff;
        }
        
        .control-group select,
        .control-group input[type="text"],
        .control-group button {
            font-size: 10px;
            padding: 3px 6px;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .section-header {
            margin-top: 12px;
            margin-bottom: 6px;
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        
        .section-header:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        /* Curve Editor Styles */
        .curve-btn {
            display: none; /* Hidden by default */
            width: 18px;
            height: 18px;
            margin-left: 6px;
            cursor: pointer;
            vertical-align: middle;
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            font-size: 14px;
            line-height: 16px;
            text-align: center;
            user-select: none;
            font-weight: bold;
        }
        
        /* Show curve button on hover of control-group */
        .control-group:hover .curve-btn {
            display: inline-block;
        }
        
        .curve-btn:hover {
            background: #444;
            border-color: #0af;
            color: #0af;
        }
        
        .curve-editor-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .curve-editor-overlay.active {
            display: flex;
        }
        
        .curve-editor {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            min-width: 500px;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .curve-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .curve-editor-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }
        
        .curve-editor-close {
            background: none;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 1;
        }
        
        .curve-editor-close:hover {
            color: #fff;
        }
        
        .curve-canvas-container {
            position: relative;
            margin: 15px 0;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0a0a0a;
        }
        
        .curve-canvas {
            display: block;
            width: 100%;
            height: 300px;
            cursor: crosshair;
        }
        
        .curve-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .curve-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .curve-control-group label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .curve-control-group input[type="number"] {
            background: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 100%;
        }
        
        .curve-control-group input[type="number"]:focus {
            outline: none;
            border-color: #0af;
        }
        
        .curve-power-slider {
            margin-top: 10px;
        }
        
        .curve-power-slider label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .curve-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }
        
        .curve-btn-action {
            padding: 6px 12px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .curve-btn-action:hover {
            background: #444;
            border-color: #666;
        }
        
        .curve-btn-primary {
            background: #0af;
            border-color: #0af;
        }
        
        .curve-btn-primary:hover {
            background: #1bf;
        }
        
        /* Audio Visualization Panel (left side) */
        #audio-visualization-panel {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            color: #fff;
            min-width: 280px;
            max-width: 320px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1004;
            font-size: 11px;
            display: none;
        }
        
        #audio-visualization-panel h3 {
            margin: 0 0 10px 0;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        /* Audio Mappings Panel (right side) */
        #audio-mappings-panel {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            color: #fff;
            min-width: 320px;
            max-width: 400px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1004;
            font-size: 11px;
            display: none;
        }
        
        #audio-meters-container .meter-container {
            margin: 6px 0;
            font-size: 9px;
        }
        
        #audio-meters-container .meter-label {
            display: flex;
            align-items: center;
            margin-bottom: 2px;
            font-size: 9px;
        }
        
        #audio-meters-container .meter-label .legend-swatch {
            margin-right: 4px;
        }
        
        #audio-meters-container .meter-wrapper {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 2px;
        }
        
        #audio-meters-container .meter-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }
        
        #audio-meters-container .meter-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.1s linear, background-color 0.2s;
            min-width: 0;
        }
        
        #audio-meters-container .meter-value {
            min-width: 32px;
            font-size: 8px;
            color: #aaa;
            text-align: right;
            font-family: monospace;
        }
        
        #audio-meters-container .stability-wrapper {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-top: 2px;
        }
        
        #audio-meters-container .stability-label {
            font-size: 7px;
            color: #888;
            min-width: 50px;
            text-transform: capitalize;
        }
        
        #audio-meters-container .stability-visualizer {
            flex: 1;
            height: 12px;
            display: flex;
            align-items: center;
            transition: opacity 0.2s;
            cursor: pointer;
        }
        
        #audio-meters-container .stability-visualizer:hover {
            opacity: 0.8;
        }
        
        #audio-meters-container .stability-indicators {
            display: flex;
            gap: 2px;
            height: 3px;
            width: 100%;
            align-items: center;
        }
        
        #audio-meters-container .stability-bar {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 1px;
            transition: width 0.2s, background-color 0.2s;
            min-width: 0;
            height: 3px;
        }
        
        #audio-meters-container .stability-waveform-container,
        #audio-meters-container .stability-histogram-container {
            display: flex;
            gap: 2px;
            width: 100%;
            height: 12px;
            align-items: center;
        }
        
        #audio-meters-container .stability-waveform,
        #audio-meters-container .stability-histogram {
            flex: 1;
            image-rendering: pixelated;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 1px;
            height: 8px;
        }
        
        #audio-meters-container .stability-rings-container {
            display: flex;
            gap: 4px;
            width: 100%;
            height: 12px;
            align-items: center;
            justify-content: center;
        }
        
        #audio-meters-container .stability-ring {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 12px;
        }
        
        #audio-meters-container .stability-ring svg {
            display: block;
            width: 12px;
            height: 12px;
        }
        
        #audio-meters-container .stability-dots-container {
            display: flex;
            gap: 2px;
            width: 100%;
            height: 12px;
            align-items: center;
        }
        
        #audio-meters-container .stability-dots {
            flex: 1;
            position: relative;
            height: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #audio-meters-container .legend-swatch {
            display: inline-block;
            vertical-align: middle;
            flex-shrink: 0;
        }
        
        /* Position mappings panel below dev-toolbox when both are visible */
        #dev-toolbox:not([hidden]) + #audio-mappings-panel[style*="block"] {
            top: auto;
            bottom: 10px;
        }
        
        #audio-mappings-panel h3 {
            margin: 0 0 10px 0;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        /* Audio mappings panel uses same control-group and control-row styles as visual parameters */
        #audio-mappings-panel .control-group {
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        #audio-mappings-panel .control-group label {
            font-size: 9px;
        }
        
        #audio-mappings-panel .control-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 2px;
        }
        
        #audio-mappings-panel .control-row input[type="range"] {
            flex: 1;
        }
        
        #audio-mappings-panel .control-row .value {
            min-width: 40px;
            font-size: 9px;
            text-align: right;
        }
        
    </style>
</head>
<body>
    <canvas id="canvas" width="1707" height="791"></canvas>
    
    <!-- Curve Editor Overlay -->
    <div id="curve-editor-overlay" class="curve-editor-overlay">
        <div class="curve-editor">
            <div class="curve-editor-header">
                <div class="curve-editor-title" id="curve-editor-title">Curve Editor: Hue Shift~</div>
                <button class="curve-editor-close" id="curve-editor-close">×</button>
            </div>
            <div class="curve-canvas-container">
                <canvas id="curve-canvas" class="curve-canvas" width="557" height="300"></canvas>
            </div>
            <div class="curve-controls">
                <div class="curve-control-group">
                    <label>Min Value</label>
                    <input type="number" id="curve-min" step="any" value="0">
                </div>
                <div class="curve-control-group">
                    <label>Max Value</label>
                    <input type="number" id="curve-max" step="any" value="1">
                </div>
            </div>
            <div class="curve-power-slider">
                <label>Curve Power (exponent): <span id="curve-power-value">1.00</span></label>
                <input type="range" id="curve-power" min="0.1" max="5" step="0.1" value="1.0">
            </div>
            <div class="curve-actions">
                <button class="curve-btn-action" id="curve-reset">Reset</button>
                <button class="curve-btn-action" id="curve-apply">Apply</button>
                <button class="curve-btn-action curve-btn-primary" id="curve-close">Done</button>
            </div>
        </div>
    </div>
    
    <!-- Shader scripts (embedded to avoid CORS issues) -->
    <script id="star-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>
    
    <script id="star-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_spikiness;      // 0.0 = circle, 1.0 = maximum spikes
        uniform float u_spikeFrequency; // Continuous number of spikes (2-20)
        uniform float u_spikeSharpness; // 0.0 = rounded, 1.0 = sharp spikes
        uniform float u_hue;
        uniform float u_scale;
        uniform float u_rotation;
        uniform float u_autoRotationSpeed;
        uniform float u_blendOpacity;
        uniform float u_fillSize;       // 0.0 = no fill, 1.0 = fill to edge
        uniform float u_fillOpacity;   // 0.0 = transparent, 1.0 = opaque

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            // Normalize coordinates
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec2 center = vec2(0.5);
            
            // Convert to centered coordinates
            vec2 p = (uv - center) * vec2(u_resolution.x / u_resolution.y, 1.0);
            
            // Rotate coordinates (manual rotation + auto rotation)
            float autoRotation = -u_time * u_autoRotationSpeed; // Auto rotation in degrees (reversed direction)
            float totalRotation = u_rotation + autoRotation;
            float rotationRad = totalRotation * 3.14159 / 180.0;
            float cosRot = cos(rotationRad);
            float sinRot = sin(rotationRad);
            vec2 rotatedP = vec2(
                p.x * cosRot - p.y * sinRot,
                p.x * sinRot + p.y * cosRot
            );
            
            // Draw a morphing shape (circle to spikes)
            float angle = atan(rotatedP.y, rotatedP.x);
            float dist = length(rotatedP);
            
            // Base radius scales with u_scale
            float baseRadius = u_scale * 0.4;
            
            // Calculate shape modulation
            // Use continuous spike frequency (not discrete)
            float modulation = cos(angle * u_spikeFrequency);
            
            // Apply sharpness: sharper spikes use power function
            // When sharpness = 0: smooth cosine wave
            // When sharpness = 1: sharp peaks (using power function)
            float sharpModulation;
            if (u_spikeSharpness < 0.01) {
                // No sharpness: use smooth cosine
                sharpModulation = modulation;
            } else {
                // Apply power function to sharpen peaks
                // Higher sharpness = steeper peaks
                float power = 1.0 / (1.0 + u_spikeSharpness * 3.0); // Range: 1.0 to ~0.25
                sharpModulation = pow(abs(modulation), power) * sign(modulation);
            }
            
            // Apply spikiness: interpolate between circle (0) and spiked shape (1)
            float spikeAmount = u_scale * 0.25 * u_spikiness;
            float r = baseRadius + spikeAmount * sharpModulation;
            
            // Draw the outline - this is the primary shape definition
            float lineWidth = 0.012;
            float outline = smoothstep(lineWidth, 0.0, abs(dist - r));
            
            // Draw the fill separately - parameterized by size and opacity
            float fillRadius = r * u_fillSize; // Fill size: 0.0 = no fill, 1.0 = fill to edge
            float fill = 0.0;
            if (u_fillSize > 0.0 && dist < fillRadius) {
                // Smooth falloff for fill interior
                float fillFalloff = smoothstep(fillRadius, fillRadius * 0.8, dist);
                fill = fillFalloff * u_fillOpacity; // Apply fill opacity
            }
            
            // Combine outline and fill
            // Outline is always full brightness, fill adds to it with its opacity
            float shape = max(outline, fill);
            
            // Convert hue to RGB (hue in degrees, saturation=1.0, value=1.0)
            // Add slow automatic hue shift over time (full cycle every 30 seconds)
            float autoHueShift = u_time * 12.0; // 360 degrees / 30 seconds = 12 deg/sec
            float finalHue = mod(u_hue + autoHueShift, 360.0);
            vec3 hsv = vec3(finalHue / 360.0, 1.0, 1.0);
            vec3 color = hsv2rgb(hsv) * shape;
            
            // Apply opacity for blend control
            gl_FragColor = vec4(color, u_blendOpacity);
        }
    </script>
    
    <script id="dilation-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_uv = a_position * 0.5 + 0.5;
            v_uv.y = 1.0 - v_uv.y; // Flip Y
        }
    </script>
    
    <script id="dilation-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform sampler2D u_history;
        uniform vec2 u_resolution;
        uniform float u_expansionFactor;
        uniform float u_fadeAmount;
        uniform float u_hueShiftAmount;
        uniform float u_noiseAmount;
        uniform float u_noiseRate;
        uniform float u_blurAmount;
        uniform float u_blurRate;
        uniform float u_time;
        varying vec2 v_uv;

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        // Convert RGB to HSV
        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        void main() {
            vec2 uv = v_uv;
            vec2 center = vec2(0.5);
            vec2 dir = uv - center;
            vec2 scaledDir = dir / u_expansionFactor; // Scale inward to sample outward
            vec2 sampleUV = scaledDir + center;
            
            // Check if current pixel is at the center (within small radius)
            float distFromCenter = length(dir);
            float centerRadius = 0.002; // Very small radius around center (about 2 pixels at 1000px resolution)
            
            vec4 history;
            if (distFromCenter < centerRadius) {
                // At center: sample neighboring pixels and average them
                // Sample 8 neighboring pixels in a ring around center
                float sampleRadius = 0.003; // Slightly larger radius for neighbors
                vec4 neighborSum = vec4(0.0);
                float neighborCount = 0.0;
                
                // Sample neighbors in 8 directions
                for (float angle = 0.0; angle < 6.28318; angle += 0.785398) { // 8 directions (2*PI/8)
                    vec2 neighborDir = vec2(cos(angle), sin(angle)) * sampleRadius;
                    vec2 neighborUV = sampleUV + neighborDir;
                    vec4 neighbor = texture2D(u_history, neighborUV);
                    neighborSum += neighbor;
                    neighborCount += 1.0;
                }
                
                // Use average of neighbors, or black if no valid neighbors
                history = neighborCount > 0.0 ? neighborSum / neighborCount : vec4(0.0, 0.0, 0.0, 0.0);
            } else {
                // Check if we're sampling from the center region (prevent center pixels from propagating outward)
                vec2 sampleDir = sampleUV - center;
                float sampleDistFromCenter = length(sampleDir);
                
                if (sampleDistFromCenter < centerRadius) {
                    // If sampling from center, use black/transparent to prevent propagation
                    history = vec4(0.0, 0.0, 0.0, 0.0);
                } else {
                    // Normal sampling
                    history = texture2D(u_history, sampleUV);
                }
            }
            
            // Fade based on expansion (further from center = more faded)
            // distFromCenter already calculated above
            // Use logarithmic fade curve for smoother transitions
            // Map distance to fade using a power curve for more gradual fade
            float fadeAmount = smoothstep(0.0, 0.8, distFromCenter); // Fade as it expands
            // Apply logarithmic fade: fade = 1 - fadeAmount^fadePower
            // u_fadeAmount range: 0 to 5.0
            // Higher values create more gradual fades
            float fadePower = 1.0 + u_fadeAmount * 2.0; // Range: 1.0 to 11.0 when u_fadeAmount is 0 to 5
            float fade = 1.0 - pow(fadeAmount, fadePower);
            
            // Decay factor: reduce brightness over time to prevent accumulation
            // Estimate age based on distance (further = older = more decay)
            float ageEstimate = distFromCenter * 2.0; // Rough estimate of "age"
            float decayRate = 0.98; // Decay 2% per frame (adjustable)
            float decay = pow(decayRate, ageEstimate); // Exponential decay
            
            // Hue shift based on expansion
            float hueShift = distFromCenter * u_hueShiftAmount; // Use parameterized hue shift
            
            // Convert RGB to HSV, shift hue, convert back
            vec3 hsv = rgb2hsv(history.rgb);
            hsv.x = fract(hsv.x + hueShift); // Shift hue (wrap around)
            hsv.z *= fade * decay; // Apply both fade and decay to value
            vec3 shiftedColor = hsv2rgb(hsv);
            
            // Apply simple radial blur based on u_blurAmount (time-based application)
            if (u_blurAmount > 0.0 && u_blurRate > 0.0) {
                // Calculate interval: rate 1.0 = every 2 seconds, rate 0.5 = every 4 seconds, etc.
                float blurInterval = 2.0 / u_blurRate;
                // Apply blur during a small window (0.1 seconds) of each interval
                float blurWindow = 0.1;
                float blurPhase = mod(u_time, blurInterval);
                if (blurPhase < blurWindow) {
                    float blurRadius = 1.5 * u_blurAmount / u_resolution.x;
                    vec4 sum = vec4(shiftedColor, history.a);
                    float count = 1.0;
                    for (int i = 0; i < 6; i++) {
                        float a = float(i) / 6.0 * 6.28318;
                        vec2 offset = vec2(cos(a), sin(a)) * blurRadius;
                        sum += texture2D(u_history, uv + offset);
                        count += 1.0;
                    }
                    shiftedColor = (sum / count).rgb;
                }
            }
            
            // Apply animated noise based on u_noiseAmount and u_noiseRate (time-based application)
            if (u_noiseAmount > 0.0 && u_noiseRate > 0.0) {
                // Calculate interval: rate 1.0 = every 2 seconds, rate 0.5 = every 4 seconds, etc.
                float noiseInterval = 2.0 / u_noiseRate;
                // Apply noise during a small window (0.1 seconds) of each interval
                float noiseWindow = 0.1;
                float noisePhase = mod(u_time, noiseInterval);
                if (noisePhase < noiseWindow) {
                    float t = u_time * 10.0; // Animation speed within the window
                    float n = fract(sin(dot(uv * (t + 1.0), vec2(12.9898,78.233))) * 43758.5453);
                    vec3 grain = mix(vec3(1.0), vec3(n), u_noiseAmount);
                    shiftedColor *= grain;
                }
            }
            
            // Clamp to prevent overflow from additive blending
            shiftedColor = clamp(shiftedColor, 0.0, 1.0);
            
            gl_FragColor = vec4(shiftedColor, history.a * fade * decay);
        }
    </script>
    <script src="./lucas_backup_files/gif.js.download"></script>
    <script src="./lucas_backup_files/analyzer.js.download"></script>
    <script src="./lucas_backup_files/legend.js.download"></script>
    <script src="./lucas_backup_files/meters.js.download"></script>
    
    <div id="hotkey-legend">
        <h4>Hotkeys</h4>
        <div class="hotkey-item">
            <span class="hotkey-key">Space</span>
            <span class="hotkey-desc">Toggle Freeze</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">R</span>
            <span class="hotkey-desc">Randomize</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">← →</span>
            <span class="hotkey-desc">Cycle Presets</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">J</span>
            <span class="hotkey-desc">Toggle Jiggle</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">Esc</span>
            <span class="hotkey-desc">Clear Screen</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↑</span>
            <span class="hotkey-desc">Accelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↓</span>
            <span class="hotkey-desc">Decelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">S</span>
            <span class="hotkey-desc">Snapshot (PNG)</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">G</span>
            <span class="hotkey-desc">Record GIF (max 10s)</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">1</span>
            <span class="hotkey-desc">Toggle Interpolation</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">V</span>
            <span class="hotkey-desc">Toggle Visual Menu</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">M</span>
            <span class="hotkey-desc">Toggle Audio Mappings</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">A</span>
            <span class="hotkey-desc">Toggle Audio Analysis</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">H</span>
            <span class="hotkey-desc">Toggle Last Selected Menu</span>
        </div>
    </div>
    
    <div id="status-indicators" style="top: 340px; left: 10px;">
        <span id="freeze-indicator" style="display: none; background: rgb(0, 170, 255); color: rgb(255, 255, 255);">FREEZE</span>
        <span id="jiggle-indicator" style="display: none; background: rgb(170, 0, 170); color: rgb(255, 255, 255);">JIGGLE</span>
        <span id="audio-indicator" style="display: inline-block; background: rgb(0, 255, 0); color: rgb(0, 0, 0);">AUDIO</span>
        <span id="unsaved-indicator" style="display: none; background: #fa0; color: #fff;">UNSAVED</span>
        <span id="record-indicator" style="display: none; background: #e33; color: #fff;">RECORD</span>
    </div>
    
    <div id="ux-toolbox" style="top: 360px; left: 10px;">
        <h4>Audio Reactive</h4>
        
        <div id="audio-controls" style="background: rgba(20, 20, 20, 0.5); border: 1px solid #444; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
            <h4 style="margin: 0 0 6px 0; font-size: 9px; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; border-bottom: 1px solid #333; padding-bottom: 4px;">Audio Input</h4>
            <select id="audio-device-select" style="width: 100%; font-size: 9px; padding: 3px; margin-bottom: 4px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;" disabled=""><option value="">Default (System Default)</option><option value="9736bca451f6d060799cbb225bdc55c8a84a19a856a24775f63da9168ae5474a">Stereo Mix (Realtek(R) Audio)</option><option value="3ee8048ea9671314de68426c523c531c060202ca7db038d018bcd43bd3baea4b">Microphone (Realtek(R) Audio)</option><option value="3dfea30ecb0bcbd76b62ee3ac7a3f3155a132dacb16d3e23b9b47ec6a6a053cc">Headset Microphone (Oculus Virtual Audio Device)</option><option value="default">Default - Stereo Mix (Realtek(R) Audio)</option><option value="communications">Communications - Headset Microphone (Oculus Virtual Audio Device)</option></select>
            <button id="enable-audio-btn" style="width: 100%; font-size: 9px; padding: 4px; margin-bottom: 4px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Disable Audio</button>
            <div id="audio-status" style="font-size: 8px; color: rgb(0, 255, 0); margin-bottom: 4px;">Audio: STEREO</div>
            <div class="audio-reactive-toggle" style="display: flex; align-items: center; gap: 6px; margin-top: 4px;">
                <input type="checkbox" id="audio-reactive-enabled" checked="" style="cursor: pointer;">
                <label for="audio-reactive-enabled" style="font-size: 9px; color: #bbb; cursor: pointer; margin: 0;">Audio Reactive Mode</label>
            </div>
        </div>
        
        <div id="audio-events-controls" style="background: rgba(20, 20, 20, 0.5); border: 1px solid #444; border-radius: 4px; padding: 8px; margin-top: 10px;">
            <h4 style="margin: 0 0 6px 0; font-size: 9px; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; border-bottom: 1px solid #333; padding-bottom: 4px;">Audio Events</h4>
            <div style="font-size: 8px; color: #888; margin-bottom: 6px;">Detect song changes and structural moments</div>
            <div id="audio-events-config" style="display: flex; flex-direction: column; gap: 4px;">
                <!-- Event triggers will be generated dynamically -->
            <div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 3px;"><div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="event-enabled-songChange" style="margin: 0px; cursor: pointer;"><label for="event-enabled-songChange" style="font-size: 9px; font-weight: 600; color: rgb(0, 170, 255); cursor: pointer;">Song Change</label></div><div id="event-actions-songChange" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;"><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Flip Dilation Polarity</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Toggle Jiggle</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Randomize Parameters</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Next Preset</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Previous Preset</button></div></div><div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 3px;"><div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="event-enabled-chorus" style="margin: 0px; cursor: pointer;"><label for="event-enabled-chorus" style="font-size: 9px; font-weight: 600; color: rgb(0, 170, 255); cursor: pointer;">Chorus</label></div><div id="event-actions-chorus" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;"><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Flip Dilation Polarity</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Toggle Jiggle</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Randomize Parameters</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Next Preset</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Previous Preset</button></div></div><div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 3px;"><div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="event-enabled-verse" style="margin: 0px; cursor: pointer;"><label for="event-enabled-verse" style="font-size: 9px; font-weight: 600; color: rgb(0, 170, 255); cursor: pointer;">Verse</label></div><div id="event-actions-verse" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;"><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Flip Dilation Polarity</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Toggle Jiggle</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Randomize Parameters</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Next Preset</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Previous Preset</button></div></div><div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 3px;"><div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="event-enabled-drop" style="margin: 0px; cursor: pointer;"><label for="event-enabled-drop" style="font-size: 9px; font-weight: 600; color: rgb(0, 170, 255); cursor: pointer;">Drop</label></div><div id="event-actions-drop" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;"><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Flip Dilation Polarity</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Toggle Jiggle</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Randomize Parameters</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Next Preset</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Previous Preset</button></div></div><div style="margin-bottom: 8px; padding: 6px; background: rgba(255, 255, 255, 0.02); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 3px;"><div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="event-enabled-tonalShift" style="margin: 0px; cursor: pointer;"><label for="event-enabled-tonalShift" style="font-size: 9px; font-weight: 600; color: rgb(0, 170, 255); cursor: pointer;">Tonal Shift</label></div><div id="event-actions-tonalShift" style="display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px;"><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Flip Dilation Polarity</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Toggle Jiggle</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Randomize Parameters</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Next Preset</button><button style="font-size: 8px; padding: 2px 6px; background: rgb(51, 51, 51); border: 1px solid rgb(85, 85, 85); border-radius: 2px; color: rgb(187, 187, 187); cursor: pointer;">Previous Preset</button></div></div></div>
        </div>
        
        <div class="section-header collapsed" id="interpolation-settings-header" style="margin-top: 0; margin-bottom: 6px; padding-top: 8px; border-top: 1px solid #333; cursor: pointer;">
            <span>Smooth Interpolation</span>
        </div>
        <div id="interpolation-settings-content" style="display: none; padding-left: 8px;">
            <div class="control-group">
                <label>
                    <input type="checkbox" id="interpolation-enabled" checked="">
                    <span style="margin-left: 6px;">Enabled</span>
                </label>
            </div>
            
            <div class="control-group">
                <label for="interpolation-duration-slider">Duration (s)</label>
                <div class="control-row">
                    <input type="range" id="interpolation-duration-slider" min="0.05" max="2.0" value="0.5" step="0.05">
                    <div class="value" contenteditable="true" id="interpolation-duration-value">0.50</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="interpolation-easing-select">Easing Type</label>
                <select id="interpolation-easing-select" style="width: 100%; font-size: 9px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                    <option value="linear">Linear</option>
                    <option value="easeInOut" selected="">Ease In-Out</option>
                    <option value="easeIn">Ease In</option>
                    <option value="easeOut">Ease Out</option>
                    <option value="spring">Spring</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="interpolation-spring-slider">Spring Constant</label>
                <div class="control-row">
                    <input type="range" id="interpolation-spring-slider" min="0.01" max="0.5" value="0.1" step="0.01">
                    <div class="value" contenteditable="true" id="interpolation-spring-value">0.10</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="interpolation-damping-slider">Damping</label>
                <div class="control-row">
                    <input type="range" id="interpolation-damping-slider" min="0.5" max="0.99" value="0.8" step="0.01">
                    <div class="value" contenteditable="true" id="interpolation-damping-value">0.80</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="interpolation-rotation-spring" checked="">
                    <span style="margin-left: 6px;">Use Spring for Rotation</span>
                </label>
            </div>
        </div>
    </div>
    
    <!-- Audio Visualization Panel (left side) -->
    <div id="audio-visualization-panel" style="display: none;">
        <h3>Audio Analysis</h3>
        <div id="audio-meters-container"><div class="meter-container" data-metric-name="coherence">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Coherence</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-coherence" style="width: 61.1962%; background-color: rgb(255, 255, 0);"></div>
                </div>
                <div class="meter-value" id="value-coherence">0.61</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-coherence">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-coherence" data-metric="coherence" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-coherence" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-coherence" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-coherence" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div><div class="meter-container" data-metric-name="mud">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Mud</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-mud" style="width: 51.967%; background-color: rgb(255, 255, 0);"></div>
                </div>
                <div class="meter-value" id="value-mud">0.52</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-mud">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-mud" data-metric="mud" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-mud" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-mud" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-mud" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div><div class="meter-container" data-metric-name="harshness">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Harshness</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-harshness" style="width: 35.5387%; background-color: rgb(255, 255, 0);"></div>
                </div>
                <div class="meter-value" id="value-harshness">0.36</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-harshness">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-harshness" data-metric="harshness" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-harshness" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-harshness" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-harshness" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div><div class="meter-container" data-metric-name="compression">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Compression</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-compression" style="width: 81.3212%; background-color: rgb(255, 0, 0);"></div>
                </div>
                <div class="meter-value" id="value-compression">0.81</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-compression">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-compression" data-metric="compression" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-compression" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-compression" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-compression" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div><div class="meter-container" data-metric-name="collision">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Collision</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-collision" style="width: 3.12106%; background-color: rgb(0, 255, 0);"></div>
                </div>
                <div class="meter-value" id="value-collision">0.03</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-collision">rings</div>
                <div class="stability-visualizer" id="stability-visualizer-collision" data-metric="collision" style="cursor: pointer;">
                <div class="stability-rings-container">
                    <div class="stability-ring" id="stability-1bar-collision" title="1 bar stability">
                        <svg width="16" height="16" viewBox="0 0 16 16">
                            <circle class="ring-bg" cx="8" cy="8" r="6" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"></circle>
                            <circle class="ring-fill" cx="8" cy="8" r="6" fill="none" stroke="#ff0" stroke-width="1" stroke-dasharray="24.015787075563257 37.69911184307752" transform="rotate(-90 8 8)" stroke-dashoffset="13.68332476751426"></circle>
                        </svg>
                    </div>
                    <div class="stability-ring" id="stability-2bar-collision" title="2 bar stability">
                        <svg width="16" height="16" viewBox="0 0 16 16">
                            <circle class="ring-bg" cx="8" cy="8" r="6" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"></circle>
                            <circle class="ring-fill" cx="8" cy="8" r="6" fill="none" stroke="#ff0" stroke-width="1" stroke-dasharray="24.30576544638681 37.69911184307752" transform="rotate(-90 8 8)" stroke-dashoffset="13.393346396690704"></circle>
                        </svg>
                    </div>
                    <div class="stability-ring" id="stability-4bar-collision" title="4 bar stability">
                        <svg width="16" height="16" viewBox="0 0 16 16">
                            <circle class="ring-bg" cx="8" cy="8" r="6" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"></circle>
                            <circle class="ring-fill" cx="8" cy="8" r="6" fill="none" stroke="#ff0" stroke-width="1" stroke-dasharray="24.41705525999149 37.69911184307752" transform="rotate(-90 8 8)" stroke-dashoffset="13.282056583086028"></circle>
                        </svg>
                    </div>
                </div>
            </div>
            </div>
        </div><div class="meter-container" data-metric-name="phaseRisk">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>PhaseRisk</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-phaseRisk" style="width: 0.389573%; background-color: rgb(0, 255, 0);"></div>
                </div>
                <div class="meter-value" id="value-phaseRisk">0.00</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-phaseRisk">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-phaseRisk" data-metric="phaseRisk" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-phaseRisk" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-phaseRisk" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-phaseRisk" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div><div class="meter-container" data-metric-name="audioAmp">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Amp</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-audioAmp" style="width: 5.72133%; background-color: rgb(0, 255, 0);"></div>
                </div>
                <div class="meter-value" id="value-audioAmp">0.06</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-audioAmp">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-audioAmp" data-metric="audioAmp" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-audioAmp" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-audioAmp" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-audioAmp" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div><div class="meter-container" data-metric-name="bandLow">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Low</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-bandLow" style="width: 29.1808%; background-color: rgb(64, 29, 14);"></div>
                </div>
                <div class="meter-value" id="value-bandLow">0.29</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-bandLow">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-bandLow" data-metric="bandLow" style="cursor: pointer;">
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-bandLow" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-bandLow" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-bandLow" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            </div>
            </div>
        </div><div class="meter-container" data-metric-name="bandMid">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>Mid</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-bandMid" style="width: 43.1102%; background-color: rgb(77, 86, 51);"></div>
                </div>
                <div class="meter-value" id="value-bandMid">0.43</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-bandMid">rings</div>
                <div class="stability-visualizer" id="stability-visualizer-bandMid" data-metric="bandMid" style="cursor: pointer;">
                <div class="stability-rings-container">
                    <div class="stability-ring" id="stability-1bar-bandMid" title="1 bar stability">
                        <svg width="16" height="16" viewBox="0 0 16 16">
                            <circle class="ring-bg" cx="8" cy="8" r="6" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"></circle>
                            <circle class="ring-fill" cx="8" cy="8" r="6" fill="none" stroke="#0f0" stroke-width="1" stroke-dasharray="36.479925403873516 37.69911184307752" transform="rotate(-90 8 8)" stroke-dashoffset="1.2191864392039984"></circle>
                        </svg>
                    </div>
                    <div class="stability-ring" id="stability-2bar-bandMid" title="2 bar stability">
                        <svg width="16" height="16" viewBox="0 0 16 16">
                            <circle class="ring-bg" cx="8" cy="8" r="6" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"></circle>
                            <circle class="ring-fill" cx="8" cy="8" r="6" fill="none" stroke="#0f0" stroke-width="1" stroke-dasharray="36.3283264337368 37.69911184307752" transform="rotate(-90 8 8)" stroke-dashoffset="1.3707854093407204"></circle>
                        </svg>
                    </div>
                    <div class="stability-ring" id="stability-4bar-bandMid" title="4 bar stability">
                        <svg width="16" height="16" viewBox="0 0 16 16">
                            <circle class="ring-bg" cx="8" cy="8" r="6" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"></circle>
                            <circle class="ring-fill" cx="8" cy="8" r="6" fill="none" stroke="#0f0" stroke-width="1" stroke-dasharray="36.0239510921264 37.69911184307752" transform="rotate(-90 8 8)" stroke-dashoffset="1.6751607509511117"></circle>
                        </svg>
                    </div>
                </div>
            </div>
            </div>
        </div><div class="meter-container" data-metric-name="bandHigh">
            <div class="meter-label"><canvas width="20" height="20" style="width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.4); border-radius: 2px; margin-left: 4px; margin-right: 4px; vertical-align: middle; display: inline-block; image-rendering: pixelated;"></canvas>High</div>
            <div class="meter-wrapper">
                <div class="meter-bar">
                    <div class="meter-fill" id="meter-bandHigh" style="width: 27.2256%; background-color: rgb(13, 40, 69);"></div>
                </div>
                <div class="meter-value" id="value-bandHigh">0.27</div>
            </div>
            <div class="stability-wrapper">
                <div class="stability-label" id="mode-label-bandHigh">waveform</div>
                <div class="stability-visualizer" id="stability-visualizer-bandHigh" data-metric="bandHigh" style="cursor: pointer;">
                    
                <div class="stability-waveform-container">
                    <canvas class="stability-waveform" id="stability-1bar-bandHigh" title="1 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-2bar-bandHigh" title="2 bar stability" width="30" height="8"></canvas>
                    <canvas class="stability-waveform" id="stability-4bar-bandHigh" title="4 bar stability" width="30" height="8"></canvas>
                </div>
            
                </div>
            </div>
        </div></div>
    </div>
    
    <!-- Audio Mappings Panel (right side) -->
    <div id="audio-mappings-panel" style="display: none; top: 10px; right: 10px;">
        <h3>Audio Mappings</h3>
        <div id="audio-mappings-content"><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-spikiness" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">spikiness</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(collision)</span><span id="mapping-value-spikiness" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.890</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-spikiness" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-spikiness" contenteditable="true">0.7</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-spikiness" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-spikiness" contenteditable="true">0.80</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-spikeFrequency" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">spikeFrequency</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(bandEnergy)</span><span id="mapping-value-spikeFrequency" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.314</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-spikeFrequency" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-spikeFrequency" contenteditable="true">2.5</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-spikeFrequency" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-spikeFrequency" contenteditable="true">0.59</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-spikeSharpness" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">spikeSharpness</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(harshness)</span><span id="mapping-value-spikeSharpness" style="font-size: 8px; font-family: monospace; color: rgb(136, 136, 136); margin-left: auto;">0.000</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-spikeSharpness" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-spikeSharpness" contenteditable="true">0.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-spikeSharpness" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-spikeSharpness" contenteditable="true">0.80</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-hue" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">hue</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(bandEnergy)</span><span id="mapping-value-hue" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.361</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-hue" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-hue" contenteditable="true">3.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-hue" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-hue" contenteditable="true">0.50</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-scale" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">scale</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(audioAmp)</span><span id="mapping-value-scale" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.867</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-scale" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-scale" contenteditable="true">3.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-scale" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-scale" contenteditable="true">0.62</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-emanationRate" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">emanationRate</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(audioAmp)</span><span id="mapping-value-emanationRate" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.865</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-emanationRate" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-emanationRate" contenteditable="true">1.7</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-emanationRate" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-emanationRate" contenteditable="true">0.69</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-dilationSpeed" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">dilationSpeed</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(coherence)</span><span id="mapping-value-dilationSpeed" style="font-size: 8px; font-family: monospace; color: rgb(0, 255, 0); margin-left: auto;">0.229</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-dilationSpeed" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-dilationSpeed" contenteditable="true">0.9</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-dilationSpeed" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-dilationSpeed" contenteditable="true">0.66</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-fadeAmount" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">fadeAmount</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(mud)</span><span id="mapping-value-fadeAmount" style="font-size: 8px; font-family: monospace; color: rgb(136, 136, 136); margin-left: auto;">0.000</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-fadeAmount" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-fadeAmount" contenteditable="true">1.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-fadeAmount" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-fadeAmount" contenteditable="true">0.85</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-fillOpacity" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">fillOpacity</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(compression)</span><span id="mapping-value-fillOpacity" style="font-size: 8px; font-family: monospace; color: rgb(136, 136, 136); margin-left: auto;">0.000</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-fillOpacity" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-fillOpacity" contenteditable="true">1.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-fillOpacity" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-fillOpacity" contenteditable="true">0.85</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-autoRotationSpeed" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">autoRotationSpeed</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(phaseRisk)</span><span id="mapping-value-autoRotationSpeed" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.990</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-autoRotationSpeed" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-autoRotationSpeed" contenteditable="true">2.1</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-autoRotationSpeed" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-autoRotationSpeed" contenteditable="true">0.90</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-hueShiftAmount" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">hueShiftAmount</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(stereoWidth)</span><span id="mapping-value-hueShiftAmount" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.994</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-hueShiftAmount" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-hueShiftAmount" contenteditable="true">1.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-hueShiftAmount" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-hueShiftAmount" contenteditable="true">0.55</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-noiseAmount" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">noiseAmount</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(harshness)</span><span id="mapping-value-noiseAmount" style="font-size: 8px; font-family: monospace; color: rgb(136, 136, 136); margin-left: auto;">0.000</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-noiseAmount" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-noiseAmount" contenteditable="true">3.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-noiseAmount" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-noiseAmount" contenteditable="true">0.98</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-blendOpacity" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">blendOpacity</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(coherence)</span><span id="mapping-value-blendOpacity" style="font-size: 8px; font-family: monospace; color: rgb(136, 136, 136); margin-left: auto;">0.000</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-blendOpacity" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-blendOpacity" contenteditable="true">2.4</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-blendOpacity" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-blendOpacity" contenteditable="true">0.90</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-fillSize" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">fillSize</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(compression)</span><span id="mapping-value-fillSize" style="font-size: 8px; font-family: monospace; color: rgb(0, 255, 0); margin-left: auto;">0.609</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-fillSize" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-fillSize" contenteditable="true">1.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-fillSize" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-fillSize" contenteditable="true">0.85</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-noiseRate" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">noiseRate</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(collision)</span><span id="mapping-value-noiseRate" style="font-size: 8px; font-family: monospace; color: rgb(255, 0, 0); margin-left: auto;">-0.890</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-noiseRate" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-noiseRate" contenteditable="true">1.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-noiseRate" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-noiseRate" contenteditable="true">0.80</div></div></div><div class="control-group"><label style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;"><input type="checkbox" id="mapping-enabled-blurRate" style="margin: 0px; cursor: pointer;"><span style="font-weight: 600; color: rgb(0, 170, 255);">blurRate</span><span style="font-size: 8px; color: rgb(136, 136, 136); font-style: italic;">(mud)</span><span id="mapping-value-blurRate" style="font-size: 8px; font-family: monospace; color: rgb(0, 255, 0); margin-left: auto;">0.006</span></label><div class="control-row" style="margin-bottom: 4px;"><label style="min-width: 70px; font-size: 9px;">Sensitivity</label><input type="range" id="mapping-sensitivity-blurRate" min="0" max="3" step="0.1"><div class="value" id="mapping-sensitivity-value-blurRate" contenteditable="true">1.0</div></div><div class="control-row"><label style="min-width: 70px; font-size: 9px;">Smoothing</label><input type="range" id="mapping-smoothing-blurRate" min="0.5" max="0.99" step="0.01"><div class="value" id="mapping-smoothing-value-blurRate" contenteditable="true">0.85</div></div></div></div>
    </div>
    
    <div id="dev-toolbox">
        <h3>Controls</h3>
        
        <div class="control-group">
            <label for="preset-select">Preset</label>
            <select id="preset-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;"><option value="">-- Select Preset --</option><option value="Burn">Burn</option><option value="Rainbow">Rainbow</option><option value="Spray">Spray</option><option value="Flower">Flower</option><option value="Portal">Portal</option><option value="Braid">Braid</option><option value="Pool">Pool</option><option value="Cross">Cross</option><option value="Wash">Wash</option><option value="Wiggle">Wiggle</option><option value="VHS">VHS</option><option value="Dive">Dive</option><option value="JiggleFreezeGlitch">JiggleFreezeGlitch</option><option value="Conch">Conch</option><option value="Smoke">Smoke</option><option value="Corduroy">Corduroy</option><option value="Moire">Moire</option><option value="Conway">Conway</option><option value="Doughnut">Doughnut</option><option value="Sparkle">Sparkle</option><option value="Slurry">Slurry</option><option value="Gunbuster">Gunbuster</option><option value="EYELINER">EYELINER</option><option value="Ekhart">Ekhart</option><option value="RainbowSwim">RainbowSwim</option><option value="Megacross">Megacross</option><option value="Feather">Feather</option><option value="Gas">Gas</option><option value="Oasis">Oasis</option><option value="Daisy">Daisy</option><option value="Ryan">Ryan</option><option value="Cosm">Cosm</option><option value="Starwash">Starwash</option><option value="Oyster">Oyster</option><option value="p3n0r">p3n0r</option><option value="Peacock">Peacock</option><option value="RecycledColors">RecycledColors</option><option value="RaveSoap">RaveSoap</option><option value="TyeDyed">TyeDyed</option><option value="WadingRainbow">WadingRainbow</option><option value="JiggleStorm">JiggleStorm</option><option value="LUCAS">LUCAS</option><option value="BUMPER">BUMPER</option><option value="WONDERWELL">WONDERWELL</option><option value="HUELOOP">HUELOOP</option><option value="GUMMY">GUMMY</option></select>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <input type="text" id="preset-name-input" placeholder="Name" style="flex: 1; font-size: 10px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <button id="save-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                <button id="delete-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #a00; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Del</button>
            </div>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <button id="export-presets-btn" style="font-size: 10px; padding: 3px 6px; background: #0a0; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Export</button>
                <label for="import-presets-input" style="font-size: 10px; padding: 3px 6px; background: #fa0; color: #fff; border: none; border-radius: 3px; cursor: pointer; display: inline-block; height: auto; line-height: normal; box-sizing: border-box;">Import</label>
                <input type="file" id="import-presets-input" accept=".json,.txt" style="display: none;">
            </div>
        </div>
        
        <div class="section-header">Resolution</div>
        <div class="control-group">
            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                <button id="res-4k-btn" class="resolution-btn" data-resolution="4k" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">4K UHD</button>
                <button id="res-pc-btn" class="resolution-btn" data-resolution="pc" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Full HD</button>
                <button id="res-mobile-btn" class="resolution-btn" data-resolution="mobile" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Mobile</button>
                <button id="res-window-btn" class="resolution-btn active" data-resolution="window" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Window</button>
            </div>
            <div id="current-resolution-display" style="margin-top: 4px; font-size: 9px; color: #aaa;">Current: Window Size</div>
        </div>
        
        <div class="section-header">Shape</div>
        <div class="control-group">
            <label for="spikiness-slider">Spikiness<span class="curve-btn" data-param="spikiness" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spikiness-slider" min="0" max="100" value="50" step="1">
                <div class="value" contenteditable="true" id="spikiness-value">0.65</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-frequency-slider">Frequency<span class="curve-btn" data-param="spikeFrequency" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spike-frequency-slider" min="2" max="20" value="5" step="0.1">
                <div class="value" contenteditable="true" id="spike-frequency-value">22.8</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-sharpness-slider">Sharpness<span class="curve-btn" data-param="spikeSharpness" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spike-sharpness-slider" min="0" max="100" value="0" step="1">
                <div class="value" contenteditable="true" id="spike-sharpness-value">0.79</div>
            </div>
        </div>
        
        <div class="section-header">Appearance</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-slider">Hue<span class="curve-btn" data-param="hue" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="hue-slider" min="0" max="360" value="45" step="1">
                    <div class="value" contenteditable="true" id="hue-value">163.14380348484315°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="scale-slider">Scale<span class="curve-btn" data-param="scale" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="scale-slider" min="0.05" max="1.0" value="0.2" step="0.01">
                    <div class="value" contenteditable="true" id="scale-value">4.73</div>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="control-group">
                <label for="fill-size-slider">Fill Size<span class="curve-btn" data-param="fillSize" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="fill-size-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="fill-size-value">0.36</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="fill-opacity-slider">Fill Opacity<span class="curve-btn" data-param="fillOpacity" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="fill-opacity-slider" min="0" max="100" value="60" step="1">
                    <div class="value" contenteditable="true" id="fill-opacity-value">0.85</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Emanation</div>
        <div class="control-group">
            <label for="dilation-slider">Dilation Speed<span class="curve-btn" data-param="dilationSpeed" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="dilation-slider" min="0" max="200" value="20" step="1">
                <div class="value" contenteditable="true" id="dilation-value">0.9218</div>
            </div>
            <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-top: 4px; cursor: pointer;">
                <input type="checkbox" id="dilation-polarity-flip">
                <span>Flip Polarity (reflect over 1.0)</span>
            </label>
        </div>
        
        <div class="control-group">
            <label for="fade-slider">Fade Amount<span class="curve-btn" data-param="fadeAmount" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="fade-slider" min="0" max="100" value="30" step="1">
                <div class="value" contenteditable="true" id="fade-value">3.018</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="emanation-rate-slider">Rate (per sec)<span class="curve-btn" data-param="emanationRate" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="emanation-rate-slider" min="2" max="200" value="2" step="0.1">
                <div class="value" contenteditable="true" id="emanation-rate-value">127.2</div>
            </div>
        </div>
        
        <div class="section-header">Filters</div>
        <div class="two-column">
            <div class="control-group">
                <label for="noise-amount-slider">Noise Amount<span class="curve-btn" data-param="noiseAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="noise-amount-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="noise-amount-value">0.06</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="noise-rate-slider">Noise Rate (1.0 = every 2s)<span class="curve-btn" data-param="noiseRate" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="noise-rate-slider" min="0" max="100" value="0" step="0.1">
                    <div class="value" contenteditable="true" id="noise-rate-value">7.76</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blur-amount-slider">Blur Amount<span class="curve-btn" data-param="blurAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blur-amount-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="blur-amount-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blur-rate-slider">Blur Rate (1.0 = every 2s)<span class="curve-btn" data-param="blurRate" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blur-rate-slider" min="0" max="100" value="0" step="0.1">
                    <div class="value" contenteditable="true" id="blur-rate-value">1.75</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Rotation</div>
        <div class="two-column">
            <div class="control-group">
                <label for="rotation-slider">Manual<span class="curve-btn" data-param="rotation" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="rotation-slider" min="0" max="360" value="0" step="1">
                    <div class="value" contenteditable="true" id="rotation-value">5.6644146367928965°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="auto-rotation-slider">Auto (deg/s)<span class="curve-btn" data-param="autoRotationSpeed" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="auto-rotation-slider" min="0" max="200" value="50" step="1">
                    <div class="value" contenteditable="true" id="auto-rotation-value">-1.0°</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Effects</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-shift-slider">Hue Shift<span class="curve-btn" data-param="hueShiftAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="hue-shift-slider" min="0.0" max="0.2" value="0.05" step="0.001">
                    <div class="value" contenteditable="true" id="hue-shift-value">22.200</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blend-opacity-slider">Opacity<span class="curve-btn" data-param="blendOpacity" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blend-opacity-slider" min="0.0" max="1.0" value="0.3" step="0.01">
                    <div class="value" contenteditable="true" id="blend-opacity-value">0.25</div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="blend-mode-select">Blend Mode</label>
            <select id="blend-mode-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="additive">Additive</option>
                <option value="alpha" selected="">Alpha Blend</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
            </select>
        </div>
        
        <div class="section-header">Actions</div>
        <div class="control-group">
            <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                <button id="randomize-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Randomize</button>
                <button id="jiggle-btn" style="flex: 1 1 0%; font-size: 10px; padding: 6px; background: rgb(170, 0, 170); color: rgb(255, 255, 255); border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Jiggle</button>
            </div>
            <label for="jiggle-amount-slider">Jiggle Amount<span class="curve-btn" data-param="jiggleAmount" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="jiggle-amount-slider" min="0" max="100" value="10" step="1">
                <div class="value" contenteditable="true" id="jiggle-amount-value">96%</div>
            </div>
            
            <div class="section-header" id="jiggle-settings-header" style="margin-top: 8px; margin-bottom: 6px; padding-top: 8px; border-top: 1px solid rgb(51, 51, 51); cursor: pointer; user-select: none;">
                <span>Jiggle Settings</span>
            </div>
            <div id="jiggle-settings-content" style="display: block; padding-left: 8px;">
                <div style="display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap;">
                    <button id="jiggle-all-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">All</button>
                    <button id="jiggle-none-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">None</button>
                    <button id="jiggle-shape-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Shape</button>
                    <button id="jiggle-appearance-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Appearance</button>
                </div>
                <div style="font-size: 9px; color: #888; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Shape</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-spikiness" checked="">
                    <span>Spikiness</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-spikeFrequency" checked="">
                    <span>Frequency</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-spikeSharpness" checked="">
                    <span>Sharpness</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Appearance</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-hue" checked="">
                    <span>Hue</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-scale" checked="">
                    <span>Scale</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-fillSize" checked="">
                    <span>Fill Size</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-fillOpacity" checked="">
                    <span>Fill Opacity</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Emanation</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-dilationSpeed" checked="">
                    <span>Dilation Speed</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-fadeAmount" checked="">
                    <span>Fade Amount</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-emanationRate" checked="">
                    <span>Rate</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Filters</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-noiseAmount" checked="">
                    <span>Noise Amount</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-noiseRate" checked="">
                    <span>Noise Rate</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-blurAmount" checked="">
                    <span>Blur Amount</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-blurRate" checked="">
                    <span>Blur Rate</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Rotation</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-autoRotationSpeed" checked="">
                    <span>Auto Rotation</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Effects</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-hueShiftAmount" checked="">
                    <span>Hue Shift</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-blendOpacity" checked="">
                    <span>Blend Opacity</span>
                </label>
            </div>
        </div>
        
        <div class="section-header collapsed" id="debug-values-header" style="margin-top: 8px; margin-bottom: 6px; padding-top: 8px; border-top: 1px solid #333; cursor: pointer;">
            <span>Debug Values</span>
        </div>
        <div id="debug-values-content" style="display: none; padding-left: 8px;" data-_display="block">
            <div id="debug-output" style="font-size: 8px; font-family: monospace; color: #aaa; line-height: 1.4; max-height: 400px; overflow-y: auto; background: #1a1a1a; padding: 6px; border-radius: 3px; border: 1px solid #333; white-space: pre-wrap;">
                <!-- Debug values will be populated here -->
            </div>
        </div>
    </div>
    
    <script>
        // Resolution configuration
        const RESOLUTIONS = {
            '4k': { width: 3840, height: 2160, name: '4K UHD' },
            'pc': { width: 1920, height: 1080, name: 'Full HD' },
            'mobile': { width: 1080, height: 1920, name: 'Mobile' },
            'window': { width: null, height: null, name: 'Window Size' }
        };
        
        // Parse URL parameters
        function getUrlParam(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        // Get current resolution setting
        let currentResolution = getUrlParam('resolution') || 'window';
        if (!RESOLUTIONS[currentResolution]) {
            currentResolution = 'window';
        }
        
        // ============================================
        // Audio Analyzer Integration
        // ============================================
        
        // Create global audio analyzer instance
        const audioAnalyzer = new AudioAnalyzer();
        let audioEnabled = false;
        let audioReactiveEnabled = true;
        
        // Audio visualization components
        let audioMeters = null;
        let audioLegend = null;
        
        // Audio mapping configuration - RELATIVE OFFSET SYSTEM
        // Maps audio metrics to normalized offsets (-1 to 1) that modulate parameters
        // relative to their base values, using jiggle ranges and enabled params
        //
        // AESTHETIC RATIONALE FOR EACH MAPPING:
        const audioMapping = {
            // SPIKINESS: Driven by collision (transient spikes/overlaps)
            // Rationale: Transient collisions create visual "spikes" - when audio has overlapping
            // transients, the shape becomes more spiky. Clean audio = smoother shapes.
            spikiness: {
                enabled: true,
                source: 'collision',
                smoothing: 0.8,
                sensitivity: 1.0, // Adjustable via UI
                // Maps collision (0-1) to offset (-1 to 1)
                // High collision = positive offset (more spiky)
                transform: (collision) => (collision - 0.5) * 2.0 // Center at 0.5, scale to -1..1
            },
            
            // SPIKE FREQUENCY: Driven by band energy variation (spectral richness)
            // Rationale: Rich, full-spectrum audio creates more complex shapes with more spikes.
            // Sparse audio = simpler shapes. Uses average energy across bands.
            spikeFrequency: {
                enabled: true,
                source: 'bandEnergy',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (bandEnergy) => {
                    const [low, mid, high] = bandEnergy;
                    const avgEnergy = (low + mid + high) / 3;
                    // Map energy (0-1) to offset (-1 to 1), centered around 0.5
                    return (avgEnergy - 0.5) * 2.0;
                }
            },
            
            // SPIKE SHARPNESS: Driven by harshness (high-frequency content)
            // Rationale: Harsh, bright audio creates sharper, more angular shapes.
            // Smooth audio = rounded shapes. High frequencies = sharp visual spikes.
            spikeSharpness: {
                enabled: true,
                source: 'harshness',
                smoothing: 0.8,
                sensitivity: 1.0,
                transform: (harshness) => harshness * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // HUE: Driven by band energy distribution (spectral color)
            // Rationale: Low frequencies = warm colors (red/orange), mid = green, high = cool (blue).
            // Creates color shifts that reflect the spectral content of the audio.
            hue: {
                enabled: true,
                source: 'bandEnergy',
                smoothing: 0.9,
                sensitivity: 1.0,
                transform: (bandEnergy) => {
                    const [low, mid, high] = bandEnergy;
                    // Weighted hue: low=0°, mid=120°, high=240°
                    const weightedHue = (low * 0 + mid * 120 + high * 240) / (low + mid + high + 0.001);
                    // Normalize to 0-360, then convert to offset (-1 to 1) relative to current hue
                    // This creates a relative offset, not absolute hue
                    // Return normalized value that will be used as offset multiplier
                    const normalizedHue = weightedHue / 360.0;
                    return (normalizedHue - 0.5) * 2.0; // Center around middle hue
                }
            },
            
            // SCALE: Driven by audio amplitude (volume/loudness)
            // Rationale: Louder audio = larger shapes. Creates pulsing effect that follows
            // the music's dynamics. Quiet passages = smaller, more intimate visuals.
            scale: {
                enabled: true,
                source: 'audioAmp',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (audioAmp) => (audioAmp - 0.5) * 2.0 // Center at 0.5, scale to -1..1
            },
            
            // EMANATION RATE: Driven by audio amplitude (rhythmic pulsing)
            // Rationale: Faster music = more frequent shape emissions. Creates visual rhythm
            // that matches the beat. Loud passages emit shapes more rapidly.
            emanationRate: {
                enabled: true,
                source: 'audioAmp',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (audioAmp) => audioAmp * 2.0 - 1.0 // 0-1 to -1..1 (positive bias for faster)
            },
            
            // DILATION SPEED: Driven by coherence (audio clarity)
            // Rationale: Clean, coherent audio = faster expansion (confident, clear visuals).
            // Muddy/chaotic audio = slower expansion (uncertain, hesitant visuals).
            // Creates visual metaphor for audio quality.
            dilationSpeed: {
                enabled: true,
                source: 'coherence',
                smoothing: 0.9,
                sensitivity: 1.0,
                transform: (coherence) => coherence * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // FADE AMOUNT: Driven by mud (midrange masking)
            // Rationale: Muddy audio = more fade (visuals fade faster, less persistent).
            // Clean audio = less fade (shapes persist longer, clearer trails).
            fadeAmount: {
                enabled: true,
                source: 'mud',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (mud) => mud * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // FILL OPACITY: Driven by compression (dynamic range)
            // Rationale: Compressed audio (less dynamic range) = more filled shapes (solid).
            // Dynamic audio = more outline-focused shapes (hollow). Reflects audio dynamics.
            fillOpacity: {
                enabled: true,
                source: 'compression',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (compression) => compression * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // AUTO ROTATION SPEED: Driven by phase risk (stereo issues)
            // Rationale: Phase problems = rotation (visual "dizziness" reflects audio problems).
            // Clean stereo = stable rotation. Creates visual metaphor for stereo quality.
            autoRotationSpeed: {
                enabled: true,
                source: 'phaseRisk',
                smoothing: 0.9,
                sensitivity: 1.0,
                transform: (phaseRisk) => phaseRisk * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // HUE SHIFT AMOUNT: Driven by stereo width (spatial spread)
            // Rationale: Wide stereo = more hue shift in dilation (colors shift more as shapes expand).
            // Mono/narrow = less shift. Creates visual representation of spatial audio.
            hueShiftAmount: {
                enabled: true,
                source: 'stereoWidth',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (stereoWidth) => {
                    if (Array.isArray(stereoWidth)) {
                        const avg = (stereoWidth[0] + stereoWidth[1] + stereoWidth[2]) / 3;
                        return avg * 2.0 - 1.0; // 0-1 to -1..1
                    }
                    return 0;
                }
            },
            
            // NOISE AMOUNT: Driven by harshness (high-frequency distortion)
            // Rationale: Harsh, distorted audio = visual noise/grain. Clean audio = smooth visuals.
            // High frequencies create visual "grit" that matches audio texture.
            noiseAmount: {
                enabled: true,
                source: 'harshness',
                smoothing: 0.8,
                sensitivity: 1.0,
                transform: (harshness) => harshness * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // BLEND OPACITY: Driven by coherence (overall audio quality)
            // Rationale: Coherent audio = higher opacity (clear, confident visuals).
            // Chaotic audio = lower opacity (transparent, uncertain visuals).
            // Overall quality metric affects visual presence.
            blendOpacity: {
                enabled: true,
                source: 'coherence',
                smoothing: 0.9,
                sensitivity: 1.0,
                transform: (coherence) => coherence * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // FILL SIZE: Driven by compression (dynamic range)
            // Rationale: Compressed audio = larger fills (more solid shapes).
            // Dynamic audio = smaller fills (more outline-focused). Complements fillOpacity.
            fillSize: {
                enabled: true,
                source: 'compression',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (compression) => compression * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // NOISE RATE: Driven by collision (transient frequency)
            // Rationale: Frequent collisions = more frequent noise bursts.
            // Creates rhythmic noise patterns that match transient density.
            noiseRate: {
                enabled: true,
                source: 'collision',
                smoothing: 0.8,
                sensitivity: 1.0,
                transform: (collision) => collision * 2.0 - 1.0 // 0-1 to -1..1
            },
            
            // BLUR RATE: Driven by mud (midrange complexity)
            // Rationale: Muddy audio = more frequent blur bursts (visual "smearing").
            // Clean audio = less blur. Creates visual metaphor for audio clarity.
            blurRate: {
                enabled: true,
                source: 'mud',
                smoothing: 0.85,
                sensitivity: 1.0,
                transform: (mud) => mud * 2.0 - 1.0 // 0-1 to -1..1
            }
        };
        
        // Smoothed audio-driven offsets (-1 to 1 range)
        const audioDrivenOffsets = {};
        Object.keys(audioMapping).forEach(key => {
            audioDrivenOffsets[key] = 0.0; // Start at 0 (no offset)
        });
        
        // Function to update audio-driven offsets
        function updateAudioDrivenParams(metrics) {
            if (!audioReactiveEnabled || !audioEnabled) {
                // Reset offsets when audio is disabled
                Object.keys(audioDrivenOffsets).forEach(key => {
                    audioDrivenOffsets[key] = 0.0;
                });
                return;
            }
            
            Object.keys(audioMapping).forEach(paramName => {
                const mapping = audioMapping[paramName];
                if (!mapping.enabled) {
                    audioDrivenOffsets[paramName] = 0.0;
                    return;
                }
                
                let rawValue = null;
                
                if (mapping.source === 'bandEnergy' && Array.isArray(metrics.u_bandEnergy)) {
                    rawValue = metrics.u_bandEnergy;
                } else if (mapping.source === 'stereoWidth' && Array.isArray(metrics.u_stereoWidth)) {
                    rawValue = metrics.u_stereoWidth;
                } else {
                    rawValue = metrics[`u_${mapping.source}`];
                }
                
                if (rawValue === null || rawValue === undefined) {
                    audioDrivenOffsets[paramName] = 0.0;
                    return;
                }
                
                // rawValue is already normalized to 0-1 range based on song's min/max from AudioAnalyzer
                // Transform functions convert 0-1 to -1..1 centered at 0.5 (baseline)
                let transformedValue = rawValue;
                if (mapping.transform) {
                    transformedValue = mapping.transform(rawValue);
                } else {
                    // Default transform: map 0-1 to -1..1, centered at 0.5
                    // This ensures normalized min (0.0) → -1, baseline (0.5) → 0, max (1.0) → +1
                    transformedValue = (rawValue - 0.5) * 2.0;
                }
                
                // Clamp to -1..1 range
                // -1 represents the song's minimum (normalized 0.0)
                // 0 represents the song's baseline (normalized 0.5)
                // +1 represents the song's maximum (normalized 1.0)
                const clampedOffset = Math.max(-1.0, Math.min(1.0, transformedValue));
                
                // Apply smoothing
                const currentOffset = audioDrivenOffsets[paramName];
                audioDrivenOffsets[paramName] = currentOffset * mapping.smoothing + clampedOffset * (1 - mapping.smoothing);
            });
        }
        
        // Jiggle range multipliers (same as used in jiggle system)
        const jiggleRanges = {
            spikiness: 1.0,           // jiggleAmount * 1.0
            spikeFrequency: 9.0,      // jiggleAmount * 9.0
            spikeSharpness: 1.0,      // jiggleAmount * 1.0
            hue: 180.0,               // jiggleAmount * 180.0
            scale: 0.3,               // jiggleAmount * 0.3
            fillSize: 1.0,            // jiggleAmount * 1.0
            fillOpacity: 1.0,          // jiggleAmount * 1.0
            hueShiftAmount: 0.1,      // jiggleAmount * 0.1
            dilationSpeed: 0.1,      // jiggleAmount * 0.1
            fadeAmount: 1.0,          // jiggleAmount * 1.0
            emanationRate: 20.0,      // jiggleAmount * 20.0
            autoRotationSpeed: 30.0,  // jiggleAmount * 30.0
            noiseAmount: 0.2,         // jiggleAmount * 0.2
            noiseRate: 2.0,           // jiggleAmount * 2.0
            blurAmount: 0.2,          // jiggleAmount * 0.2
            blurRate: 2.0,            // jiggleAmount * 2.0
            blendOpacity: 0.1         // jiggleAmount * 0.1
        };
        
        // Function to apply audio-driven relative offsets
        // Uses normalized min/max values to span the full jiggle range
        // Normalized 0.0 → minimum of jiggle range, 0.5 → base value, 1.0 → maximum of jiggle range
        function applyAudioReactivity(paramName, baseValue, jiggleEnabledParams, jiggleAmount) {
            if (!audioReactiveEnabled || !audioEnabled) {
                return baseValue;
            }
            
            const mapping = audioMapping[paramName];
            if (!mapping || !mapping.enabled) {
                return baseValue;
            }
            
            // Only apply if parameter is enabled in jiggle settings
            if (jiggleEnabledParams && !jiggleEnabledParams[paramName]) {
                return baseValue;
            }
            
            // Get normalized audio offset (-1 to 1, where 0 = baseline)
            // This offset is already based on normalized min/max values from AudioAnalyzer
            const audioOffset = audioDrivenOffsets[paramName] || 0.0;
            
            // Get jiggle range for this parameter
            const range = jiggleRanges[paramName] || 1.0;
            
            // Get sensitivity multiplier (default 1.0, adjustable via UI)
            // Sensitivity allows fine-tuning the strength of audio reactivity
            const sensitivity = mapping.sensitivity !== undefined ? mapping.sensitivity : 1.0;
            
            // Map normalized audio offset to jiggle range
            // audioOffset is -1..1 (centered at 0, which represents the song's baseline)
            // We map this to span the full jiggle range defined by jiggleAmount
            // Formula: offset = audioOffset * sensitivity * jiggleAmount * range
            // This ensures normalized min/max values span the full jiggle range
            const offset = audioOffset * sensitivity * jiggleAmount * range;
            
            // Apply offset to base value
            let newValue = baseValue + offset;
            
            // Clamp to parameter-specific limits (same as jiggle system)
            switch(paramName) {
                case 'spikiness':
                case 'spikeSharpness':
                case 'fillSize':
                case 'fillOpacity':
                case 'blendOpacity':
                case 'noiseAmount':
                case 'blurAmount':
                    newValue = Math.max(0, Math.min(1, newValue));
                    break;
                case 'spikeFrequency':
                    newValue = Math.max(2, Math.min(20, newValue));
                    break;
                case 'hue':
                    newValue = ((newValue % 360) + 360) % 360; // Wrap around
                    break;
                case 'scale':
                    newValue = Math.max(0.05, Math.min(1.0, newValue));
                    break;
                case 'dilationSpeed':
                    newValue = Math.max(0.88, Math.min(1.22, newValue));
                    break;
                case 'fadeAmount':
                    newValue = Math.max(0, Math.min(5.0, newValue));
                    break;
                case 'emanationRate':
                    newValue = Math.max(2, Math.min(200, newValue));
                    break;
                case 'autoRotationSpeed':
                    newValue = Math.max(-1, Math.min(360, newValue));
                    break;
                case 'hueShiftAmount':
                    newValue = Math.max(0, Math.min(0.2, newValue));
                    break;
                case 'noiseRate':
                case 'blurRate':
                    newValue = Math.max(0, Math.min(10, newValue));
                    break;
            }
            
            return newValue;
        }
        
        // Audio device loading and controls
        async function loadAudioDevices() {
            const select = document.getElementById('audio-device-select');
            if (!select) return;
            
            try {
                const devices = await audioAnalyzer.getAudioDevices();
                select.innerHTML = '<option value="">Default (System Default)</option>';
                
                devices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label;
                    select.appendChild(option);
                });
                
                console.log(`Loaded ${devices.length} audio input devices`);
            } catch (err) {
                console.error('Failed to load audio devices:', err);
                select.innerHTML = '<option value="">Error loading devices</option>';
            }
        }
        
        function setupAudioVisualization() {
            const container = document.getElementById('audio-meters-container');
            if (!container || !audioMeters || !audioLegend) return;
            
            // Create meters for each metric
            const metricNames = ['coherence', 'mud', 'harshness', 'compression', 'collision', 'phaseRisk', 'audioAmp', 'bandLow', 'bandMid', 'bandHigh'];
            
            metricNames.forEach(name => {
                const meter = audioMeters.createMeter(name);
                
                // Add legend swatch to the label
                const label = meter.querySelector('.meter-label');
                if (label) {
                    let swatchId;
                    if (name === 'bandLow' || name === 'bandMid' || name === 'bandHigh') {
                        swatchId = 'legend-bandEnergy';
                    } else if (name === 'audioAmp') {
                        swatchId = 'legend-bandEnergy';
                    } else {
                        swatchId = `legend-${name}`;
                    }
                    
                    const swatch = audioLegend.createLegendCanvas(swatchId);
                    label.insertBefore(swatch, label.firstChild);
                }
                
                container.appendChild(meter);
            });
            
            // Set up legend canvases
            const metricMap = {
                'legend-coherence': 'coherence',
                'legend-mud': 'mud',
                'legend-harshness': 'harshness',
                'legend-compression': 'compression',
                'legend-collision': 'collision',
                'legend-phaseRisk': 'phaseRisk',
                'legend-bandEnergy': 'bandEnergy'
            };
            
            Object.keys(metricMap).forEach(elementId => {
                const canvas = document.getElementById(elementId);
                if (canvas) {
                    canvas.width = 20;
                    canvas.height = 20;
                    canvas.style.width = '20px';
                    canvas.style.height = '20px';
                    canvas.style.border = '1px solid rgba(255,255,255,0.4)';
                    canvas.style.borderRadius = '2px';
                    canvas.style.imageRendering = 'pixelated';
                    
                    const metricName = metricMap[elementId];
                    if (metricName === 'bandEnergy') {
                        audioLegend.ctx[elementId] = canvas.getContext('2d');
                    } else {
                        audioLegend.ctx[metricName] = canvas.getContext('2d');
                    }
                }
            });
        }
        
        function setupAudioControls() {
            const btn = document.getElementById('enable-audio-btn');
            const status = document.getElementById('audio-status');
            const deviceSelect = document.getElementById('audio-device-select');
            const audioReactiveCheckbox = document.getElementById('audio-reactive-enabled');
            
            if (!btn || !status) return;
            
            loadAudioDevices();
            
            if (deviceSelect) {
                deviceSelect.addEventListener('change', () => {
                    if (audioEnabled) {
                        btn.click();
                        btn.click();
                    }
                });
            }
            
            if (audioReactiveCheckbox) {
                audioReactiveCheckbox.addEventListener('change', (e) => {
                    audioReactiveEnabled = e.target.checked;
                    updateStatusIndicators();
                });
            }
            
            btn.addEventListener('click', async () => {
                if (audioEnabled) {
                    audioAnalyzer.disableAudio();
                    audioEnabled = false;
                    btn.textContent = 'Enable Audio';
                    status.textContent = 'Audio: Disabled';
                    status.style.color = '#888';
                    if (deviceSelect) deviceSelect.disabled = false;
                    updateStatusIndicators();
                } else {
                    try {
                        const selectedDeviceId = deviceSelect?.value || null;
                        await audioAnalyzer.enableAudio(selectedDeviceId, true);
                        audioEnabled = true;
                        const mode = audioAnalyzer.isStereo ? 'STEREO' : 'MONO';
                        btn.textContent = 'Disable Audio';
                        status.textContent = `Audio: ${mode}`;
                        status.style.color = audioAnalyzer.isStereo ? '#0f0' : '#ff0';
                        if (deviceSelect) deviceSelect.disabled = true;
                        updateStatusIndicators();
                    } catch (err) {
                        console.error('Failed to enable audio:', err);
                        alert('Failed to enable audio: ' + err.message);
                    }
                }
            });
        }
        
        // Generate audio mapping controls UI (compact, matching visual parameters style)
        function generateAudioMappingControls() {
            const container = document.getElementById('audio-mappings-content');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.keys(audioMapping).forEach(paramName => {
                const mapping = audioMapping[paramName];
                const group = document.createElement('div');
                group.className = 'control-group';
                
                // Label with checkbox and source info
                const label = document.createElement('label');
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '6px';
                label.style.marginBottom = '4px';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `mapping-enabled-${paramName}`;
                checkbox.checked = mapping.enabled;
                checkbox.style.margin = '0';
                checkbox.style.cursor = 'pointer';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = paramName;
                nameSpan.style.fontWeight = '600';
                nameSpan.style.color = '#0af';
                
                const sourceSpan = document.createElement('span');
                sourceSpan.textContent = `(${mapping.source})`;
                sourceSpan.style.fontSize = '8px';
                sourceSpan.style.color = '#888';
                sourceSpan.style.fontStyle = 'italic';
                
                const valueSpan = document.createElement('span');
                valueSpan.id = `mapping-value-${paramName}`;
                valueSpan.textContent = '0.00';
                valueSpan.style.fontSize = '8px';
                valueSpan.style.fontFamily = 'monospace';
                valueSpan.style.color = '#0f0';
                valueSpan.style.marginLeft = 'auto';
                
                checkbox.addEventListener('change', (e) => {
                    mapping.enabled = e.target.checked;
                });
                
                label.appendChild(checkbox);
                label.appendChild(nameSpan);
                label.appendChild(sourceSpan);
                label.appendChild(valueSpan);
                
                // Sensitivity control row
                const sensitivityRow = document.createElement('div');
                sensitivityRow.className = 'control-row';
                sensitivityRow.style.marginBottom = '4px';
                
                const sensitivityLabel = document.createElement('label');
                sensitivityLabel.textContent = 'Sensitivity';
                sensitivityLabel.style.minWidth = '70px';
                sensitivityLabel.style.fontSize = '9px';
                
                const sensitivitySlider = document.createElement('input');
                sensitivitySlider.type = 'range';
                sensitivitySlider.id = `mapping-sensitivity-${paramName}`;
                sensitivitySlider.min = '0';
                sensitivitySlider.max = '3';
                sensitivitySlider.step = '0.1';
                sensitivitySlider.value = (mapping.sensitivity !== undefined ? mapping.sensitivity : 1.0).toString();
                
                const sensitivityValue = document.createElement('div');
                sensitivityValue.className = 'value';
                sensitivityValue.id = `mapping-sensitivity-value-${paramName}`;
                sensitivityValue.textContent = (mapping.sensitivity !== undefined ? mapping.sensitivity : 1.0).toFixed(1);
                sensitivityValue.contentEditable = 'true';
                
                sensitivitySlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    mapping.sensitivity = val;
                    sensitivityValue.textContent = val.toFixed(1);
                });
                
                sensitivityValue.addEventListener('blur', () => {
                    const val = parseFloat(sensitivityValue.textContent);
                    if (!isNaN(val)) {
                        const clamped = Math.max(0, Math.min(3, val));
                        mapping.sensitivity = clamped;
                        sensitivitySlider.value = clamped.toString();
                        sensitivityValue.textContent = clamped.toFixed(1);
                    }
                });
                
                sensitivityRow.appendChild(sensitivityLabel);
                sensitivityRow.appendChild(sensitivitySlider);
                sensitivityRow.appendChild(sensitivityValue);
                
                // Smoothing control row
                const smoothingRow = document.createElement('div');
                smoothingRow.className = 'control-row';
                
                const smoothingLabel = document.createElement('label');
                smoothingLabel.textContent = 'Smoothing';
                smoothingLabel.style.minWidth = '70px';
                smoothingLabel.style.fontSize = '9px';
                
                const smoothingSlider = document.createElement('input');
                smoothingSlider.type = 'range';
                smoothingSlider.id = `mapping-smoothing-${paramName}`;
                smoothingSlider.min = '0.5';
                smoothingSlider.max = '0.99';
                smoothingSlider.step = '0.01';
                smoothingSlider.value = mapping.smoothing.toString();
                
                const smoothingValue = document.createElement('div');
                smoothingValue.className = 'value';
                smoothingValue.id = `mapping-smoothing-value-${paramName}`;
                smoothingValue.textContent = mapping.smoothing.toFixed(2);
                smoothingValue.contentEditable = 'true';
                
                smoothingSlider.addEventListener('input', (e) => {
                    const val = parseFloat(e.target.value);
                    mapping.smoothing = val;
                    smoothingValue.textContent = val.toFixed(2);
                });
                
                smoothingValue.addEventListener('blur', () => {
                    const val = parseFloat(smoothingValue.textContent);
                    if (!isNaN(val)) {
                        const clamped = Math.max(0.5, Math.min(0.99, val));
                        mapping.smoothing = clamped;
                        smoothingSlider.value = clamped.toString();
                        smoothingValue.textContent = clamped.toFixed(2);
                    }
                });
                
                smoothingRow.appendChild(smoothingLabel);
                smoothingRow.appendChild(smoothingSlider);
                smoothingRow.appendChild(smoothingValue);
                
                group.appendChild(label);
                group.appendChild(sensitivityRow);
                group.appendChild(smoothingRow);
                container.appendChild(group);
            });
        }
        
        // Update mapping value displays
        function updateMappingValueDisplays() {
            Object.keys(audioMapping).forEach(paramName => {
                const valueSpan = document.getElementById(`mapping-value-${paramName}`);
                if (valueSpan) {
                    const offset = audioDrivenOffsets[paramName] || 0.0;
                    valueSpan.textContent = offset.toFixed(3);
                    // Color code: green for positive, red for negative
                    valueSpan.style.color = offset > 0 ? '#0f0' : offset < 0 ? '#f00' : '#888';
                }
            });
        }
        
        // Audio event configuration and handlers
        const audioEventConfig = {
            songChange: { enabled: false, actions: [] },
            chorus: { enabled: false, actions: [] },
            verse: { enabled: false, actions: [] },
            drop: { enabled: false, actions: [] },
            tonalShift: { enabled: false, actions: [] }
        };
        
        // Available event actions
        const eventActions = [
            { id: 'flipDilation', name: 'Flip Dilation Polarity' },
            { id: 'toggleJiggle', name: 'Toggle Jiggle' },
            { id: 'randomize', name: 'Randomize Parameters' },
            { id: 'nextPreset', name: 'Next Preset' },
            { id: 'prevPreset', name: 'Previous Preset' }
        ];
        
        // Setup audio event system
        function setupAudioEvents() {
            const container = document.getElementById('audio-events-config');
            if (!container) return;
            
            // Create UI for each event type
            Object.keys(audioEventConfig).forEach(eventType => {
                const eventGroup = document.createElement('div');
                eventGroup.style.marginBottom = '8px';
                eventGroup.style.padding = '6px';
                eventGroup.style.background = 'rgba(255, 255, 255, 0.02)';
                eventGroup.style.border = '1px solid rgba(255, 255, 255, 0.05)';
                eventGroup.style.borderRadius = '3px';
                
                const header = document.createElement('div');
                header.style.display = 'flex';
                header.style.alignItems = 'center';
                header.style.gap = '6px';
                header.style.marginBottom = '4px';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `event-enabled-${eventType}`;
                checkbox.checked = audioEventConfig[eventType].enabled;
                checkbox.style.margin = '0';
                checkbox.style.cursor = 'pointer';
                
                const label = document.createElement('label');
                label.textContent = eventType.charAt(0).toUpperCase() + eventType.slice(1).replace(/([A-Z])/g, ' $1');
                label.style.fontSize = '9px';
                label.style.fontWeight = '600';
                label.style.color = '#0af';
                label.style.cursor = 'pointer';
                label.setAttribute('for', `event-enabled-${eventType}`);
                
                checkbox.addEventListener('change', (e) => {
                    audioEventConfig[eventType].enabled = e.target.checked;
                    if (e.target.checked) {
                        registerEventHandlers(eventType);
                    } else {
                        unregisterEventHandlers(eventType);
                    }
                });
                
                header.appendChild(checkbox);
                header.appendChild(label);
                
                const actionsContainer = document.createElement('div');
                actionsContainer.id = `event-actions-${eventType}`;
                actionsContainer.style.display = 'flex';
                actionsContainer.style.flexWrap = 'wrap';
                actionsContainer.style.gap = '4px';
                actionsContainer.style.marginTop = '4px';
                
                eventActions.forEach(action => {
                    const actionBtn = document.createElement('button');
                    actionBtn.textContent = action.name;
                    actionBtn.style.fontSize = '8px';
                    actionBtn.style.padding = '2px 6px';
                    actionBtn.style.background = '#333';
                    actionBtn.style.border = '1px solid #555';
                    actionBtn.style.borderRadius = '2px';
                    actionBtn.style.color = '#bbb';
                    actionBtn.style.cursor = 'pointer';
                    
                    const isActive = audioEventConfig[eventType].actions.includes(action.id);
                    if (isActive) {
                        actionBtn.style.background = '#0af';
                        actionBtn.style.color = '#fff';
                    }
                    
                    actionBtn.addEventListener('click', () => {
                        const index = audioEventConfig[eventType].actions.indexOf(action.id);
                        if (index > -1) {
                            audioEventConfig[eventType].actions.splice(index, 1);
                            actionBtn.style.background = '#333';
                            actionBtn.style.color = '#bbb';
                        } else {
                            audioEventConfig[eventType].actions.push(action.id);
                            actionBtn.style.background = '#0af';
                            actionBtn.style.color = '#fff';
                        }
                    });
                    
                    actionsContainer.appendChild(actionBtn);
                });
                
                eventGroup.appendChild(header);
                eventGroup.appendChild(actionsContainer);
                container.appendChild(eventGroup);
            });
            
            // Register handlers for initially enabled events
            Object.keys(audioEventConfig).forEach(eventType => {
                if (audioEventConfig[eventType].enabled) {
                    registerEventHandlers(eventType);
                }
            });
        }
        
        // Register event handlers
        function registerEventHandlers(eventType) {
            audioAnalyzer.onEvent(eventType, (data) => {
                if (!audioEventConfig[eventType].enabled) return;
                
                audioEventConfig[eventType].actions.forEach(actionId => {
                    executeEventAction(actionId, eventType, data);
                });
            });
        }
        
        // Unregister event handlers
        function unregisterEventHandlers(eventType) {
            // Note: AudioAnalyzer doesn't have offEvent implemented yet, but this is the structure
            // For now, we'll just check enabled state in the callback
        }
        
        // Execute event action
        // Note: This function will be called after main script variables are defined
        // We use a closure to access variables from the main script scope
        function executeEventAction(actionId, eventType, eventData) {
            const dilationFlipCheckbox = document.getElementById('dilation-polarity-flip');
            const jiggleButton = document.getElementById('jiggle-btn');
            const randomizeButton = document.getElementById('randomize-btn');
            
            switch(actionId) {
                case 'flipDilation':
                    if (dilationFlipCheckbox) {
                        dilationFlipCheckbox.checked = !dilationFlipCheckbox.checked;
                        console.log(`Event ${eventType}: Flipped dilation polarity`);
                    }
                    break;
                    
                case 'toggleJiggle':
                    if (jiggleButton) {
                        jiggleButton.click();
                        console.log(`Event ${eventType}: Toggled jiggle`);
                    }
                    break;
                    
                case 'randomize':
                    if (randomizeButton) {
                        randomizeButton.click();
                        console.log(`Event ${eventType}: Randomized parameters`);
                    }
                    break;
                    
                case 'nextPreset':
                    // Access variables from main scope via closure
                    // These are defined in the main IIFE and accessible here
                    try {
                        if (typeof presetSelect !== 'undefined' && presetSelect && 
                            typeof presetNames !== 'undefined' && presetNames.length > 0) {
                            const currentValue = presetSelect.value;
                            const currentIndex = presetNames.indexOf(currentValue);
                            if (currentIndex >= 0) {
                                const nextIndex = (currentIndex + 1) % presetNames.length;
                                presetSelect.value = presetNames[nextIndex];
                                if (typeof loadPreset === 'function') {
                                    loadPreset(presetNames[nextIndex]);
                                }
                                console.log(`Event ${eventType}: Loaded next preset: ${presetNames[nextIndex]}`);
                            }
                        }
                    } catch (err) {
                        console.error('Error executing nextPreset action:', err);
                    }
                    break;
                    
                case 'prevPreset':
                    // Access variables from main scope via closure
                    try {
                        if (typeof presetSelect !== 'undefined' && presetSelect && 
                            typeof presetNames !== 'undefined' && presetNames.length > 0) {
                            const currentValue = presetSelect.value;
                            const currentIndex = presetNames.indexOf(currentValue);
                            if (currentIndex >= 0) {
                                const prevIndex = (currentIndex - 1 + presetNames.length) % presetNames.length;
                                presetSelect.value = presetNames[prevIndex];
                                if (typeof loadPreset === 'function') {
                                    loadPreset(presetNames[prevIndex]);
                                }
                                console.log(`Event ${eventType}: Loaded previous preset: ${presetNames[prevIndex]}`);
                            }
                        }
                    } catch (err) {
                        console.error('Error executing prevPreset action:', err);
                    }
                    break;
            }
        }
        
        // Simple WebGL renderer
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.program = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                const res = RESOLUTIONS[currentResolution];
                if (res.width && res.height) {
                    // Fixed resolution
                    this.canvas.width = res.width;
                    this.canvas.height = res.height;
                } else {
                    // Window size
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Resize textures if they exist
                if (this.historyTexture && this.currentTexture) {
                    this.setupFramebuffers();
                }
            }
            
            setupFramebuffers() {
                const gl = this.gl;
                
                // Create or recreate history texture
                if (this.historyTexture) {
                    gl.deleteTexture(this.historyTexture);
                }
                if (this.historyFramebuffer) {
                    gl.deleteFramebuffer(this.historyFramebuffer);
                }
                
                this.historyTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.historyFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.historyTexture, 0);
                
                // Create or recreate current texture
                if (this.currentTexture) {
                    gl.deleteTexture(this.currentTexture);
                }
                if (this.currentFramebuffer) {
                    gl.deleteFramebuffer(this.currentFramebuffer);
                }
                
                this.currentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.currentFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.currentTexture, 0);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const info = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${info}`);
                }
                
                return shader;
            }
            
            init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource) {
                const gl = this.gl;
                
                // Compile shape shader
                const vertexShader = this.compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.program);
                    throw new Error(`Program linking error: ${info}`);
                }
                
                // Compile dilation shader
                const dilationVertexShader = this.compileShader(dilationVertexSource, gl.VERTEX_SHADER);
                const dilationFragmentShader = this.compileShader(dilationFragmentSource, gl.FRAGMENT_SHADER);
                this.dilationProgram = gl.createProgram();
                gl.attachShader(this.dilationProgram, dilationVertexShader);
                gl.attachShader(this.dilationProgram, dilationFragmentShader);
                gl.linkProgram(this.dilationProgram);
                
                if (!gl.getProgramParameter(this.dilationProgram, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.dilationProgram);
                    throw new Error(`Dilation program linking error: ${info}`);
                }
                
                // Setup full-screen quad (shared buffer)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1
                ]);
                
                this.quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Setup position attribute for shape program
                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup position attribute for dilation program
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup framebuffers
                this.setupFramebuffers();
                
                // Clear history texture to black
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                gl.useProgram(this.program);
            }
            
            setUniform(name, value, program = null) {
                const gl = this.gl;
                const targetProgram = program || this.program;
                const location = gl.getUniformLocation(targetProgram, name);
                
                if (location === null) return;
                
                if (typeof value === 'number') {
                    gl.uniform1f(location, value);
                } else if (Array.isArray(value)) {
                    if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    } else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                }
            }
            
            setBlendMode(mode, opacity) {
                const gl = this.gl;
                
                switch(mode) {
                    case 'additive':
                        // Additive: src + dst (bright, accumulates)
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'alpha':
                        // Alpha blend: src * alpha + dst * (1 - alpha)
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'multiply':
                        // Multiply: src * dst (darker)
                        gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'screen':
                        // Screen: 1 - (1 - src) * (1 - dst) (lighter)
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'overlay':
                        // Overlay: if dst < 0.5: 2 * multiply, else: 2 * screen - 1
                        // True overlay requires reading destination buffer (not possible with simple blend funcs)
                        // Approximation: use a combination that's closer to overlay behavior
                        // Using DST_COLOR with ONE gives multiply-like effect for darker areas
                        gl.blendFunc(gl.DST_COLOR, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    default:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                }
                
                // Apply opacity by modifying blend color (requires shader modification)
                // For now, opacity affects the shape shader output
            }
            
            render(uniforms, dilationFactor, shouldCaptureShape, fadeAmount, hueShiftAmount, emanationRate, noiseAmount, noiseRate, blurAmount, blurRate, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation) {
                const gl = this.gl;
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                const shapePositionLocation = gl.getAttribLocation(this.program, 'a_position');
                
                // Calculate center pixel coordinates for clearing
                const centerX = Math.floor(this.canvas.width / 2);
                const centerY = Math.floor(this.canvas.height / 2);
                
                // Step 1: Dilation pass - expand history texture
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                
                // Setup vertex attributes
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Set dilation uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                const dilationHistoryLocation = gl.getUniformLocation(this.dilationProgram, 'u_history');
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', dilationFactor, this.dilationProgram);
                this.setUniform('u_fadeAmount', fadeAmount, this.dilationProgram);
                this.setUniform('u_hueShiftAmount', hueShiftAmount, this.dilationProgram);
                this.setUniform('u_noiseAmount', noiseAmount, this.dilationProgram);
                this.setUniform('u_noiseRate', noiseRate, this.dilationProgram);
                this.setUniform('u_blurAmount', blurAmount, this.dilationProgram);
                this.setUniform('u_blurRate', blurRate, this.dilationProgram);
                this.setUniform('u_time', uniforms.u_time || 0.0, this.dilationProgram);
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Clear center 4 pixels to prevent white accumulation
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(centerX - 1, centerY - 1, 2, 2);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.disable(gl.SCISSOR_TEST);
                
                // Step 2: Draw current shape (only add to history if shouldCaptureShape is true)
                // This controls the emanation rate - how frequently new shapes are captured
                if (shouldCaptureShape) {
                    gl.useProgram(this.program);
                    gl.enableVertexAttribArray(shapePositionLocation);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Enable blending with configurable mode
                    gl.enable(gl.BLEND);
                    this.setBlendMode(blendMode, blendOpacity);
                    
                    Object.keys(uniforms).forEach(name => {
                        this.setUniform(name, uniforms[name]);
                    });
                    this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                    this.setUniform('u_rotation', totalRotation); // Capture total rotation at this moment
                    this.setUniform('u_autoRotationSpeed', 0.0); // Disable auto-rotation for captured shapes (they're frozen)
                    this.setUniform('u_blendOpacity', blendOpacity);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND);
                }
                
                // Step 3: Display current texture to screen
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for display
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 4: Draw current star on top of everything (always visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable blending with configurable mode
                gl.enable(gl.BLEND);
                this.setBlendMode(blendMode, blendOpacity);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                this.setUniform('u_rotation', rotation);
                this.setUniform('u_autoRotationSpeed', autoRotationSpeed);
                this.setUniform('u_blendOpacity', blendOpacity);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 5: Copy current texture to history for next frame (always, for smooth dilation)
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for copy
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        
        // Get shader from script tag
        function getShader(id) {
            const script = document.getElementById(id);
            if (!script) {
                throw new Error(`Shader script not found: ${id}`);
            }
            return script.textContent;
        }
        
        // Initialize
        function init() {
            const canvas = document.getElementById('canvas');
            const renderer = new SimpleRenderer(canvas);
            
            // Get shaders from script tags
            const vertexSource = getShader('star-vertex-shader');
            const fragmentSource = getShader('star-fragment-shader');
            const dilationVertexSource = getShader('dilation-vertex-shader');
            const dilationFragmentSource = getShader('dilation-fragment-shader');
            
            renderer.init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource);
            
            return { renderer, canvas };
        }
        
        const { renderer, canvas } = init();
        
        // Curve Editor System
        (() => {
            const curveEditorOverlay = document.getElementById('curve-editor-overlay');
            const curveEditorClose = document.getElementById('curve-editor-close');
            const curveCanvas = document.getElementById('curve-canvas');
            const curveCtx = curveCanvas.getContext('2d');
            const curveMinInput = document.getElementById('curve-min');
            const curveMaxInput = document.getElementById('curve-max');
            const curvePowerSlider = document.getElementById('curve-power');
            const curvePowerValue = document.getElementById('curve-power-value');
            const curveEditorTitle = document.getElementById('curve-editor-title');
            const curveResetBtn = document.getElementById('curve-reset');
            const curveApplyBtn = document.getElementById('curve-apply');
            const curveDoneBtn = document.getElementById('curve-close');
            
            let currentParam = null;
            let curveSettings = {}; // Store curve settings per parameter
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Default curve settings
            function getDefaultCurveSettings() {
                return {
                    min: 0,
                    max: 1,
                    power: 1.0, // Linear by default
                    type: 'power' // 'power' for exponential, could extend to 'bezier' later
                };
            }
            
            // Parameter-specific default settings
            function getParamDefaultSettings(paramName) {
                const defaults = {
                    // Shape parameters (0-1 range)
                    'spikiness': { min: 0, max: 1, power: 1.0 },
                    'spikeSharpness': { min: 0, max: 1, power: 1.0 },
                    'fillSize': { min: 0, max: 1, power: 1.0 },
                    'fillOpacity': { min: 0, max: 1, power: 1.0 },
                    'blendOpacity': { min: 0, max: 1, power: 1.0 },
                    'jiggleAmount': { min: 0, max: 1, power: 1.0 },
                    
                    // Frequency parameters
                    'spikeFrequency': { min: 2, max: 20, power: 1.0 },
                    
                    // Angle parameters
                    'hue': { min: 0, max: 360, power: 1.0 },
                    'rotation': { min: 0, max: 360, power: 1.0 },
                    
                    // Scale parameters
                    'scale': { min: 0.05, max: 1.0, power: 1.0 },
                    
                    // Rate parameters (with exponential curves)
                    'emanationRate': { min: 2, max: 200, power: 1.0 },
                    'noiseRate': { min: 0, max: 10, power: 0.333 }, // Exponential (1/3 power)
                    'blurRate': { min: 0, max: 10, power: 0.333 }, // Exponential (1/3 power)
                    'autoRotationSpeed': { min: -1, max: 360, power: 0.5 }, // Exponential (0.5 power, range -1 to 360)
                    
                    // Amount parameters (with exponential curves)
                    'noiseAmount': { min: 0, max: 1, power: 0.25 }, // Exponential (1/4 power)
                    'blurAmount': { min: 0, max: 1, power: 0.25 }, // Exponential (1/4 power)
                    'fadeAmount': { min: 0, max: 5, power: 0.333 }, // Exponential (1/3 power, range 0-5)
                    'hueShiftAmount': { min: 0, max: 0.2, power: 1.0 },
                    
                    // Dilation speed (complex mapping - approximate with range)
                    'dilationSpeed': { min: 0.88, max: 1.22, power: 0.125 }, // Very slow exponential (1/8 power)
                };
                return defaults[paramName] || null;
            }
            
            // Get or create curve settings for a parameter
            function getCurveSettings(paramName) {
                if (!curveSettings[paramName]) {
                    // Start with parameter-specific defaults if available
                    const paramDefaults = getParamDefaultSettings(paramName);
                    curveSettings[paramName] = { ...getDefaultCurveSettings(), ...(paramDefaults || {}) };
                    // Load from localStorage if available (overrides defaults)
                    const saved = localStorage.getItem(`curve_${paramName}`);
                    if (saved) {
                        try {
                            curveSettings[paramName] = { ...curveSettings[paramName], ...JSON.parse(saved) };
                        } catch (e) {
                            console.warn('Failed to load curve settings for', paramName);
                        }
                    }
                }
                return curveSettings[paramName];
            }
            
            // Save curve settings
            function saveCurveSettings(paramName) {
                if (curveSettings[paramName]) {
                    localStorage.setItem(`curve_${paramName}`, JSON.stringify(curveSettings[paramName]));
                }
            }
            
            // Map slider value (0-100) to output using curve
            function mapValue(sliderValue, settings) {
                if (!settings) settings = getDefaultCurveSettings();
                const normalized = sliderValue / 100.0;
                const curved = Math.pow(normalized, settings.power);
                return settings.min + curved * (settings.max - settings.min);
            }
            
            // Reverse map: output value to slider (0-100)
            function reverseMapValue(outputValue, settings) {
                if (!settings) settings = getDefaultCurveSettings();
                const normalized = (outputValue - settings.min) / (settings.max - settings.min);
                if (normalized <= 0) return 0;
                if (normalized >= 1) return 100;
                const curved = Math.pow(normalized, 1.0 / settings.power);
                return curved * 100;
            }
            
            // Draw curve on canvas
            function drawCurve() {
                const width = curveCanvas.width = curveCanvas.offsetWidth;
                const height = curveCanvas.height = curveCanvas.offsetHeight;
                const padding = 40;
                const w = width - padding * 2;
                const h = height - padding * 2;
                
                curveCtx.clearRect(0, 0, width, height);
                curveCtx.fillStyle = '#0a0a0a';
                curveCtx.fillRect(0, 0, width, height);
                
                const settings = currentParam ? getCurveSettings(currentParam) : getDefaultCurveSettings();
                
                // Draw grid
                curveCtx.strokeStyle = '#222';
                curveCtx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = padding + (w * i / 10);
                    const y = padding + (h * i / 10);
                    curveCtx.beginPath();
                    curveCtx.moveTo(x, padding);
                    curveCtx.lineTo(x, padding + h);
                    curveCtx.stroke();
                    curveCtx.beginPath();
                    curveCtx.moveTo(padding, y);
                    curveCtx.lineTo(padding + w, y);
                    curveCtx.stroke();
                }
                
                // Draw axes
                curveCtx.strokeStyle = '#555';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                curveCtx.moveTo(padding, padding);
                curveCtx.lineTo(padding, padding + h);
                curveCtx.lineTo(padding + w, padding + h);
                curveCtx.stroke();
                
                // Draw curve
                curveCtx.strokeStyle = '#0af';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const x = padding + (w * i / 100);
                    const normalized = i / 100.0;
                    const curved = Math.pow(normalized, settings.power);
                    const outputValue = settings.min + curved * (settings.max - settings.min);
                    const normalizedOutput = (outputValue - settings.min) / (settings.max - settings.min);
                    const y = padding + h - (normalizedOutput * h);
                    if (i === 0) {
                        curveCtx.moveTo(x, y);
                    } else {
                        curveCtx.lineTo(x, y);
                    }
                }
                curveCtx.stroke();
                
                // Draw current slider position if applicable
                if (currentParam) {
                    const slider = document.getElementById(`${currentParam}-slider`);
                    if (slider) {
                        const sliderValue = parseFloat(slider.value);
                        const x = padding + (w * sliderValue / 100);
                        const output = mapValue(sliderValue, settings);
                        const normalizedOutput = (output - settings.min) / (settings.max - settings.min);
                        const y = padding + h - (normalizedOutput * h);
                        
                        curveCtx.fillStyle = '#ff0';
                        curveCtx.beginPath();
                        curveCtx.arc(x, y, 5, 0, Math.PI * 2);
                        curveCtx.fill();
                    }
                }
                
                // Draw labels
                curveCtx.fillStyle = '#aaa';
                curveCtx.font = '10px monospace';
                curveCtx.textAlign = 'center';
                curveCtx.fillText('Input (0-100)', padding + w / 2, height - 10);
                curveCtx.save();
                curveCtx.translate(15, padding + h / 2);
                curveCtx.rotate(-Math.PI / 2);
                curveCtx.fillText('Output', 0, 0);
                curveCtx.restore();
                
                // Draw min/max labels
                curveCtx.fillStyle = '#888';
                curveCtx.font = '9px monospace';
                curveCtx.textAlign = 'right';
                curveCtx.fillText(settings.max.toFixed(2), padding - 10, padding + 5);
                curveCtx.fillText(settings.min.toFixed(2), padding - 10, padding + h + 5);
                curveCtx.textAlign = 'left';
                curveCtx.fillText('0', padding + 5, height - 10);
                curveCtx.fillText('100', padding + w - 25, height - 10);
            }
            
            // Open curve editor for a parameter
            function openCurveEditor(paramName) {
                currentParam = paramName;
                const settings = getCurveSettings(paramName);
                
                // Update UI
                const paramLabel = document.querySelector(`[data-param="${paramName}"]`)?.parentElement?.textContent || paramName;
                curveEditorTitle.textContent = `Curve Editor: ${paramLabel}`;
                curveMinInput.value = settings.min;
                curveMaxInput.value = settings.max;
                curvePowerSlider.value = settings.power;
                curvePowerValue.textContent = settings.power.toFixed(2);
                
                // Show editor
                curveEditorOverlay.classList.add('active');
                drawCurve();
                
                // Update canvas on resize
                window.addEventListener('resize', drawCurve);
            }
            
            // Close curve editor
            function closeCurveEditor() {
                curveEditorOverlay.classList.remove('active');
                currentParam = null;
                window.removeEventListener('resize', drawCurve);
            }
            
            // Apply curve settings
            function applyCurveSettings() {
                if (!currentParam) return;
                
                const settings = getCurveSettings(currentParam);
                settings.min = parseFloat(curveMinInput.value) || 0;
                settings.max = parseFloat(curveMaxInput.value) || 1;
                settings.power = parseFloat(curvePowerSlider.value) || 1.0;
                
                // Ensure min < max
                if (settings.min >= settings.max) {
                    settings.max = settings.min + 0.01;
                    curveMaxInput.value = settings.max;
                }
                
                saveCurveSettings(currentParam);
                drawCurve();
                
                // Trigger update of current slider value
                const slider = document.getElementById(`${currentParam}-slider`);
                if (slider && slider.oninput) {
                    slider.oninput({ target: slider });
                }
            }
            
            // Reset curve to default
            function resetCurve() {
                if (!currentParam) return;
                curveSettings[currentParam] = getDefaultCurveSettings();
                curveMinInput.value = curveSettings[currentParam].min;
                curveMaxInput.value = curveSettings[currentParam].max;
                curvePowerSlider.value = curveSettings[currentParam].power;
                curvePowerValue.textContent = curveSettings[currentParam].power.toFixed(2);
                drawCurve();
            }
            
            // Event listeners
            curveEditorClose.addEventListener('click', closeCurveEditor);
            curveDoneBtn.addEventListener('click', () => {
                applyCurveSettings();
                closeCurveEditor();
            });
            curveApplyBtn.addEventListener('click', applyCurveSettings);
            curveResetBtn.addEventListener('click', resetCurve);
            
            curveMinInput.addEventListener('input', () => {
                applyCurveSettings();
            });
            
            curveMaxInput.addEventListener('input', () => {
                applyCurveSettings();
            });
            
            curvePowerSlider.addEventListener('input', (e) => {
                curvePowerValue.textContent = parseFloat(e.target.value).toFixed(2);
                applyCurveSettings();
            });
            
            // Click outside to close
            curveEditorOverlay.addEventListener('click', (e) => {
                if (e.target === curveEditorOverlay) {
                    closeCurveEditor();
                }
            });
            
            // Make curve editor available globally
            window.CurveEditor = {
                open: openCurveEditor,
                mapValue: mapValue,
                reverseMapValue: reverseMapValue,
                getCurveSettings: getCurveSettings
            };
        })();
        
        (() => {
            // Get slider elements
            const spikinessSlider = document.getElementById('spikiness-slider');
            const spikeFrequencySlider = document.getElementById('spike-frequency-slider');
            const spikeSharpnessSlider = document.getElementById('spike-sharpness-slider');
            const hueSlider = document.getElementById('hue-slider');
            const scaleSlider = document.getElementById('scale-slider');
            const dilationSlider = document.getElementById('dilation-slider');
            const dilationValue = document.getElementById('dilation-value');
            const dilationPolarityFlip = document.getElementById('dilation-polarity-flip');
            const fadeSlider = document.getElementById('fade-slider');
            const hueShiftSlider = document.getElementById('hue-shift-slider');
            const rotationSlider = document.getElementById('rotation-slider');
            const spikinessValue = document.getElementById('spikiness-value');
            const spikeFrequencyValue = document.getElementById('spike-frequency-value');
            const spikeSharpnessValue = document.getElementById('spike-sharpness-value');
            const hueValue = document.getElementById('hue-value');
            const scaleValue = document.getElementById('scale-value');
            const fadeValue = document.getElementById('fade-value');
            const hueShiftValue = document.getElementById('hue-shift-value');
            const rotationValue = document.getElementById('rotation-value');
            const blendModeSelect = document.getElementById('blend-mode-select');
            const blendOpacitySlider = document.getElementById('blend-opacity-slider');
            const blendOpacityValue = document.getElementById('blend-opacity-value');
            const fillSizeSlider = document.getElementById('fill-size-slider');
            const fillSizeValue = document.getElementById('fill-size-value');
            const fillOpacitySlider = document.getElementById('fill-opacity-slider');
            const fillOpacityValue = document.getElementById('fill-opacity-value');
            const randomizeBtn = document.getElementById('randomize-btn');
            const jiggleBtn = document.getElementById('jiggle-btn');
            const jiggleAmountSlider = document.getElementById('jiggle-amount-slider');
            const jiggleAmountValue = document.getElementById('jiggle-amount-value');
            
            // Jiggle settings drawer
            const jiggleSettingsHeader = document.getElementById('jiggle-settings-header');
            const jiggleSettingsContent = document.getElementById('jiggle-settings-content');
            
            // Initialize jiggle enabled params (all enabled by default)
            const jiggleParamNames = [
                'spikiness', 'spikeFrequency', 'spikeSharpness',
                'hue', 'scale', 'fillSize', 'fillOpacity',
                'dilationSpeed', 'fadeAmount', 'emanationRate',
                'noiseAmount', 'noiseRate', 'blurAmount', 'blurRate',
                'autoRotationSpeed', 'hueShiftAmount', 'blendOpacity'
            ];
            
            // Initialize jiggleEnabledParams object - all enabled by default
            let jiggleEnabledParams = {};
            jiggleParamNames.forEach(param => {
                jiggleEnabledParams[param] = true;
            });
            
            // Toggle jiggle settings drawer - set up handler
            // Note: This header is excluded from the generic section-header handler below
            function setupJiggleDrawerHandler() {
                const header = document.getElementById('jiggle-settings-header');
                const content = document.getElementById('jiggle-settings-content');
                if (header && content) {
                    header.style.userSelect = 'none'; // Prevent text selection
                    header.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const isCollapsed = this.classList.contains('collapsed');
                        console.log('Jiggle drawer clicked, isCollapsed:', isCollapsed); // Debug log
                        if (isCollapsed) {
                            this.classList.remove('collapsed');
                            content.style.display = 'block';
                        } else {
                            this.classList.add('collapsed');
                            content.style.display = 'none';
                        }
                    });
                    console.log('Jiggle drawer handler attached successfully'); // Debug log
                    return true;
                } else {
                    console.warn('Jiggle drawer elements not found:', { header: !!header, content: !!content }); // Debug log
                }
                return false;
            }
            
            // Set up the handler
            if (!setupJiggleDrawerHandler()) {
                // Fallback: try again after a short delay in case DOM isn't ready
                setTimeout(() => {
                    console.log('Retrying jiggle drawer handler setup...'); // Debug log
                    setupJiggleDrawerHandler();
                }, 100);
            }
            
            // Initialize checkboxes and add event listeners
            jiggleParamNames.forEach(param => {
                const checkbox = document.getElementById(`jiggle-param-${param}`);
                if (checkbox) {
                    checkbox.checked = jiggleEnabledParams[param];
                    checkbox.addEventListener('change', (e) => {
                        jiggleEnabledParams[param] = e.target.checked;
                    });
                }
            });
            
            // Quick action buttons
            const jiggleAllBtn = document.getElementById('jiggle-all-btn');
            const jiggleNoneBtn = document.getElementById('jiggle-none-btn');
            const jiggleShapeBtn = document.getElementById('jiggle-shape-btn');
            const jiggleAppearanceBtn = document.getElementById('jiggle-appearance-btn');
            
            if (jiggleAllBtn) {
                jiggleAllBtn.addEventListener('click', () => {
                    jiggleParamNames.forEach(param => {
                        jiggleEnabledParams[param] = true;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = true;
                    });
                });
            }
            
            if (jiggleNoneBtn) {
                jiggleNoneBtn.addEventListener('click', () => {
                    jiggleParamNames.forEach(param => {
                        jiggleEnabledParams[param] = false;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = false;
                    });
                });
            }
            
            if (jiggleShapeBtn) {
                jiggleShapeBtn.addEventListener('click', () => {
                    const shapeParams = ['spikiness', 'spikeFrequency', 'spikeSharpness'];
                    jiggleParamNames.forEach(param => {
                        const enabled = shapeParams.includes(param);
                        jiggleEnabledParams[param] = enabled;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = enabled;
                    });
                });
            }
            
            if (jiggleAppearanceBtn) {
                jiggleAppearanceBtn.addEventListener('click', () => {
                    const appearanceParams = ['hue', 'scale', 'fillSize', 'fillOpacity'];
                    jiggleParamNames.forEach(param => {
                        const enabled = appearanceParams.includes(param);
                        jiggleEnabledParams[param] = enabled;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = enabled;
                    });
                });
            }
            
            // Get emanation rate slider before initializing values
            const emanationRateSlider = document.getElementById('emanation-rate-slider');
            const emanationRateValue = document.getElementById('emanation-rate-value');
            const autoRotationSlider = document.getElementById('auto-rotation-slider');
            const autoRotationValue = document.getElementById('auto-rotation-value');
            
            // Filter sliders
            const noiseAmountSlider = document.getElementById('noise-amount-slider');
            const noiseAmountValue = document.getElementById('noise-amount-value');
            const noiseRateSlider = document.getElementById('noise-rate-slider');
            const noiseRateValue = document.getElementById('noise-rate-value');
            const blurAmountSlider = document.getElementById('blur-amount-slider');
            const blurAmountValue = document.getElementById('blur-amount-value');
            const blurRateSlider = document.getElementById('blur-rate-slider');
            const blurRateValue = document.getElementById('blur-rate-value');
            
            // GIF capture state
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            let gifRecording = false;
            let gifCaptureFrames = [];
            let gifCaptureTimer = null;
            let gifCountdownTimer = null;
            let gifCaptureStart = 0;
            let gifCaptureWidth = 0;
            let gifCaptureHeight = 0;
            const GIF_FPS = 15;
            const GIF_MAX_MS = 10000; // 10s max
            
            // Get preset management elements before defining functions
            const presetSelect = document.getElementById('preset-select');
            const presetNameInput = document.getElementById('preset-name-input');
            const savePresetBtn = document.getElementById('save-preset-btn');
            const deletePresetBtn = document.getElementById('delete-preset-btn');
            const exportPresetsBtn = document.getElementById('export-presets-btn');
            const importPresetsInput = document.getElementById('import-presets-input');
            
            // Status indicators
            const freezeIndicator = document.getElementById('freeze-indicator');
            const jiggleIndicator = document.getElementById('jiggle-indicator');
            const unsavedIndicator = document.getElementById('unsaved-indicator');
            const statusIndicators = document.getElementById('status-indicators');
            const hotkeyLegend = document.getElementById('hotkey-legend');
            const recordIndicator = document.getElementById('record-indicator');
            
            // Position status indicators below hotkey legend
            function positionStatusIndicators() {
                if (hotkeyLegend && statusIndicators) {
                    const rect = hotkeyLegend.getBoundingClientRect();
                    statusIndicators.style.top = (rect.bottom + 6) + 'px';
                    statusIndicators.style.left = rect.left + 'px';
                }
            }
            
            // Position UX toolbox below status indicators
            const uxToolbox = document.getElementById('ux-toolbox');
            function positionUXToolbox() {
                if (statusIndicators && uxToolbox) {
                    const rect = statusIndicators.getBoundingClientRect();
                    uxToolbox.style.top = (rect.bottom + 6) + 'px';
                    uxToolbox.style.left = rect.left + 'px';
                }
            }
            
            // Position on load and resize
            positionStatusIndicators();
            positionUXToolbox();
            window.addEventListener('resize', () => {
                positionStatusIndicators();
                positionUXToolbox();
            });
            
            // ============================================
            // Smooth Interpolation System
            // ============================================
            
            class ParameterInterpolator {
                constructor() {
                    this.params = new Map(); // paramName -> {current, target, startTime, duration, startValue, easing}
                    this.springParams = new Map(); // paramName -> {current, target, velocity, spring, damping}
                    this.enabled = true;
                    this.defaultDuration = 0.5; // seconds
                    this.defaultEasing = 'easeInOut';
                    this.springConstant = 0.1;
                    this.springDamping = 0.8;
                    this.useSpringForRotation = true;
                }
                
                setEnabled(enabled) {
                    this.enabled = enabled;
                    if (!enabled) {
                        // Snap all params to targets
                        this.params.forEach((state, paramName) => {
                            state.current = state.target;
                        });
                        this.springParams.forEach((state, paramName) => {
                            state.current = state.target;
                            state.velocity = 0;
                        });
                    }
                }
                
                setTarget(paramName, targetValue, duration = null, easing = null, useSpring = false) {
                    if (!this.enabled) {
                        // If disabled, set current directly
                        if (useSpring || (this.useSpringForRotation && paramName === 'rotation')) {
                            const state = this.springParams.get(paramName) || { current: targetValue, velocity: 0, spring: this.springConstant, damping: this.springDamping };
                            state.target = targetValue;
                            state.spring = this.springConstant;
                            state.damping = this.springDamping;
                            this.springParams.set(paramName, state);
                        } else {
                            const state = this.params.get(paramName) || { current: targetValue };
                            state.current = targetValue;
                            state.target = targetValue;
                            this.params.set(paramName, state);
                        }
                        return;
                    }
                    
                    const currentValue = this.getCurrent(paramName);
                    const finalDuration = duration ?? this.defaultDuration;
                    const finalEasing = easing ?? this.defaultEasing;
                    
                    if (useSpring || (this.useSpringForRotation && paramName === 'rotation')) {
                        const state = this.springParams.get(paramName) || { current: currentValue, velocity: 0, spring: this.springConstant, damping: this.springDamping };
                        state.target = targetValue;
                        state.spring = this.springConstant;
                        state.damping = this.springDamping;
                        this.springParams.set(paramName, state);
                    } else {
                        this.params.set(paramName, {
                            current: currentValue,
                            target: targetValue,
                            startValue: currentValue,
                            startTime: Date.now(),
                            duration: finalDuration * 1000, // Convert to ms
                            easing: finalEasing
                        });
                    }
                }
                
                update() {
                    if (!this.enabled) return;
                    
                    const now = Date.now();
                    const deltaTime = 1/60; // Assume 60fps
                    
                    // Update standard interpolations
                    this.params.forEach((state, paramName) => {
                        const elapsed = now - state.startTime;
                        const progress = Math.min(elapsed / state.duration, 1);
                        
                        if (progress >= 1) {
                            state.current = state.target;
                        } else {
                            const t = this.applyEasing(progress, state.easing);
                            state.current = this.lerp(state.startValue, state.target, t);
                        }
                    });
                    
                    // Update spring-based interpolations
                    this.springParams.forEach((state, paramName) => {
                        const distance = state.target - state.current;
                        const force = distance * state.spring;
                        state.velocity = (state.velocity + force) * state.damping;
                        state.current += state.velocity * deltaTime;
                        
                        // Stop if very close and velocity is small
                        if (Math.abs(distance) < 0.001 && Math.abs(state.velocity) < 0.001) {
                            state.current = state.target;
                            state.velocity = 0;
                        }
                    });
                }
                
                getCurrent(paramName) {
                    if (this.springParams.has(paramName)) {
                        return this.springParams.get(paramName).current;
                    }
                    if (this.params.has(paramName)) {
                        return this.params.get(paramName).current;
                    }
                    // Return target if param doesn't exist yet (for initialization)
                    return null;
                }
                
                lerp(start, end, t) {
                    return start + (end - start) * t;
                }
                
                applyEasing(t, easing) {
                    switch(easing) {
                        case 'linear':
                            return t;
                        case 'easeIn':
                            return t * t;
                        case 'easeOut':
                            return 1 - (1 - t) * (1 - t);
                        case 'easeInOut':
                            return t < 0.5 
                                ? 2 * t * t 
                                : 1 - Math.pow(-2 * t + 2, 2) / 2;
                        default:
                            return t < 0.5 
                                ? 2 * t * t 
                                : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    }
                }
                
                // Handle rotation wrapping (359° -> 1° should go forward, not backward)
                setTargetRotation(paramName, targetValue) {
                    const current = this.getCurrent(paramName) ?? targetValue;
                    
                    // Normalize angles to 0-360
                    const currentNorm = ((current % 360) + 360) % 360;
                    const targetNorm = ((targetValue % 360) + 360) % 360;
                    
                    // Find shortest path
                    let diff = targetNorm - currentNorm;
                    if (Math.abs(diff) > 180) {
                        diff = diff > 0 ? diff - 360 : diff + 360;
                    }
                    
                    this.setTarget(paramName, currentNorm + diff, null, null, this.useSpringForRotation);
                }
            }
            
            // Create global interpolator instance
            const interpolator = new ParameterInterpolator();
            
            // Wire up interpolation settings UI
            const interpolationEnabled = document.getElementById('interpolation-enabled');
            const interpolationDurationSlider = document.getElementById('interpolation-duration-slider');
            const interpolationDurationValue = document.getElementById('interpolation-duration-value');
            const interpolationEasingSelect = document.getElementById('interpolation-easing-select');
            const interpolationSpringSlider = document.getElementById('interpolation-spring-slider');
            const interpolationSpringValue = document.getElementById('interpolation-spring-value');
            const interpolationDampingSlider = document.getElementById('interpolation-damping-slider');
            const interpolationDampingValue = document.getElementById('interpolation-damping-value');
            const interpolationRotationSpring = document.getElementById('interpolation-rotation-spring');
            const interpolationSettingsHeader = document.getElementById('interpolation-settings-header');
            const interpolationSettingsContent = document.getElementById('interpolation-settings-content');
            
            // Toggle interpolation settings drawer
            if (interpolationSettingsHeader && interpolationSettingsContent) {
                interpolationSettingsHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isCollapsed = this.classList.contains('collapsed');
                    if (isCollapsed) {
                        this.classList.remove('collapsed');
                        interpolationSettingsContent.style.display = 'block';
                    } else {
                        this.classList.add('collapsed');
                        interpolationSettingsContent.style.display = 'none';
                    }
                });
            }
            
            // Debug values panel
            const debugValuesHeader = document.getElementById('debug-values-header');
            const debugValuesContent = document.getElementById('debug-values-content');
            const debugOutput = document.getElementById('debug-output');
            
            if (debugValuesHeader && debugValuesContent) {
                debugValuesHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isCollapsed = this.classList.contains('collapsed');
                    if (isCollapsed) {
                        this.classList.remove('collapsed');
                        debugValuesContent.style.display = 'block';
                    } else {
                        this.classList.add('collapsed');
                        debugValuesContent.style.display = 'none';
                    }
                });
            }
            
            // Function to update debug output
            function updateDebugOutput() {
                if (!debugOutput || debugValuesContent.style.display === 'none') return;
                
                const getInterpolatedCurrent = (param) => interpolator.getCurrent(param) ?? 'N/A';
                const getInterpolatedTarget = (param) => {
                    const state = interpolator.params.get(param);
                    const springState = interpolator.springParams.get(param);
                    if (springState) return springState.target.toFixed(4);
                    if (state) return state.target.toFixed(4);
                    return 'N/A';
                };
                const getInterpolationProgress = (param) => {
                    const state = interpolator.params.get(param);
                    if (!state) return 'N/A';
                    const elapsed = Date.now() - state.startTime;
                    const progress = Math.min(elapsed / state.duration, 1);
                    return (progress * 100).toFixed(1) + '%';
                };
                const getSpringVelocity = (param) => {
                    const state = interpolator.springParams.get(param);
                    if (!state) return 'N/A';
                    return state.velocity.toFixed(4);
                };
                
                const output = [];
                output.push('=== INTERPOLATION STATE ===');
                output.push(`Enabled: ${interpolator.enabled}`);
                output.push(`Active: ${interpolator.enabled && !jiggleEnabled}`);
                output.push(`Jiggle Enabled: ${jiggleEnabled}`);
                output.push(`Jiggle Amount: ${(jiggleAmount * 100).toFixed(1)}%`);
                output.push('');
                
                output.push('=== ROTATION ===');
                output.push(`Rotation (direct): ${rotation.toFixed(2)}°`);
                output.push(`Rotation (interp current): ${getInterpolatedCurrent('rotation')}°`);
                output.push(`Rotation (interp target): ${getInterpolatedTarget('rotation')}°`);
                output.push(`Rotation (base): ${baseRotation.toFixed(2)}°`);
                output.push(`Rotation (target base): ${targetBaseRotation.toFixed(2)}°`);
                const rotSpring = interpolator.springParams.get('rotation');
                if (rotSpring) {
                    output.push(`Rotation (spring velocity): ${rotSpring.velocity.toFixed(4)}`);
                }
                output.push(`Auto Rotation Speed (direct): ${autoRotationSpeed.toFixed(2)}°/s`);
                output.push(`Auto Rotation Speed (interp current): ${getInterpolatedCurrent('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (interp target): ${getInterpolatedTarget('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (base): ${baseAutoRotationSpeed.toFixed(2)}°/s`);
                output.push('');
                
                output.push('=== DILATION ===');
                output.push(`Dilation Speed (direct): ${dilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (interp current): ${getInterpolatedCurrent('dilationSpeed')}`);
                output.push(`Dilation Speed (interp target): ${getInterpolatedTarget('dilationSpeed')}`);
                output.push(`Dilation Speed (base): ${baseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (target base): ${targetBaseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (progress): ${getInterpolationProgress('dilationSpeed')}`);
                output.push(`Effective (freeze): ${freezeEnabled ? '1.0 (frozen)' : dilationSpeed.toFixed(4)}`);
                output.push('');
                
                output.push('=== SHAPE ===');
                output.push(`Spikiness: ${spikiness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikiness')} | target: ${getInterpolatedTarget('spikiness')} | base: ${baseSpikiness.toFixed(3)}`);
                output.push(`Spike Freq: ${spikeFrequency.toFixed(2)} | interp: ${getInterpolatedCurrent('spikeFrequency')} | target: ${getInterpolatedTarget('spikeFrequency')} | base: ${baseSpikeFrequency.toFixed(2)}`);
                output.push(`Spike Sharp: ${spikeSharpness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikeSharpness')} | target: ${getInterpolatedTarget('spikeSharpness')} | base: ${baseSpikeSharpness.toFixed(3)}`);
                output.push('');
                
                output.push('=== APPEARANCE ===');
                output.push(`Hue: ${hue.toFixed(1)}° | interp: ${getInterpolatedCurrent('hue')}° | target: ${getInterpolatedTarget('hue')}° | base: ${baseHue.toFixed(1)}°`);
                output.push(`Scale: ${scale.toFixed(3)} | interp: ${getInterpolatedCurrent('scale')} | target: ${getInterpolatedTarget('scale')} | base: ${baseScale.toFixed(3)}`);
                output.push(`Fill Size: ${fillSize.toFixed(3)} | interp: ${getInterpolatedCurrent('fillSize')} | target: ${getInterpolatedTarget('fillSize')} | base: ${baseFillSize.toFixed(3)}`);
                output.push(`Fill Opacity: ${fillOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('fillOpacity')} | target: ${getInterpolatedTarget('fillOpacity')} | base: ${baseFillOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== EMANATION ===');
                output.push(`Emanation Rate: ${emanationRate.toFixed(2)} | interp: ${getInterpolatedCurrent('emanationRate')} | target: ${getInterpolatedTarget('emanationRate')} | base: ${baseEmanationRate.toFixed(2)}`);
                output.push(`Fade Amount: ${fadeAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('fadeAmount')} | target: ${getInterpolatedTarget('fadeAmount')} | base: ${baseFadeAmount.toFixed(3)}`);
                output.push('');
                
                output.push('=== FILTERS ===');
                output.push(`Noise Amount: ${noiseAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('noiseAmount')} | target: ${getInterpolatedTarget('noiseAmount')} | base: ${baseNoiseAmount.toFixed(3)}`);
                output.push(`Noise Rate: ${noiseRate.toFixed(2)} | interp: ${getInterpolatedCurrent('noiseRate')} | target: ${getInterpolatedTarget('noiseRate')} | base: ${baseNoiseRate.toFixed(2)}`);
                output.push(`Blur Amount: ${blurAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('blurAmount')} | target: ${getInterpolatedTarget('blurAmount')} | base: ${baseBlurAmount.toFixed(3)}`);
                output.push(`Blur Rate: ${blurRate.toFixed(2)} | interp: ${getInterpolatedCurrent('blurRate')} | target: ${getInterpolatedTarget('blurRate')} | base: ${baseBlurRate.toFixed(2)}`);
                output.push('');
                
                output.push('=== EFFECTS ===');
                output.push(`Hue Shift: ${hueShiftAmount.toFixed(4)} | interp: ${getInterpolatedCurrent('hueShiftAmount')} | target: ${getInterpolatedTarget('hueShiftAmount')} | base: ${baseHueShiftAmount.toFixed(4)}`);
                output.push(`Blend Opacity: ${blendOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('blendOpacity')} | target: ${getInterpolatedTarget('blendOpacity')} | base: ${baseBlendOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== CALCULATED VALUES ===');
                const currentTime = (Date.now() - startTime) / 1000.0;
                const interpolatedRot = interpolator.getCurrent('rotation') ?? rotation;
                const interpolatedAutoRot = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                const totalRotation = interpolatedRot + (currentTime * interpolatedAutoRot);
                output.push(`Total Rotation: ${totalRotation.toFixed(2)}°`);
                output.push(`Time: ${currentTime.toFixed(2)}s`);
                
                debugOutput.textContent = output.join('\n');
            }
            
            // Interpolation enabled toggle
            if (interpolationEnabled) {
                interpolationEnabled.addEventListener('change', (e) => {
                    interpolator.setEnabled(e.target.checked);
                });
            }
            
            // Duration slider
            if (interpolationDurationSlider) {
                interpolationDurationSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    interpolator.defaultDuration = value;
                    interpolationDurationValue.textContent = value.toFixed(2);
                });
                handleValueEdit(interpolationDurationValue,
                    (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                    (val) => val.toFixed(2),
                    (val) => {
                        interpolator.defaultDuration = val;
                        interpolationDurationSlider.value = val;
                    }
                );
            }
            
            // Easing select
            if (interpolationEasingSelect) {
                interpolationEasingSelect.addEventListener('change', (e) => {
                    interpolator.defaultEasing = e.target.value;
                });
            }
            
            // Spring constant slider
            if (interpolationSpringSlider) {
                interpolationSpringSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    interpolator.springConstant = value;
                    interpolationSpringValue.textContent = value.toFixed(2);
                    // Update existing spring params
                    interpolator.springParams.forEach((state) => {
                        state.spring = value;
                    });
                });
                handleValueEdit(interpolationSpringValue,
                    (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                    (val) => val.toFixed(2),
                    (val) => {
                        interpolator.springConstant = val;
                        interpolationSpringSlider.value = val;
                    }
                );
            }
            
            // Damping slider
            if (interpolationDampingSlider) {
                interpolationDampingSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    interpolator.springDamping = value;
                    interpolationDampingValue.textContent = value.toFixed(2);
                    // Update existing spring params
                    interpolator.springParams.forEach((state) => {
                        state.damping = value;
                    });
                });
                handleValueEdit(interpolationDampingValue,
                    (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                    (val) => val.toFixed(2),
                    (val) => {
                        interpolator.springDamping = val;
                        interpolationDampingSlider.value = val;
                    }
                );
            }
            
            // Rotation spring toggle
            if (interpolationRotationSpring) {
                interpolationRotationSpring.addEventListener('change', (e) => {
                    interpolator.useSpringForRotation = e.target.checked;
                });
            }
            
            // Function to update debug output
            function updateDebugOutput() {
                if (!debugOutput || !debugValuesContent || debugValuesContent.style.display === 'none') return;
                
                const getInterpolatedCurrent = (param) => {
                    const val = interpolator.getCurrent(param);
                    return val !== null && val !== undefined ? val.toFixed(4) : 'N/A';
                };
                const getInterpolatedTarget = (param) => {
                    const state = interpolator.params.get(param);
                    const springState = interpolator.springParams.get(param);
                    if (springState) return springState.target.toFixed(4);
                    if (state) return state.target.toFixed(4);
                    return 'N/A';
                };
                const getInterpolationProgress = (param) => {
                    const state = interpolator.params.get(param);
                    if (!state) return 'N/A';
                    const elapsed = Date.now() - state.startTime;
                    const progress = Math.min(elapsed / state.duration, 1);
                    return (progress * 100).toFixed(1) + '%';
                };
                
                const output = [];
                output.push('=== INTERPOLATION STATE ===');
                output.push(`Enabled: ${interpolator.enabled}`);
                output.push(`Active: ${interpolator.enabled && !jiggleEnabled}`);
                output.push(`Jiggle Enabled: ${jiggleEnabled}`);
                output.push(`Jiggle Amount: ${(jiggleAmount * 100).toFixed(1)}%`);
                output.push('');
                
                output.push('=== ROTATION ===');
                output.push(`Rotation (direct): ${rotation.toFixed(2)}°`);
                output.push(`Rotation (interp current): ${getInterpolatedCurrent('rotation')}°`);
                output.push(`Rotation (interp target): ${getInterpolatedTarget('rotation')}°`);
                output.push(`Rotation (base): ${baseRotation.toFixed(2)}°`);
                output.push(`Rotation (target base): ${targetBaseRotation.toFixed(2)}°`);
                const rotSpring = interpolator.springParams.get('rotation');
                if (rotSpring) {
                    output.push(`Rotation (spring velocity): ${rotSpring.velocity.toFixed(4)}`);
                }
                output.push(`Auto Rotation Speed (direct): ${autoRotationSpeed.toFixed(2)}°/s`);
                output.push(`Auto Rotation Speed (interp current): ${getInterpolatedCurrent('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (interp target): ${getInterpolatedTarget('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (base): ${baseAutoRotationSpeed.toFixed(2)}°/s`);
                output.push('');
                
                output.push('=== DILATION ===');
                output.push(`Dilation Speed (direct): ${dilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (interp current): ${getInterpolatedCurrent('dilationSpeed')}`);
                output.push(`Dilation Speed (interp target): ${getInterpolatedTarget('dilationSpeed')}`);
                output.push(`Dilation Speed (base): ${baseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (target base): ${targetBaseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (progress): ${getInterpolationProgress('dilationSpeed')}`);
                output.push(`Effective (freeze): ${freezeEnabled ? '1.0 (frozen)' : dilationSpeed.toFixed(4)}`);
                output.push('');
                
                output.push('=== SHAPE ===');
                output.push(`Spikiness: ${spikiness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikiness')} | target: ${getInterpolatedTarget('spikiness')} | base: ${baseSpikiness.toFixed(3)}`);
                output.push(`Spike Freq: ${spikeFrequency.toFixed(2)} | interp: ${getInterpolatedCurrent('spikeFrequency')} | target: ${getInterpolatedTarget('spikeFrequency')} | base: ${baseSpikeFrequency.toFixed(2)}`);
                output.push(`Spike Sharp: ${spikeSharpness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikeSharpness')} | target: ${getInterpolatedTarget('spikeSharpness')} | base: ${baseSpikeSharpness.toFixed(3)}`);
                output.push('');
                
                output.push('=== APPEARANCE ===');
                output.push(`Hue: ${hue.toFixed(1)}° | interp: ${getInterpolatedCurrent('hue')}° | target: ${getInterpolatedTarget('hue')}° | base: ${baseHue.toFixed(1)}°`);
                output.push(`Scale: ${scale.toFixed(3)} | interp: ${getInterpolatedCurrent('scale')} | target: ${getInterpolatedTarget('scale')} | base: ${baseScale.toFixed(3)}`);
                output.push(`Fill Size: ${fillSize.toFixed(3)} | interp: ${getInterpolatedCurrent('fillSize')} | target: ${getInterpolatedTarget('fillSize')} | base: ${baseFillSize.toFixed(3)}`);
                output.push(`Fill Opacity: ${fillOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('fillOpacity')} | target: ${getInterpolatedTarget('fillOpacity')} | base: ${baseFillOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== EMANATION ===');
                output.push(`Emanation Rate: ${emanationRate.toFixed(2)} | interp: ${getInterpolatedCurrent('emanationRate')} | target: ${getInterpolatedTarget('emanationRate')} | base: ${baseEmanationRate.toFixed(2)}`);
                output.push(`Fade Amount: ${fadeAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('fadeAmount')} | target: ${getInterpolatedTarget('fadeAmount')} | base: ${baseFadeAmount.toFixed(3)}`);
                output.push('');
                
                output.push('=== FILTERS ===');
                output.push(`Noise Amount: ${noiseAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('noiseAmount')} | target: ${getInterpolatedTarget('noiseAmount')} | base: ${baseNoiseAmount.toFixed(3)}`);
                output.push(`Noise Rate: ${noiseRate.toFixed(2)} | interp: ${getInterpolatedCurrent('noiseRate')} | target: ${getInterpolatedTarget('noiseRate')} | base: ${baseNoiseRate.toFixed(2)}`);
                output.push(`Blur Amount: ${blurAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('blurAmount')} | target: ${getInterpolatedTarget('blurAmount')} | base: ${baseBlurAmount.toFixed(3)}`);
                output.push(`Blur Rate: ${blurRate.toFixed(2)} | interp: ${getInterpolatedCurrent('blurRate')} | target: ${getInterpolatedTarget('blurRate')} | base: ${baseBlurRate.toFixed(2)}`);
                output.push('');
                
                output.push('=== EFFECTS ===');
                output.push(`Hue Shift: ${hueShiftAmount.toFixed(4)} | interp: ${getInterpolatedCurrent('hueShiftAmount')} | target: ${getInterpolatedTarget('hueShiftAmount')} | base: ${baseHueShiftAmount.toFixed(4)}`);
                output.push(`Blend Opacity: ${blendOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('blendOpacity')} | target: ${getInterpolatedTarget('blendOpacity')} | base: ${baseBlendOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== CALCULATED VALUES ===');
                const currentTime = (Date.now() - startTime) / 1000.0;
                const interpolatedRot = interpolator.getCurrent('rotation') ?? rotation;
                const interpolatedAutoRot = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                const totalRotation = interpolatedRot + (currentTime * interpolatedAutoRot);
                output.push(`Total Rotation: ${totalRotation.toFixed(2)}°`);
                output.push(`Time: ${currentTime.toFixed(2)}s`);
                
                debugOutput.textContent = output.join('\n');
            }
            
            // Track last loaded preset for unsaved changes detection
            let lastLoadedPresetName = null;
            let lastLoadedPresetValues = null;
            
            // Function to update status indicators
            function updateStatusIndicators() {
                freezeIndicator.style.display = freezeEnabled ? 'inline-block' : 'none';
                jiggleIndicator.style.display = jiggleEnabled ? 'inline-block' : 'none';
                const audioIndicator = document.getElementById('audio-indicator');
                if (audioIndicator) {
                    audioIndicator.style.display = (audioEnabled && audioReactiveEnabled) ? 'inline-block' : 'none';
                }
                
                // Check if current values differ from last loaded preset
                if (lastLoadedPresetName && lastLoadedPresetValues) {
                    const currentValues = {
                        spikiness, spikeFrequency, spikeSharpness, hue, scale,
                        fillSize, fillOpacity, rotation, hueShiftAmount,
                        dilationSpeed, fadeAmount, emanationRate, autoRotationSpeed,
                        blendMode, blendOpacity
                    };
                    
                    // Compare values (with small tolerance for floating point)
                    let hasChanges = false;
                    for (const [key, currentValue] of Object.entries(currentValues)) {
                        const lastValue = lastLoadedPresetValues[key];
                        if (lastValue !== undefined && Math.abs(currentValue - lastValue) > 0.001) {
                            hasChanges = true;
                            break;
                        }
                    }
                    // Also check blendMode (string comparison)
                    if (currentValues.blendMode !== lastLoadedPresetValues.blendMode) {
                        hasChanges = true;
                    }
                    
                    unsavedIndicator.style.display = hasChanges ? 'inline-block' : 'none';
                } else {
                    unsavedIndicator.style.display = 'none';
                }
            }
            
            // Collapsible dev-tool sections
            const sectionHeaders = Array.from(document.querySelectorAll('#dev-toolbox .section-header'));
            sectionHeaders.forEach((header) => {
                // Skip jiggle-settings-header as it has its own custom handler
                if (header.id === 'jiggle-settings-header') {
                    return;
                }
                header.addEventListener('click', () => {
                    const collapsed = header.classList.toggle('collapsed');
                    let el = header.nextElementSibling;
                    while (el && !el.classList.contains('section-header')) {
                        if (collapsed) {
                            el.dataset._display = el.style.display || '';
                            el.style.display = 'none';
                        } else {
                            el.style.display = el.dataset._display || '';
                        }
                        el = el.nextElementSibling;
                    }
                });
            });
            
            // Preset management functions (need to be defined before we try to load presets)
            // Load presets from localStorage
            function loadPresets() {
                const presets = JSON.parse(localStorage.getItem('sandboxPresets') || '{}');
                presetSelect.innerHTML = '<option value="">-- Select Preset --</option>';
                Object.keys(presets).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    presetSelect.appendChild(option);
                });
                return presets;
            }
            
            // Load preset
            function loadPreset(name) {
                const presets = loadPresets();
                if (!presets[name]) {
                    alert('Preset not found');
                    return;
                }
                
                const preset = presets[name];
                
                // Set all values using interpolation for smooth transitions
                // Handle migration from old "spikes" parameter to new shape parameters
                if (preset.spikes !== undefined) {
                    // Old preset format: convert discrete spikes to continuous parameters
                    const oldSpikes = preset.spikes;
                    interpolator.setTarget('spikiness', 0.8); // Default spikiness for old presets
                    interpolator.setTarget('spikeFrequency', Math.max(2.0, Math.min(20.0, oldSpikes))); // Use old spike count as frequency
                    interpolator.setTarget('spikeSharpness', 0.0); // Default sharpness
                } else {
                    // New preset format
                    interpolator.setTarget('spikiness', preset.spikiness !== undefined ? preset.spikiness : 0.5);
                    interpolator.setTarget('spikeFrequency', preset.spikeFrequency !== undefined ? preset.spikeFrequency : 5.0);
                    interpolator.setTarget('spikeSharpness', preset.spikeSharpness !== undefined ? preset.spikeSharpness : 0.0);
                }
                interpolator.setTarget('hue', preset.hue);
                interpolator.setTarget('scale', preset.scale);
                interpolator.setTarget('hueShiftAmount', preset.hueShiftAmount);
                interpolator.setTargetRotation('rotation', preset.rotation); // Use rotation-specific setter for wrapping
                blendMode = preset.blendMode; // Blend mode doesn't need interpolation
                interpolator.setTarget('blendOpacity', preset.blendOpacity);
                interpolator.setTarget('fillSize', preset.fillSize !== undefined ? preset.fillSize : 0.0);
                interpolator.setTarget('fillOpacity', preset.fillOpacity !== undefined ? preset.fillOpacity : 0.6);
                interpolator.setTarget('emanationRate', preset.emanationRate !== undefined ? preset.emanationRate : 2.0);
                interpolator.setTarget('noiseAmount', preset.noiseAmount !== undefined ? preset.noiseAmount : 0.0);
                interpolator.setTarget('noiseRate', preset.noiseRate !== undefined ? preset.noiseRate : 0.0);
                interpolator.setTarget('blurAmount', preset.blurAmount !== undefined ? preset.blurAmount : 0.0);
                interpolator.setTarget('blurRate', preset.blurRate !== undefined ? preset.blurRate : 0.0);
                interpolator.setTarget('autoRotationSpeed', preset.autoRotationSpeed);
                
                // Also set direct values for slider updates (they'll sync via interpolator)
                spikiness = interpolator.getCurrent('spikiness') ?? (preset.spikiness !== undefined ? preset.spikiness : 0.5);
                spikeFrequency = interpolator.getCurrent('spikeFrequency') ?? (preset.spikeFrequency !== undefined ? preset.spikeFrequency : 5.0);
                spikeSharpness = interpolator.getCurrent('spikeSharpness') ?? (preset.spikeSharpness !== undefined ? preset.spikeSharpness : 0.0);
                hue = interpolator.getCurrent('hue') ?? preset.hue;
                scale = interpolator.getCurrent('scale') ?? preset.scale;
                hueShiftAmount = interpolator.getCurrent('hueShiftAmount') ?? preset.hueShiftAmount;
                rotation = interpolator.getCurrent('rotation') ?? preset.rotation;
                blendOpacity = interpolator.getCurrent('blendOpacity') ?? preset.blendOpacity;
                fillSize = interpolator.getCurrent('fillSize') ?? (preset.fillSize !== undefined ? preset.fillSize : 0.0);
                fillOpacity = interpolator.getCurrent('fillOpacity') ?? (preset.fillOpacity !== undefined ? preset.fillOpacity : 0.6);
                emanationRate = interpolator.getCurrent('emanationRate') ?? (preset.emanationRate !== undefined ? preset.emanationRate : 2.0);
                noiseAmount = interpolator.getCurrent('noiseAmount') ?? (preset.noiseAmount !== undefined ? preset.noiseAmount : 0.0);
                noiseRate = interpolator.getCurrent('noiseRate') ?? (preset.noiseRate !== undefined ? preset.noiseRate : 0.0);
                blurAmount = interpolator.getCurrent('blurAmount') ?? (preset.blurAmount !== undefined ? preset.blurAmount : 0.0);
                blurRate = interpolator.getCurrent('blurRate') ?? (preset.blurRate !== undefined ? preset.blurRate : 0.0);
                autoRotationSpeed = interpolator.getCurrent('autoRotationSpeed') ?? preset.autoRotationSpeed;
                
                // Handle dilation speed separately (needs slider conversion)
                dilationSpeed = preset.dilationSlider ? (() => {
                    const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                    const range = (1.22 - 0.88) / (1.0 - midPower);
                    const min = 1.0 - midPower * range;
                    return min + Math.pow(parseFloat(preset.dilationSlider) / 200.0, 1.0 / 8.0) * range;
                })() : (interpolator.getCurrent('dilationSpeed') ?? 1.01);
                interpolator.setTarget('dilationSpeed', dilationSpeed);
                
                // Handle fade amount separately (needs slider conversion)
                fadeAmount = preset.fadeSlider ? Math.pow(parseFloat(preset.fadeSlider) / 100.0, 1.0 / 3.0) * 5.0 : (interpolator.getCurrent('fadeAmount') ?? 0.3);
                interpolator.setTarget('fadeAmount', fadeAmount);
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = hue;
                hueValue.textContent = hue + '°';
                scaleSlider.value = scale;
                scaleValue.textContent = scale.toFixed(2);
                dilationSlider.value = preset.dilationSlider || 20;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(parseFloat(dilationSlider.value) / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = preset.fadeSlider || 30;
                fadeAmount = Math.pow(parseFloat(fadeSlider.value) / 100.0, 1.0 / 3.0) * 5.0;
                fadeValue.textContent = fadeAmount.toFixed(3);
                hueShiftSlider.value = hueShiftAmount;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                rotationSlider.value = rotation;
                rotationValue.textContent = rotation + '°';
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                emanationRateSlider.value = emanationRate;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                noiseRateSlider.value = noiseRateToSlider(noiseRate);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                blurAmountSlider.value = blurAmountToSlider(blurAmount);
                blurAmountValue.textContent = blurAmount.toFixed(2);
                blurRateSlider.value = blurRateToSlider(blurRate);
                blurRateValue.textContent = blurRate.toFixed(2);
                // Use stored slider value if available, otherwise reverse map from speed value
                if (preset.autoRotationSlider !== undefined) {
                    autoRotationSlider.value = preset.autoRotationSlider;
                    autoRotationSpeed = -1.0 + Math.pow(preset.autoRotationSlider / 200.0, 0.5) * 361.0;
                } else {
                    // Fallback: reverse map from speed value
                    const sliderValue = Math.round(200 * Math.pow((autoRotationSpeed + 1) / 361.0, 2));
                    autoRotationSlider.value = sliderValue;
                }
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Restore jiggle settings if present
                if (preset.jiggleAmount !== undefined) {
                    jiggleAmount = preset.jiggleAmount;
                    jiggleAmountSlider.value = Math.round(jiggleAmount * 100);
                    jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
                }
                
                if (preset.jiggleEnabledParams) {
                    // Restore enabled params from preset
                    jiggleParamNames.forEach(param => {
                        if (preset.jiggleEnabledParams[param] !== undefined) {
                            jiggleEnabledParams[param] = preset.jiggleEnabledParams[param];
                            const checkbox = document.getElementById(`jiggle-param-${param}`);
                            if (checkbox) checkbox.checked = jiggleEnabledParams[param];
                        }
                    });
                }
                
                // Restore dilation polarity flip if present
                if (preset.dilationPolarityFlip !== undefined) {
                    const dilationFlipCheckbox = document.getElementById('dilation-polarity-flip');
                    if (dilationFlipCheckbox) {
                        dilationFlipCheckbox.checked = preset.dilationPolarityFlip;
                    }
                }
                
                // Restore audio mapping configuration if present
                if (preset.audioMapping) {
                    Object.keys(preset.audioMapping).forEach(paramName => {
                        const savedMapping = preset.audioMapping[paramName];
                        if (audioMapping[paramName]) {
                            // Restore enabled state
                            if (savedMapping.enabled !== undefined) {
                                audioMapping[paramName].enabled = savedMapping.enabled;
                                const checkbox = document.getElementById(`mapping-enabled-${paramName}`);
                                if (checkbox) checkbox.checked = savedMapping.enabled;
                            }
                            
                            // Restore sensitivity
                            if (savedMapping.sensitivity !== undefined) {
                                audioMapping[paramName].sensitivity = savedMapping.sensitivity;
                                const sensitivitySlider = document.getElementById(`mapping-sensitivity-${paramName}`);
                                const sensitivityValue = document.getElementById(`mapping-sensitivity-value-${paramName}`);
                                if (sensitivitySlider) {
                                    sensitivitySlider.value = savedMapping.sensitivity.toString();
                                    if (sensitivityValue) sensitivityValue.textContent = savedMapping.sensitivity.toFixed(1);
                                }
                            }
                            
                            // Restore smoothing
                            if (savedMapping.smoothing !== undefined) {
                                audioMapping[paramName].smoothing = savedMapping.smoothing;
                                const smoothingSlider = document.getElementById(`mapping-smoothing-${paramName}`);
                                const smoothingValue = document.getElementById(`mapping-smoothing-value-${paramName}`);
                                if (smoothingSlider) {
                                    smoothingSlider.value = savedMapping.smoothing.toString();
                                    if (smoothingValue) smoothingValue.textContent = savedMapping.smoothing.toFixed(2);
                                }
                            }
                        }
                    });
                }
                
                // Update base values to match loaded preset
                updateBaseValues();
                
                // Update dropdown to show the loaded preset
                presetSelect.value = name;
            }
            
            // Initialize presets dropdown
            loadPresets();
            
            // Try to load last active preset BEFORE initializing default values
            const lastActivePreset = localStorage.getItem('sandboxLastActivePreset');
            let presetLoaded = false;
            if (lastActivePreset) {
                const presets = loadPresets();
                if (presets[lastActivePreset]) {
                    presetSelect.value = lastActivePreset;
                    presetLoaded = true;
                }
            }
            
            // Helper function to map slider value using curve editor
            function mapParamValue(paramName, sliderValue, sliderMax = 100) {
                const settings = window.CurveEditor?.getCurveSettings(paramName);
                if (settings && window.CurveEditor) {
                    // Normalize slider value to 0-100 range
                    const normalized = (sliderValue / sliderMax) * 100;
                    return window.CurveEditor.mapValue(normalized, settings);
                }
                return null; // Will fall back to original mapping
            }
            
            // Helper function to reverse map value to slider using curve editor
            function reverseMapParamValue(paramName, value, sliderMax = 100) {
                const settings = window.CurveEditor?.getCurveSettings(paramName);
                if (settings && window.CurveEditor) {
                    const sliderValue = window.CurveEditor.reverseMapValue(value, settings);
                    // Convert from 0-100 range to actual slider range
                    return (sliderValue / 100.0) * sliderMax;
                }
                return null; // Will fall back to original mapping
            }
            
            // Current values (initialize from sliders, or from preset if one was loaded)
            const initialSpikinessSlider = parseFloat(spikinessSlider.value);
            let spikiness = mapParamValue('spikiness', initialSpikinessSlider) ?? (initialSpikinessSlider / 100.0);
            
            const initialSpikeFrequencySlider = parseFloat(spikeFrequencySlider.value);
            let spikeFrequency = mapParamValue('spikeFrequency', initialSpikeFrequencySlider, 20) ?? initialSpikeFrequencySlider;
            
            const initialSpikeSharpnessSlider = parseFloat(spikeSharpnessSlider.value);
            let spikeSharpness = mapParamValue('spikeSharpness', initialSpikeSharpnessSlider) ?? (initialSpikeSharpnessSlider / 100.0);
            
            const initialHueSlider = parseFloat(hueSlider.value);
            let hue = mapParamValue('hue', initialHueSlider, 360) ?? initialHueSlider;
            
            const initialScaleSlider = parseFloat(scaleSlider.value);
            let scale = mapParamValue('scale', initialScaleSlider, 1.0) ?? initialScaleSlider;
            
            // Initialize dilation speed
            const initialDilationSlider = parseFloat(dilationSlider.value);
            let dilationSpeed = mapParamValue('dilationSpeed', initialDilationSlider, 200);
            if (dilationSpeed === null) {
                // Fallback to original exponential mapping
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(initialDilationSlider / 200.0, 1.0 / 8.0) * range;
            }
            
            // Initialize fade amount
            const initialFadeSlider = parseFloat(fadeSlider.value);
            fadeAmount = mapParamValue('fadeAmount', initialFadeSlider) ?? (Math.pow(initialFadeSlider / 100.0, 1.0 / 3.0) * 5.0);
            
            const initialHueShiftSlider = parseFloat(hueShiftSlider.value);
            let hueShiftAmount = mapParamValue('hueShiftAmount', initialHueShiftSlider, 0.2) ?? initialHueShiftSlider;
            
            const initialRotationSlider = parseFloat(rotationSlider.value);
            let rotation = mapParamValue('rotation', initialRotationSlider, 360) ?? initialRotationSlider;
            
            let blendMode = blendModeSelect.value;
            
            const initialBlendOpacitySlider = parseFloat(blendOpacitySlider.value);
            let blendOpacity = mapParamValue('blendOpacity', initialBlendOpacitySlider, 1.0) ?? initialBlendOpacitySlider;
            
            const initialFillSizeSlider = parseFloat(fillSizeSlider.value);
            let fillSize = mapParamValue('fillSize', initialFillSizeSlider) ?? (initialFillSizeSlider / 100.0);
            
            const initialFillOpacitySlider = parseFloat(fillOpacitySlider.value);
            let fillOpacity = mapParamValue('fillOpacity', initialFillOpacitySlider) ?? (initialFillOpacitySlider / 100.0);
            
            const initialEmanationRateSlider = parseFloat(emanationRateSlider.value);
            let emanationRate = mapParamValue('emanationRate', initialEmanationRateSlider, 200) ?? initialEmanationRateSlider;
            
            // Initialize noise amount with curve editor mapping
            const initialNoiseSlider = parseFloat(noiseAmountSlider.value);
            let noiseAmount = mapParamValue('noiseAmount', initialNoiseSlider) ?? (Math.pow(initialNoiseSlider / 100.0, 1.0 / 4.0));
            
            // Initialize noise rate
            const initialNoiseRateSlider = parseFloat(noiseRateSlider.value);
            let noiseRate = mapParamValue('noiseRate', initialNoiseRateSlider) ?? (Math.pow(initialNoiseRateSlider / 100.0, 1.0 / 3.0) * 10.0);
            
            // Initialize blur amount
            const initialBlurSlider = parseFloat(blurAmountSlider.value);
            let blurAmount = mapParamValue('blurAmount', initialBlurSlider) ?? (Math.pow(initialBlurSlider / 100.0, 1.0 / 4.0));
            
            // Initialize blur rate
            const initialBlurRateSlider = parseFloat(blurRateSlider.value);
            let blurRate = mapParamValue('blurRate', initialBlurRateSlider) ?? (Math.pow(initialBlurRateSlider / 100.0, 1.0 / 3.0) * 10.0);
            
            const initialJiggleAmountSlider = parseFloat(jiggleAmountSlider.value);
            let jiggleAmount = mapParamValue('jiggleAmount', initialJiggleAmountSlider) ?? (initialJiggleAmountSlider / 100.0);
            jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            let jiggleEnabled = false;
            
            // Hotkey / playback state
            let freezeEnabled = false;
            let originalDilationSpeed = dilationSpeed;
            
            // Store base values for jiggle (when jiggle is off, these match current values)
            let baseSpikiness = spikiness;
            let baseSpikeFrequency = spikeFrequency;
            let baseSpikeSharpness = spikeSharpness;
            let baseHue = hue;
            let baseScale = scale;
            let baseFillSize = fillSize;
            let baseFillOpacity = fillOpacity;
            let baseRotation = rotation;
            let baseHueShiftAmount = hueShiftAmount;
            let baseDilationSpeed = dilationSpeed;
            let baseFadeAmount = fadeAmount;
            let baseEmanationRate = emanationRate;
            let baseNoiseAmount = noiseAmount;
            let baseNoiseRate = noiseRate;
            let baseBlurAmount = blurAmount;
            let baseBlurRate = blurRate;
            let baseBlendOpacity = blendOpacity;
            
            // Initialize auto rotation speed
            const initialAutoRotationSlider = parseFloat(autoRotationSlider.value);
            let autoRotationSpeed = mapParamValue('autoRotationSpeed', initialAutoRotationSlider, 200);
            if (autoRotationSpeed === null) {
                // Fallback to original exponential mapping
                autoRotationSpeed = -1.0 + Math.pow(initialAutoRotationSlider / 200.0, 0.5) * 361.0;
            }
            
            // Now initialize baseAutoRotationSpeed after autoRotationSpeed is declared
            let baseAutoRotationSpeed = autoRotationSpeed;
            
            // Initialize all parameters in the interpolator with their initial values
            // This ensures interpolation works from the start
            interpolator.setTarget('spikiness', spikiness, 0); // Instant for initial values
            interpolator.setTarget('spikeFrequency', spikeFrequency, 0);
            interpolator.setTarget('spikeSharpness', spikeSharpness, 0);
            interpolator.setTarget('hue', hue, 0);
            interpolator.setTarget('scale', scale, 0);
            interpolator.setTarget('fillSize', fillSize, 0);
            interpolator.setTarget('fillOpacity', fillOpacity, 0);
            interpolator.setTargetRotation('rotation', rotation, 0); // Use rotation-specific setter
            interpolator.setTarget('hueShiftAmount', hueShiftAmount, 0);
            interpolator.setTarget('dilationSpeed', dilationSpeed, 0);
            interpolator.setTarget('fadeAmount', fadeAmount, 0);
            interpolator.setTarget('emanationRate', emanationRate, 0);
            interpolator.setTarget('autoRotationSpeed', autoRotationSpeed, 0);
            interpolator.setTarget('noiseAmount', noiseAmount, 0);
            interpolator.setTarget('noiseRate', noiseRate, 0);
            interpolator.setTarget('blurAmount', blurAmount, 0);
            interpolator.setTarget('blurRate', blurRate, 0);
            interpolator.setTarget('blendOpacity', blendOpacity, 0);
            
            // Target origins for jiggle when user edits params during jiggle
            // Jiggle will smoothly ease its orbit center toward these targets
            let targetBaseSpikiness = baseSpikiness;
            let targetBaseSpikeFrequency = baseSpikeFrequency;
            let targetBaseSpikeSharpness = baseSpikeSharpness;
            let targetBaseHue = baseHue;
            let targetBaseScale = baseScale;
            let targetBaseFillSize = baseFillSize;
            let targetBaseFillOpacity = baseFillOpacity;
            let targetBaseRotation = baseRotation;
            let targetBaseHueShiftAmount = baseHueShiftAmount;
            let targetBaseDilationSpeed = baseDilationSpeed;
            let targetBaseFadeAmount = baseFadeAmount;
            let targetBaseEmanationRate = baseEmanationRate;
            let targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
            let targetBaseNoiseAmount = baseNoiseAmount;
            let targetBaseNoiseRate = baseNoiseRate;
            let targetBaseBlurAmount = baseBlurAmount;
            let targetBaseBlurRate = baseBlurRate;
            let targetBaseBlendOpacity = baseBlendOpacity;
            
            // Now load the preset if one was found (this will override the default values)
            if (presetLoaded) {
                loadPreset(lastActivePreset);
            } else {
                // If no preset loaded, initialize status indicators
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
        
            // Helper function to handle editable value changes
            // Direct input bypasses clamping - allows any value
            function handleValueEdit(valueElement, parseFn, formatFn, updateFn) {
                valueElement.addEventListener('blur', (e) => {
                    const text = e.target.textContent.trim();
                    const numValue = parseFn(text);
                    if (!isNaN(numValue)) {
                        // No clamping - accept the value as-is
                        const formatted = formatFn(numValue);
                        e.target.textContent = formatted;
                        updateFn(numValue);
                    } else {
                        // Restore previous value on invalid input
                        const currentValue = parseFn(e.target.textContent);
                        if (!isNaN(currentValue)) {
                            e.target.textContent = formatFn(currentValue);
                        }
                    }
                });
                
                valueElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    }
                });
            }
            
            // Update sliders
            spikinessSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('spikiness', sliderValue) ?? (sliderValue / 100.0);
                interpolator.setTarget('spikiness', targetValue);
                spikiness = targetValue; // Update direct value for display
                spikinessValue.textContent = targetValue.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikinessValue, 
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    interpolator.setTarget('spikiness', val);
                    spikiness = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikiness');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikinessSlider.value = reverseMapParamValue('spikiness', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        spikinessSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            spikeFrequencySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('spikeFrequency', sliderValue, 20) ?? sliderValue;
                interpolator.setTarget('spikeFrequency', targetValue);
                spikeFrequency = targetValue;
                spikeFrequencyValue.textContent = targetValue.toFixed(1);
                updateBaseValues();
            });
            
            handleValueEdit(spikeFrequencyValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    interpolator.setTarget('spikeFrequency', val);
                    spikeFrequency = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikeFrequency');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikeFrequencySlider.value = reverseMapParamValue('spikeFrequency', clampedForDisplay, 20) ?? clampedForDisplay;
                    } else {
                        const clampedForSlider = Math.max(2, Math.min(20, val));
                        spikeFrequencySlider.value = clampedForSlider;
                    }
                    updateBaseValues();
                }
            );
            
            spikeSharpnessSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('spikeSharpness', sliderValue) ?? (sliderValue / 100.0);
                interpolator.setTarget('spikeSharpness', targetValue);
                spikeSharpness = targetValue;
                spikeSharpnessValue.textContent = targetValue.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikeSharpnessValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    interpolator.setTarget('spikeSharpness', val);
                    spikeSharpness = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikeSharpness');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikeSharpnessSlider.value = reverseMapParamValue('spikeSharpness', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        spikeSharpnessSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            hueSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('hue', sliderValue, 360) ?? sliderValue;
                interpolator.setTarget('hue', targetValue);
                hue = targetValue;
                hueValue.textContent = Math.round(targetValue) + '°';
                updateBaseValues();
            });
            
            handleValueEdit(hueValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    interpolator.setTarget('hue', val);
                    hue = val;
                    const settings = window.CurveEditor?.getCurveSettings('hue');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        hueSlider.value = reverseMapParamValue('hue', clampedForDisplay, 360) ?? Math.round(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(360, val));
                        hueSlider.value = Math.round(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            scaleSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('scale', sliderValue, 1.0) ?? sliderValue;
                interpolator.setTarget('scale', targetValue);
                scale = targetValue;
                scaleValue.textContent = targetValue.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(scaleValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    interpolator.setTarget('scale', val);
                    scale = val;
                    const settings = window.CurveEditor?.getCurveSettings('scale');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        const sliderVal = reverseMapParamValue('scale', clampedForDisplay, 1.0) ?? clampedForDisplay;
                        scaleSlider.value = sliderVal.toFixed(2);
                        scaleValue.textContent = clampedForDisplay.toFixed(2);
                    } else {
                        const clampedForSlider = Math.max(0.05, Math.min(1.0, val));
                        scaleSlider.value = clampedForSlider.toFixed(2);
                        scaleValue.textContent = clampedForSlider.toFixed(2);
                    }
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map dilation speed to slider value
            function dilationSpeedToSlider(speed) {
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                // Reverse: speed = min + (slider/200)^(1/8) * range
                // slider = 200 * ((speed - min) / range)^8
                const normalized = (speed - min) / range;
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
            }
            
            dilationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                dilationSpeed = mapParamValue('dilationSpeed', sliderValue, 200);
                if (dilationSpeed === null) {
                    // Fallback to original exponential mapping
                    const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                    const range = (1.22 - 0.88) / (1.0 - midPower);
                    const min = 1.0 - midPower * range;
                    dilationSpeed = min + Math.pow(sliderValue / 200.0, 1.0 / 8.0) * range;
                }
                dilationValue.textContent = dilationSpeed.toFixed(4);
            });
            
            handleValueEdit(dilationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(4),
                (val) => {
                    dilationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0.88, Math.min(1.22, val));
                    dilationSlider.value = dilationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map fade amount to slider value
            function fadeAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/3) * 5.0
                // slider = 100 * (amount / 5.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount / 5.0)), 3));
            }
            
            fadeSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fadeAmount = mapParamValue('fadeAmount', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 5.0);
                fadeValue.textContent = fadeAmount.toFixed(3);
            });
            
            handleValueEdit(fadeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    fadeAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(5.0, val));
                    fadeSlider.value = fadeAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            hueShiftSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                hueShiftAmount = mapParamValue('hueShiftAmount', sliderValue, 0.2) ?? sliderValue;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                updateBaseValues();
            });
            
            handleValueEdit(hueShiftValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    hueShiftAmount = val;
                    const settings = window.CurveEditor?.getCurveSettings('hueShiftAmount');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        hueShiftSlider.value = reverseMapParamValue('hueShiftAmount', clampedForDisplay, 0.2) ?? clampedForDisplay.toFixed(3);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(0.2, val));
                        hueShiftSlider.value = clampedForSlider.toFixed(3);
                    }
                    updateBaseValues();
                }
            );
            
            rotationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetRotation = mapParamValue('rotation', sliderValue, 360) ?? sliderValue;
                interpolator.setTargetRotation('rotation', targetRotation);
                rotation = targetRotation; // Update direct value for display
                rotationValue.textContent = Math.round(targetRotation) + '°';
                updateBaseValues();
            });
            
            handleValueEdit(rotationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    interpolator.setTargetRotation('rotation', val);
                    rotation = val;
                    const settings = window.CurveEditor?.getCurveSettings('rotation');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        rotationSlider.value = reverseMapParamValue('rotation', clampedForDisplay, 360) ?? Math.round(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(360, val));
                        rotationSlider.value = Math.round(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            blendModeSelect.addEventListener('change', (e) => {
                blendMode = e.target.value;
                updateStatusIndicators();
            });
            
            blendOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blendOpacity = mapParamValue('blendOpacity', sliderValue, 1.0) ?? sliderValue;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blendOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blendOpacity = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blendOpacitySlider.value = clampedForSlider.toFixed(2);
                    updateBaseValues();
                }
            );
            
            fillSizeSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fillSize = mapParamValue('fillSize', sliderValue) ?? (sliderValue / 100.0);
                fillSizeValue.textContent = fillSize.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillSizeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillSize = val;
                    const settings = window.CurveEditor?.getCurveSettings('fillSize');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        fillSizeSlider.value = reverseMapParamValue('fillSize', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        fillSizeSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            fillOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fillOpacity = mapParamValue('fillOpacity', sliderValue) ?? (sliderValue / 100.0);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillOpacity = val;
                    const settings = window.CurveEditor?.getCurveSettings('fillOpacity');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        fillOpacitySlider.value = reverseMapParamValue('fillOpacity', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        fillOpacitySlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            emanationRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                emanationRate = mapParamValue('emanationRate', sliderValue, 200) ?? sliderValue;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                updateStatusIndicators();
            });
            
            handleValueEdit(emanationRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    emanationRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(2, Math.min(200, val));
                    emanationRateSlider.value = clampedForSlider;
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map noise amount to slider value
            function noiseAmountToSlider(amount) {
                // Use curve editor reverse mapping if available
                const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                if (settings && window.CurveEditor) {
                    return window.CurveEditor.reverseMapValue(amount, settings);
                }
                // Fallback to default exponential mapping
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount)), 4));
            }
            
            // Noise amount slider with curve editor mapping
            noiseAmountSlider.addEventListener('input', (e) => {
                // Map slider value (0-100) to noise amount using curve editor
                const sliderValue = parseFloat(e.target.value);
                const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                if (settings && window.CurveEditor) {
                    noiseAmount = window.CurveEditor.mapValue(sliderValue, settings);
                } else {
                    // Fallback to default exponential mapping
                    noiseAmount = Math.pow(sliderValue / 100.0, 1.0 / 4.0);
                }
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(noiseAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    noiseAmount = val;
                    // Update slider position using curve editor reverse mapping
                    // This will clamp the slider display to the curve's min/max range
                    const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        noiseAmountSlider.value = noiseAmountToSlider(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        noiseAmountSlider.value = noiseAmountToSlider(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map noise rate to slider value (slow exponential curve)
            function noiseRateToSlider(rate) {
                // Map rate (0-10) to slider (0-100) with exponential curve
                // rate = (slider / 100)^(1/3) * 10.0
                // slider = 100 * (rate / 10.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, rate / 10.0)), 3) * 10) / 10; // Round to 0.1
            }
            
            // Noise rate slider (0-100 slider maps to 0-10 rate with slow exponential curve, where 1.0 = every 2 seconds)
            noiseRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                noiseRate = mapParamValue('noiseRate', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 10.0);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(noiseRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    noiseRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(10, val));
                    noiseRateSlider.value = noiseRateToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Blur amount slider
            // Helper function to reverse-map blur amount to slider value
            function blurAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/4)
                // slider = 100 * amount^4
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount)), 4));
            }
            
            // Blur amount slider with exponential mapping (0-100 slider to 0-1, granular near 0)
            blurAmountSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blurAmount = mapParamValue('blurAmount', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 4.0));
                blurAmountValue.textContent = blurAmount.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blurAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blurAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blurAmountSlider.value = blurAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map blur rate to slider value (slow exponential curve)
            function blurRateToSlider(rate) {
                // Map rate (0-10) to slider (0-100) with exponential curve
                // rate = (slider / 100)^(1/3) * 10.0
                // slider = 100 * (rate / 10.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, rate / 10.0)), 3) * 10) / 10; // Round to 0.1
            }
            
            // Blur rate slider (0-100 slider maps to 0-10 rate with slow exponential curve, where 1.0 = every 2 seconds)
            blurRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blurRate = mapParamValue('blurRate', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 10.0);
                blurRateValue.textContent = blurRate.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blurRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blurRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(10, val));
                    blurRateSlider.value = blurRateToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map auto rotation speed to slider value
            function autoRotationSpeedToSlider(speed) {
                // Reverse: speed = -1 + (slider/200)^0.5 * 361
                // slider = 200 * ((speed + 1) / 361)^2
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, (speed + 1) / 361.0)), 2));
            }
            
            autoRotationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                let targetSpeed = mapParamValue('autoRotationSpeed', sliderValue, 200);
                if (targetSpeed === null) {
                    // Fallback to original exponential mapping
                    targetSpeed = -1.0 + Math.pow(sliderValue / 200.0, 0.5) * 361.0;
                }
                interpolator.setTarget('autoRotationSpeed', targetSpeed);
                autoRotationSpeed = targetSpeed; // Update direct value for display
                autoRotationValue.textContent = targetSpeed.toFixed(1) + '°';
                updateStatusIndicators();
            });
            
            handleValueEdit(autoRotationValue,
                (text) => parseFloat(text.replace(/[^0-9.-]/g, '')),
                (val) => val.toFixed(1) + '°',
                (val) => {
                    autoRotationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(-1, Math.min(360, val));
                    autoRotationSlider.value = autoRotationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Wire up curve editor buttons
            document.querySelectorAll('.curve-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paramName = btn.getAttribute('data-param');
                    if (paramName && window.CurveEditor) {
                        window.CurveEditor.open(paramName);
                    }
                });
            });
            
            // Save current state as preset
            function savePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please enter a preset name');
                    return;
                }
                
                // Build audio mapping configuration object
                const audioMappingConfig = {};
                Object.keys(audioMapping).forEach(paramName => {
                    const mapping = audioMapping[paramName];
                    audioMappingConfig[paramName] = {
                        enabled: mapping.enabled,
                        sensitivity: mapping.sensitivity !== undefined ? mapping.sensitivity : 1.0,
                        smoothing: mapping.smoothing
                    };
                });
                
                const preset = {
                    spikiness: spikiness,
                    spikeFrequency: spikeFrequency,
                    spikeSharpness: spikeSharpness,
                    hue: hue,
                    scale: scale,
                    fillSize: fillSize,
                    fillOpacity: fillOpacity,
                    dilationSlider: parseFloat(dilationSlider.value), // Store slider value for proper restoration
                    fadeSlider: parseFloat(fadeSlider.value), // Store slider value for proper restoration
                    hueShiftAmount: hueShiftAmount,
                    rotation: rotation,
                    blendMode: blendMode,
                    blendOpacity: blendOpacity,
                    emanationRate: emanationRate,
                    noiseAmount: noiseAmount,
                    noiseRate: noiseRate,
                    blurAmount: blurAmount,
                    blurRate: blurRate,
                    autoRotationSpeed: autoRotationSpeed, // Store actual value (will reverse map to slider on load)
                    autoRotationSlider: parseFloat(autoRotationSlider.value), // Also store slider for easier restoration
                    jiggleAmount: jiggleAmount, // Store jiggle amount
                    jiggleEnabledParams: { ...jiggleEnabledParams }, // Store jiggle enabled params (copy object)
                    audioMapping: audioMappingConfig, // Store audio mapping configuration
                    dilationPolarityFlip: dilationPolarityFlip ? dilationPolarityFlip.checked : false // Store dilation polarity flip state
                };
                
                const presets = loadPresets();
                presets[name] = preset;
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                updatePresetNames(); // Update preset names list for cycling
                presetNameInput.value = '';
                alert(`Preset "${name}" saved!`);
            }
            
            // Delete preset
            function deletePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please select a preset to delete');
                    return;
                }
                
                if (!confirm(`Delete preset "${name}"?`)) {
                    return;
                }
                
                const presets = loadPresets();
                delete presets[name];
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetSelect.value = '';
            }
            
            // Event listeners
            presetSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadPreset(e.target.value);
                    localStorage.setItem('sandboxLastActivePreset', e.target.value);
                    updatePresetNames(); // Update preset names list for cycling
                }
            });
            
            savePresetBtn.addEventListener('click', () => {
                const presetName = presetNameInput.value.trim();
                savePreset(presetName);
                if (presetName) {
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                    presetSelect.value = presetName;
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            deletePresetBtn.addEventListener('click', () => {
                const presetToDelete = presetSelect.value;
                deletePreset(presetToDelete);
                if (localStorage.getItem('sandboxLastActivePreset') === presetToDelete) {
                    localStorage.removeItem('sandboxLastActivePreset');
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            // Export presets to JSON file
            exportPresetsBtn.addEventListener('click', () => {
                const presets = loadPresets();
                const jsonString = JSON.stringify(presets, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sandbox-presets.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(`Exported ${Object.keys(presets).length} preset(s) to sandbox-presets.json`);
            });
            
            // Import presets from JSON file
            importPresetsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        
                        if (typeof importedPresets !== 'object' || Array.isArray(importedPresets)) {
                            alert('Invalid preset file format. Expected an object with preset names as keys.');
                            return;
                        }
                        
                        // Load current presets
                        const currentPresets = loadPresets();
                        
                        // Merge imported presets with current presets (imported presets take precedence for conflicts)
                        let importedCount = 0;
                        let overwrittenCount = 0;
                        for (const [name, preset] of Object.entries(importedPresets)) {
                            if (currentPresets[name]) {
                                overwrittenCount++;
                            } else {
                                importedCount++;
                            }
                            currentPresets[name] = preset;
                        }
                        
                        // Save merged presets
                        localStorage.setItem('sandboxPresets', JSON.stringify(currentPresets));
                        loadPresets();
                        
                        // Update preset names list for hotkeys (if updatePresetNames is defined)
                        if (typeof updatePresetNames === 'function') {
                            updatePresetNames();
                        }
                        
                        // Reset file input
                        e.target.value = '';
                        
                        const message = `Imported ${importedCount} new preset(s)${overwrittenCount > 0 ? ` and overwrote ${overwrittenCount} existing preset(s)` : ''}.`;
                        alert(message);
                    } catch (error) {
                        alert(`Error importing presets: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            });
            
            // Randomize function
            function randomizeAll() {
                // Randomize all parameters within their valid ranges
                
                // Shape parameters
                spikiness = Math.random();
                spikeFrequency = 2 + Math.random() * 18; // 2-20
                spikeSharpness = Math.random();
                hue = Math.random() * 360;
                scale = 0.05 + Math.random() * 0.95; // 0.05-1.0
                fillSize = Math.random();
                fillOpacity = Math.random();
                rotation = Math.random() * 360;
                hueShiftAmount = Math.random() * 0.2; // 0-0.2
                
                // Blend parameters
                const blendModes = ['additive', 'alpha', 'multiply', 'screen', 'overlay'];
                blendMode = blendModes[Math.floor(Math.random() * blendModes.length)];
                blendOpacity = Math.random();
                
                // Emanation parameters
                // Dilation speed: 0.88-1.22 (use slider range 0-200, map to actual value)
                const randomDilationSlider = Math.random() * 200;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(randomDilationSlider / 200.0, 1.0 / 8.0) * range;
                
                // Fade amount: 0-5.0 (use slider range 0-100, map to actual value)
                const randomFadeSlider = Math.random() * 100;
                fadeAmount = Math.pow(randomFadeSlider / 100.0, 1.0 / 3.0) * 5.0;
                
                // Emanation rate: 2-200
                emanationRate = 2 + Math.random() * 198;
                
                // Filter parameters
                noiseAmount = Math.random(); // 0-1
                noiseRate = Math.random() * 10.0; // 0-10 (time-based: interval = 2.0 / rate)
                blurAmount = Math.random(); // 0-1
                blurRate = Math.random() * 10.0; // 0-10 (time-based: interval = 2.0 / rate)
                
                // Auto rotation speed: -1 to 360 (use slider range 0-200, map to actual value)
                const randomAutoRotationSlider = Math.random() * 200;
                autoRotationSpeed = -1.0 + Math.pow(randomAutoRotationSlider / 200.0, 0.5) * 361.0;
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = Math.round(hue);
                hueValue.textContent = Math.round(hue) + '°';
                scaleSlider.value = scale.toFixed(2);
                scaleValue.textContent = scale.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                rotationSlider.value = Math.round(rotation);
                rotationValue.textContent = Math.round(rotation) + '°';
                hueShiftSlider.value = hueShiftAmount.toFixed(3);
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                
                // Update blend controls
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity.toFixed(2);
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                
                // Update emanation controls
                dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = fadeAmountToSlider(fadeAmount);
                fadeValue.textContent = fadeAmount.toFixed(3);
                emanationRateSlider.value = emanationRate.toFixed(1);
                emanationRateValue.textContent = emanationRate.toFixed(1);
                
                // Update filter controls
                noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                noiseRateSlider.value = noiseRateToSlider(noiseRate);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                blurAmountSlider.value = blurAmountToSlider(blurAmount);
                blurAmountValue.textContent = blurAmount.toFixed(2);
                blurRateSlider.value = blurRateToSlider(blurRate);
                blurRateValue.textContent = blurRate.toFixed(2);
                
                // Update auto rotation
                autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Update base values
                baseSpikiness = spikiness;
                baseSpikeFrequency = spikeFrequency;
                baseSpikeSharpness = spikeSharpness;
                baseHue = hue;
                baseScale = scale;
                baseFillSize = fillSize;
                baseFillOpacity = fillOpacity;
                baseRotation = rotation;
                baseHueShiftAmount = hueShiftAmount;
                baseDilationSpeed = dilationSpeed;
                baseFadeAmount = fadeAmount;
                baseEmanationRate = emanationRate;
                baseAutoRotationSpeed = autoRotationSpeed;
                baseNoiseAmount = noiseAmount;
                baseNoiseRate = noiseRate;
                baseBlurAmount = blurAmount;
                baseBlurRate = blurRate;
                baseBlendOpacity = blendOpacity;
                
                // Update target bases to match
                targetBaseSpikiness = baseSpikiness;
                targetBaseSpikeFrequency = baseSpikeFrequency;
                targetBaseSpikeSharpness = baseSpikeSharpness;
                targetBaseHue = baseHue;
                targetBaseScale = baseScale;
                targetBaseFillSize = baseFillSize;
                targetBaseFillOpacity = baseFillOpacity;
                targetBaseRotation = baseRotation;
                targetBaseHueShiftAmount = baseHueShiftAmount;
                targetBaseDilationSpeed = baseDilationSpeed;
                targetBaseFadeAmount = baseFadeAmount;
                targetBaseEmanationRate = baseEmanationRate;
                targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                targetBaseNoiseAmount = baseNoiseAmount;
                targetBaseNoiseRate = baseNoiseRate;
                targetBaseBlurAmount = baseBlurAmount;
                targetBaseBlurRate = baseBlurRate;
                targetBaseBlendOpacity = baseBlendOpacity;
            }
            
            // Resolution controls
            function updateResolution(resolutionKey) {
                currentResolution = resolutionKey;
                const res = RESOLUTIONS[resolutionKey];
                
                // Update URL without page reload
                const url = new URL(window.location);
                if (resolutionKey === 'window') {
                    url.searchParams.delete('resolution');
                } else {
                    url.searchParams.set('resolution', resolutionKey);
                }
                window.history.replaceState({}, '', url);
                
                // Update UI
                document.querySelectorAll('.resolution-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-resolution="${resolutionKey}"]`).classList.add('active');
                
                // Update display
                const display = document.getElementById('current-resolution-display');
                if (res.width && res.height) {
                    display.textContent = `Current: ${res.name} (${res.width}×${res.height})`;
                } else {
                    display.textContent = `Current: ${res.name}`;
                }
                
                // Resize canvas
                renderer.resize();
            }
            
            // Set initial active button
            document.querySelector(`[data-resolution="${currentResolution}"]`).classList.add('active');
            updateResolution(currentResolution); // Update display
            
            // Resolution button event listeners
            document.querySelectorAll('.resolution-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const resolution = e.target.dataset.resolution;
                    updateResolution(resolution);
                });
            });
            
            randomizeBtn.addEventListener('click', randomizeAll);
            
            // Jiggle functionality
            jiggleAmountSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                jiggleAmount = mapParamValue('jiggleAmount', sliderValue) ?? (sliderValue / 100.0);
                jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            });
            
            handleValueEdit(jiggleAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')) / 100.0, // Convert percentage to 0-1
                (val) => Math.round(val * 100) + '%',
                (val) => {
                    jiggleAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    jiggleAmountSlider.value = Math.round(clampedForSlider * 100);
                }
            );
            
            jiggleBtn.addEventListener('click', () => {
                jiggleEnabled = !jiggleEnabled;
                jiggleBtn.textContent = jiggleEnabled ? 'Stop Jiggle' : 'Jiggle';
                jiggleBtn.style.background = jiggleEnabled ? '#a00' : '#a0a';
                
                if (!jiggleEnabled) {
                    // Keep current jiggled values and update base values to match
                    // This way the values persist when jiggle is turned off
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    // Targets match new bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                    
                    // Sync interpolator targets to current values so interpolation continues smoothly
                    interpolator.setTarget('spikiness', spikiness, 0); // Instant sync
                    interpolator.setTarget('spikeFrequency', spikeFrequency, 0);
                    interpolator.setTarget('spikeSharpness', spikeSharpness, 0);
                    interpolator.setTarget('hue', hue, 0);
                    interpolator.setTarget('scale', scale, 0);
                    interpolator.setTarget('fillSize', fillSize, 0);
                    interpolator.setTarget('fillOpacity', fillOpacity, 0);
                    interpolator.setTargetRotation('rotation', rotation, 0);
                    interpolator.setTarget('hueShiftAmount', hueShiftAmount, 0);
                    interpolator.setTarget('dilationSpeed', dilationSpeed, 0);
                    interpolator.setTarget('fadeAmount', fadeAmount, 0);
                    interpolator.setTarget('emanationRate', emanationRate, 0);
                    interpolator.setTarget('autoRotationSpeed', autoRotationSpeed, 0);
                    interpolator.setTarget('noiseAmount', noiseAmount, 0);
                    interpolator.setTarget('noiseRate', noiseRate, 0);
                    interpolator.setTarget('blurAmount', blurAmount, 0);
                    interpolator.setTarget('blurRate', blurRate, 0);
                    interpolator.setTarget('blendOpacity', blendOpacity, 0);
                    
                    // Update sliders to reflect current values (they should already match, but ensure sync)
                    spikinessSlider.value = Math.round(spikiness * 100);
                    spikeFrequencySlider.value = spikeFrequency;
                    spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                    hueSlider.value = Math.round(hue);
                    scaleSlider.value = scale.toFixed(2);
                    fillSizeSlider.value = Math.round(fillSize * 100);
                    fillOpacitySlider.value = Math.round(fillOpacity * 100);
                    rotationSlider.value = Math.round(rotation);
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                    fadeSlider.value = fadeAmountToSlider(fadeAmount);
                    emanationRateSlider.value = emanationRate.toFixed(1);
                    autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                    noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                    noiseRateSlider.value = noiseRateToSlider(noiseRate);
                    blurAmountSlider.value = blurAmountToSlider(blurAmount);
                    blurRateSlider.value = blurRateToSlider(blurRate);
                    blendOpacitySlider.value = blendOpacity.toFixed(2);
                    
                    // Update status indicators (unsaved state may have changed)
                    updateStatusIndicators();
                } else {
                    // Store current values as base when starting jiggle
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    // Targets start at current bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                }
                
                // Update jiggle indicator
                updateStatusIndicators();
            });
            
            // Update base values when sliders change
            function updateBaseValues() {
                if (!jiggleEnabled) {
                    // When jiggle is off, bases track current values directly
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                } else {
                    // When jiggle is on, treat current values as new desired origins
                    // Jiggle will smoothly ease its orbit center toward these targets
                    targetBaseSpikiness = spikiness;
                    targetBaseSpikeFrequency = spikeFrequency;
                    targetBaseSpikeSharpness = spikeSharpness;
                    targetBaseHue = hue;
                    targetBaseScale = scale;
                    targetBaseFillSize = fillSize;
                    targetBaseFillOpacity = fillOpacity;
                    targetBaseRotation = rotation;
                    targetBaseHueShiftAmount = hueShiftAmount;
                    targetBaseDilationSpeed = dilationSpeed;
                    targetBaseFadeAmount = fadeAmount;
                    targetBaseEmanationRate = emanationRate;
                    targetBaseAutoRotationSpeed = autoRotationSpeed;
                    targetBaseNoiseAmount = noiseAmount;
                    targetBaseNoiseRate = noiseRate;
                    targetBaseBlurAmount = blurAmount;
                    targetBaseBlurRate = blurRate;
                    targetBaseBlendOpacity = blendOpacity;
                }
                // Update status indicators to check for unsaved changes
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
            
            let startTime = Date.now();
            let lastCaptureTime = 0;
            const TARGET_FPS = 60;
            const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
            
            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;
                
                // Get audio metrics if enabled
                let audioMetrics = null;
                if (audioEnabled && audioAnalyzer) {
                    audioMetrics = audioAnalyzer.getMetrics();
                    updateAudioDrivenParams(audioMetrics);
                    
                    // Update audio visualization (meters and legend)
                    if (audioMeters && audioLegend) {
                        audioMeters.updateAll(audioMetrics);
                        audioLegend.update(audioMetrics);
                    }
                    
                    // Update mapping value displays
                    updateMappingValueDisplays();
                }
                
                // Update interpolation system (only if enabled and jiggle is off)
                // When jiggle is enabled, it bypasses interpolation and sets values directly
                const interpolationActive = interpolator.enabled && !jiggleEnabled;
                if (interpolationActive) {
                    interpolator.update();
                }
                
                // Get values for rendering
                // When jiggle is enabled OR interpolation is disabled, use direct values
                // When jiggle is off AND interpolation is enabled, use interpolated values
                // Then blend with audio-driven values if audio reactive is enabled
                let interpolatedRotation, interpolatedAutoRotationSpeed, interpolatedHueShiftAmount;
                let interpolatedDilationSpeed, interpolatedEmanationRate, interpolatedNoiseAmount;
                let interpolatedNoiseRate, interpolatedBlurAmount, interpolatedBlurRate;
                let interpolatedSpikiness, interpolatedSpikeFrequency, interpolatedSpikeSharpness;
                let interpolatedHue, interpolatedScale, interpolatedFillSize;
                let interpolatedFillOpacity, interpolatedFadeAmount, interpolatedBlendOpacity;
                
                const audioReactiveStrength = audioReactiveEnabled && audioEnabled ? 1.0 : 0.0;
                
                if (interpolationActive) {
                    // Use interpolated values when interpolation is enabled and jiggle is off
                    interpolatedRotation = interpolator.getCurrent('rotation') ?? rotation;
                    interpolatedAutoRotationSpeed = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                    interpolatedHueShiftAmount = interpolator.getCurrent('hueShiftAmount') ?? hueShiftAmount;
                    interpolatedDilationSpeed = interpolator.getCurrent('dilationSpeed') ?? dilationSpeed;
                    interpolatedEmanationRate = interpolator.getCurrent('emanationRate') ?? emanationRate;
                    interpolatedNoiseAmount = interpolator.getCurrent('noiseAmount') ?? noiseAmount;
                    interpolatedNoiseRate = interpolator.getCurrent('noiseRate') ?? noiseRate;
                    interpolatedBlurAmount = interpolator.getCurrent('blurAmount') ?? blurAmount;
                    interpolatedBlurRate = interpolator.getCurrent('blurRate') ?? blurRate;
                    interpolatedSpikiness = interpolator.getCurrent('spikiness') ?? spikiness;
                    interpolatedSpikeFrequency = interpolator.getCurrent('spikeFrequency') ?? spikeFrequency;
                    interpolatedSpikeSharpness = interpolator.getCurrent('spikeSharpness') ?? spikeSharpness;
                    interpolatedHue = interpolator.getCurrent('hue') ?? hue;
                    interpolatedScale = interpolator.getCurrent('scale') ?? scale;
                    interpolatedFillSize = interpolator.getCurrent('fillSize') ?? fillSize;
                    interpolatedFillOpacity = interpolator.getCurrent('fillOpacity') ?? fillOpacity;
                    interpolatedFadeAmount = interpolator.getCurrent('fadeAmount') ?? fadeAmount;
                    interpolatedBlendOpacity = interpolator.getCurrent('blendOpacity') ?? blendOpacity;
                } else {
                    // Use direct values when jiggle is active OR interpolation is disabled
                    interpolatedRotation = rotation;
                    interpolatedAutoRotationSpeed = autoRotationSpeed;
                    interpolatedHueShiftAmount = hueShiftAmount;
                    interpolatedDilationSpeed = dilationSpeed;
                    interpolatedEmanationRate = emanationRate;
                    interpolatedNoiseAmount = noiseAmount;
                    interpolatedNoiseRate = noiseRate;
                    interpolatedBlurAmount = blurAmount;
                    interpolatedBlurRate = blurRate;
                    interpolatedSpikiness = spikiness;
                    interpolatedSpikeFrequency = spikeFrequency;
                    interpolatedSpikeSharpness = spikeSharpness;
                    interpolatedHue = hue;
                    interpolatedScale = scale;
                    interpolatedFillSize = fillSize;
                    interpolatedFillOpacity = fillOpacity;
                    interpolatedFadeAmount = fadeAmount;
                    interpolatedBlendOpacity = blendOpacity;
                }
                
                // Apply audio-driven relative offsets if audio reactive is enabled
                // Uses jiggle ranges and respects jiggleEnabledParams
                // Audio offsets are applied relative to interpolated values, within jiggle ranges
                if (audioReactiveEnabled && audioEnabled) {
                    interpolatedSpikiness = applyAudioReactivity('spikiness', interpolatedSpikiness, jiggleEnabledParams, jiggleAmount);
                    interpolatedSpikeFrequency = applyAudioReactivity('spikeFrequency', interpolatedSpikeFrequency, jiggleEnabledParams, jiggleAmount);
                    interpolatedSpikeSharpness = applyAudioReactivity('spikeSharpness', interpolatedSpikeSharpness, jiggleEnabledParams, jiggleAmount);
                    interpolatedHue = applyAudioReactivity('hue', interpolatedHue, jiggleEnabledParams, jiggleAmount);
                    interpolatedScale = applyAudioReactivity('scale', interpolatedScale, jiggleEnabledParams, jiggleAmount);
                    interpolatedFillSize = applyAudioReactivity('fillSize', interpolatedFillSize, jiggleEnabledParams, jiggleAmount);
                    interpolatedFillOpacity = applyAudioReactivity('fillOpacity', interpolatedFillOpacity, jiggleEnabledParams, jiggleAmount);
                    interpolatedEmanationRate = applyAudioReactivity('emanationRate', interpolatedEmanationRate, jiggleEnabledParams, jiggleAmount);
                    interpolatedDilationSpeed = applyAudioReactivity('dilationSpeed', interpolatedDilationSpeed, jiggleEnabledParams, jiggleAmount);
                    interpolatedFadeAmount = applyAudioReactivity('fadeAmount', interpolatedFadeAmount, jiggleEnabledParams, jiggleAmount);
                    interpolatedAutoRotationSpeed = applyAudioReactivity('autoRotationSpeed', interpolatedAutoRotationSpeed, jiggleEnabledParams, jiggleAmount);
                    interpolatedHueShiftAmount = applyAudioReactivity('hueShiftAmount', interpolatedHueShiftAmount, jiggleEnabledParams, jiggleAmount);
                    interpolatedNoiseAmount = applyAudioReactivity('noiseAmount', interpolatedNoiseAmount, jiggleEnabledParams, jiggleAmount);
                    interpolatedNoiseRate = applyAudioReactivity('noiseRate', interpolatedNoiseRate, jiggleEnabledParams, jiggleAmount);
                    interpolatedBlurAmount = applyAudioReactivity('blurAmount', interpolatedBlurAmount, jiggleEnabledParams, jiggleAmount);
                    interpolatedBlurRate = applyAudioReactivity('blurRate', interpolatedBlurRate, jiggleEnabledParams, jiggleAmount);
                    interpolatedBlendOpacity = applyAudioReactivity('blendOpacity', interpolatedBlendOpacity, jiggleEnabledParams, jiggleAmount);
                }
                
                // Apply jiggle if enabled
                if (jiggleEnabled && jiggleAmount > 0) {
                    // Ease bases toward targets so jiggle orbits move smoothly when user edits params
                    const originLerp = 0.1;
                    baseSpikiness += (targetBaseSpikiness - baseSpikiness) * originLerp;
                    baseSpikeFrequency += (targetBaseSpikeFrequency - baseSpikeFrequency) * originLerp;
                    baseSpikeSharpness += (targetBaseSpikeSharpness - baseSpikeSharpness) * originLerp;
                    baseHue += (targetBaseHue - baseHue) * originLerp;
                    baseScale += (targetBaseScale - baseScale) * originLerp;
                    baseFillSize += (targetBaseFillSize - baseFillSize) * originLerp;
                    baseFillOpacity += (targetBaseFillOpacity - baseFillOpacity) * originLerp;
                    baseRotation += (targetBaseRotation - baseRotation) * originLerp;
                    baseHueShiftAmount += (targetBaseHueShiftAmount - baseHueShiftAmount) * originLerp;
                    baseDilationSpeed += (targetBaseDilationSpeed - baseDilationSpeed) * originLerp;
                    baseFadeAmount += (targetBaseFadeAmount - baseFadeAmount) * originLerp;
                    baseEmanationRate += (targetBaseEmanationRate - baseEmanationRate) * originLerp;
                    baseAutoRotationSpeed += (targetBaseAutoRotationSpeed - baseAutoRotationSpeed) * originLerp;
                    baseNoiseAmount += (targetBaseNoiseAmount - baseNoiseAmount) * originLerp;
                    baseNoiseRate += (targetBaseNoiseRate - baseNoiseRate) * originLerp;
                    baseBlurAmount += (targetBaseBlurAmount - baseBlurAmount) * originLerp;
                    baseBlurRate += (targetBaseBlurRate - baseBlurRate) * originLerp;
                    baseBlendOpacity += (targetBaseBlendOpacity - baseBlendOpacity) * originLerp;
                    
                    // Use time-based seed for smooth jiggle
                    const seed = currentTime * 2.0; // Speed of jiggle
                    
                    // Apply random offsets to each parameter based on jiggle amount
                    // Using sin/cos with different frequencies for each parameter for smooth variation
                    // Only apply jiggle if the parameter is enabled in jiggleEnabledParams
                    
                    if (jiggleEnabledParams.spikiness) {
                        spikiness = baseSpikiness + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        spikiness = Math.max(0, Math.min(1, spikiness));
                    }
                    
                    if (jiggleEnabledParams.spikeFrequency) {
                        spikeFrequency = baseSpikeFrequency + (Math.sin(seed * 1.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 9.0; // ±9 range
                        spikeFrequency = Math.max(2, Math.min(20, spikeFrequency));
                    }
                    
                    if (jiggleEnabledParams.spikeSharpness) {
                        spikeSharpness = baseSpikeSharpness + (Math.sin(seed * 1.1) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        spikeSharpness = Math.max(0, Math.min(1, spikeSharpness));
                    }
                    
                    if (jiggleEnabledParams.hue) {
                        hue = baseHue + (Math.sin(seed * 0.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 180.0; // ±180 range
                        hue = ((hue % 360) + 360) % 360; // Wrap around
                    }
                    
                    if (jiggleEnabledParams.scale) {
                        scale = baseScale + (Math.sin(seed * 1.5) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.3; // ±0.3 range
                        scale = Math.max(0.05, Math.min(1.0, scale));
                    }
                    
                    if (jiggleEnabledParams.fillSize) {
                        fillSize = baseFillSize + (Math.sin(seed * 1.2) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        fillSize = Math.max(0, Math.min(1, fillSize));
                    }
                    
                    if (jiggleEnabledParams.fillOpacity) {
                        fillOpacity = baseFillOpacity + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                    }
                    
                    // Manual rotation does not jiggle; keep rotation from user / auto-rotation
                    
                    if (jiggleEnabledParams.hueShiftAmount) {
                        hueShiftAmount = baseHueShiftAmount + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1; // ±0.1 range
                        hueShiftAmount = Math.max(0, Math.min(0.2, hueShiftAmount));
                    }
                    
                    if (jiggleEnabledParams.dilationSpeed) {
                        // Dilation speed: jiggle around base, range ~0.88-1.22, so use ±0.1 range
                        dilationSpeed = baseDilationSpeed + (Math.sin(seed * 0.9) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1;
                        dilationSpeed = Math.max(0.88, Math.min(1.22, dilationSpeed));
                    }
                    
                    if (jiggleEnabledParams.fadeAmount) {
                        // Fade amount: jiggle around base, range 0-5, so use ±1.0 range
                        fadeAmount = baseFadeAmount + (Math.sin(seed * 1.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 1.0;
                        fadeAmount = Math.max(0, Math.min(5.0, fadeAmount));
                    }
                    
                    if (jiggleEnabledParams.emanationRate) {
                        // Emanation rate: jiggle around base, range 2-200, so use ±20 range
                        emanationRate = baseEmanationRate + (Math.sin(seed * 1.0) * 0.5 + 0.5 - 0.5) * jiggleAmount * 20.0;
                        emanationRate = Math.max(2, Math.min(200, emanationRate));
                    }
                    
                    if (jiggleEnabledParams.autoRotationSpeed) {
                        // Auto rotation speed: jiggle around base, range -1 to 360, so use ±30 range
                        autoRotationSpeed = baseAutoRotationSpeed + (Math.sin(seed * 0.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 30.0;
                        autoRotationSpeed = Math.max(-1, Math.min(360, autoRotationSpeed));
                    }
                    
                    if (jiggleEnabledParams.noiseAmount) {
                        // Noise amount: jiggle around base, range 0-1, so use ±0.2 range
                        noiseAmount = baseNoiseAmount + (Math.sin(seed * 1.9) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.2;
                        noiseAmount = Math.max(0, Math.min(1, noiseAmount));
                    }
                    
                    if (jiggleEnabledParams.noiseRate) {
                        // Noise rate: jiggle around base, range 0-10, so use ±2.0 range
                        noiseRate = baseNoiseRate + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount * 2.0;
                        noiseRate = Math.max(0, Math.min(10, noiseRate));
                    }
                    
                    if (jiggleEnabledParams.blurAmount) {
                        // Blur amount: jiggle around base, range 0-1, so use ±0.2 range
                        blurAmount = baseBlurAmount + (Math.sin(seed * 2.0) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.2;
                        blurAmount = Math.max(0, Math.min(1, blurAmount));
                    }
                    
                    if (jiggleEnabledParams.blurRate) {
                        // Blur rate: jiggle around base, range 0-10, so use ±2.0 range
                        blurRate = baseBlurRate + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount * 2.0;
                        blurRate = Math.max(0, Math.min(10, blurRate));
                    }
                    
                    if (jiggleEnabledParams.blendOpacity) {
                        // Blend opacity: jiggle around base, range 0-1, so use ±0.1 range
                        blendOpacity = baseBlendOpacity + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1;
                        blendOpacity = Math.max(0, Math.min(1, blendOpacity));
                    }
                }
                
                // Calculate capture interval from interpolated emanation rate (emanations per second)
                const captureInterval = 1.0 / interpolatedEmanationRate;
                
                // Check if it's time to capture a new shape
                const shouldCaptureShape = (currentTime - lastCaptureTime) >= captureInterval;
                if (shouldCaptureShape) {
                    lastCaptureTime = currentTime;
                }
                
                // Calculate total rotation (interpolated manual + auto) for capturing
                // This ensures captured shapes preserve their rotation at capture time
                const totalRotation = interpolatedRotation + (currentTime * interpolatedAutoRotationSpeed);
                
                // Apply freeze: if frozen, set dilation to 1.0 (no expansion)
                let effectiveDilationSpeed = freezeEnabled ? 1.0 : interpolatedDilationSpeed;
                
                // Apply polarity flip if enabled: reflect dilation speed over 1.0
                // If dilationSpeed < 1.0, flip it to > 1.0 preserving distance from 1.0
                // Example: 0.9 → 1.1 (distance 0.1 preserved), 1.1 → 0.9
                if (dilationPolarityFlip && dilationPolarityFlip.checked && !freezeEnabled) {
                    if (effectiveDilationSpeed < 1.0) {
                        const distance = 1.0 - effectiveDilationSpeed;
                        effectiveDilationSpeed = 1.0 + distance;
                    } else if (effectiveDilationSpeed > 1.0) {
                        const distance = effectiveDilationSpeed - 1.0;
                        effectiveDilationSpeed = 1.0 - distance;
                    }
                }
                
                // Apply polarity flip if enabled: reflect dilation speed over 1.0
                // If dilationSpeed < 1.0, flip it to > 1.0 preserving distance from 1.0
                // Example: 0.9 → 1.1 (distance 0.1 preserved)
                if (dilationPolarityFlip && dilationPolarityFlip.checked && !freezeEnabled) {
                    if (effectiveDilationSpeed < 1.0) {
                        const distance = 1.0 - effectiveDilationSpeed;
                        effectiveDilationSpeed = 1.0 + distance;
                    } else if (effectiveDilationSpeed > 1.0) {
                        const distance = effectiveDilationSpeed - 1.0;
                        effectiveDilationSpeed = 1.0 - distance;
                    }
                }
                
                // Use interpolated values for rendering
                renderer.render({
                    u_time: currentTime,
                    u_spikiness: interpolatedSpikiness,
                    u_spikeFrequency: interpolatedSpikeFrequency,
                    u_spikeSharpness: interpolatedSpikeSharpness,
                    u_hue: interpolatedHue,
                    u_scale: interpolatedScale,
                    u_fillSize: interpolatedFillSize,
                    u_fillOpacity: interpolatedFillOpacity
                }, effectiveDilationSpeed, shouldCaptureShape, interpolatedFadeAmount, interpolatedHueShiftAmount, interpolatedEmanationRate, interpolatedNoiseAmount, interpolatedNoiseRate, interpolatedBlurAmount, interpolatedBlurRate, interpolatedRotation, blendMode, interpolatedBlendOpacity, interpolatedAutoRotationSpeed, totalRotation);
                
                // Update debug output
                updateDebugOutput();
            }
            
            // Use setInterval for fixed 60fps instead of requestAnimationFrame
            setInterval(render, FRAME_TIME);
            render(); // Initial render
            
            // Setup audio controls
            setupAudioControls();
            
            // Initialize audio visualization components
            audioLegend = new MetricLegend();
            audioMeters = new MetricMeters('waveform');
            setupAudioVisualization();
            
            // Generate audio mapping controls UI
            generateAudioMappingControls();
            
            // Hotkey handlers
            let presetNames = [];
            
            // Track last selected menu panel for H key toggle
            let lastSelectedMenuPanel = null; // 'visual', 'mappings', or 'analysis'
            
            // Store reference to original loadPresets before it gets wrapped
            const originalLoadPresetsForHotkeys = loadPresets;
            
            // Update preset names list (use original function to avoid circular reference)
            function updatePresetNames() {
                const presets = originalLoadPresetsForHotkeys();
                presetNames = Object.keys(presets);
            }
            updatePresetNames();
            
            // Setup audio event system (after variables are defined)
            setupAudioEvents();
            
            // Track current preset index
            let currentPresetIndex = -1;
            
            // Find current preset index
            function findCurrentPresetIndex() {
                const currentPreset = presetSelect.value;
                currentPresetIndex = presetNames.indexOf(currentPreset);
                if (currentPresetIndex === -1 && presetNames.length > 0) {
                    currentPresetIndex = 0;
                }
            }
            
            function downloadSnapshot() {
                try {
                    if (!canvas) return;
                    const dataUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    const ts = new Date();
                    const pad = (n) => String(n).padStart(2, '0');
                    const timestamp = `${ts.getFullYear()}-${pad(ts.getMonth() + 1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}`;
                    a.href = dataUrl;
                    a.download = `coherence-sandbox-${timestamp}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } catch (err) {
                    console.error('Snapshot failed', err);
                }
            }

	    function toggleFullScreen() {
		let devtool = document.querySelector('#dev-toolbox');
		let hotleg = document.querySelector('#hotkey-legend');
		let uxToolbox = document.querySelector('#ux-toolbox');

		devtool.hidden = !devtool.hidden;
		hotleg.hidden = !hotleg.hidden;
		if (uxToolbox) uxToolbox.hidden = !uxToolbox.hidden;
	    }
            
            // GIF capture helpers
            function startGifCapture() {
                if (gifRecording) return;
                gifRecording = true;
                gifCaptureFrames = [];
                gifCaptureStart = Date.now();
                
                const maxWidth = 720;
                gifCaptureWidth = Math.min(maxWidth, canvas.width);
                gifCaptureHeight = Math.round(gifCaptureWidth * (canvas.height / canvas.width));
                captureCanvas.width = gifCaptureWidth;
                captureCanvas.height = gifCaptureHeight;
                
                if (recordIndicator) {
                    recordIndicator.style.display = 'inline-block';
                    recordIndicator.textContent = 'RECORD 10.0s';
                    positionStatusIndicators();
                }
                
                const captureFrame = () => {
                    try {
                        captureCtx.clearRect(0, 0, gifCaptureWidth, gifCaptureHeight);
                        captureCtx.drawImage(canvas, 0, 0, gifCaptureWidth, gifCaptureHeight);
                        const frame = captureCtx.getImageData(0, 0, gifCaptureWidth, gifCaptureHeight);
                        gifCaptureFrames.push(frame);
                    } catch (err) {
                        console.error('GIF capture frame failed', err);
                    }
                };
                
                captureFrame();
                
                gifCaptureTimer = setInterval(() => {
                    captureFrame();
                    if (Date.now() - gifCaptureStart >= GIF_MAX_MS) {
                        stopGifCapture(true);
                    }
                }, 1000 / GIF_FPS);
                
                gifCountdownTimer = setInterval(() => {
                    if (!gifRecording) return;
                    const elapsed = Date.now() - gifCaptureStart;
                    const remaining = Math.max(0, GIF_MAX_MS - elapsed);
                    const seconds = (remaining / 1000).toFixed(1);
                    if (recordIndicator) {
                        recordIndicator.textContent = `RECORD ${seconds}s`;
                    }
                }, 100);
            }
            
            function stopGifCapture(autoStop = false) {
                if (!gifRecording) return;
                gifRecording = false;
                if (gifCaptureTimer) {
                    clearInterval(gifCaptureTimer);
                    gifCaptureTimer = null;
                }
                if (gifCountdownTimer) {
                    clearInterval(gifCountdownTimer);
                    gifCountdownTimer = null;
                }
                if (recordIndicator) {
                    recordIndicator.style.display = 'none';
                    recordIndicator.textContent = 'RECORD';
                }
                
                if (gifCaptureFrames.length < 2) {
                    gifCaptureFrames = [];
                    return;
                }
                
                let gif;
                try {
                    gif = new GIF({
                        workers: 2,
                        quality: 10,
                        workerScript: 'vendor/gif.worker.js',
                        width: gifCaptureWidth,
                        height: gifCaptureHeight
                    });
                } catch (err) {
                    console.warn('GIF capture is not supported in this environment.', err);
                    gifCaptureFrames = [];
                    return;
                }
                
                const combinedFrames = gifCaptureFrames.concat(
                    gifCaptureFrames.length > 2 ? gifCaptureFrames.slice(1, -1).reverse() : []
                );
                
                combinedFrames.forEach((frame) => {
                    gif.addFrame(frame, { delay: 1000 / GIF_FPS });
                });
                
                gif.on('finished', (blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const ts = new Date();
                    const pad = (n) => String(n).padStart(2, '0');
                    const timestamp = `${ts.getFullYear()}-${pad(ts.getMonth() + 1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}`;
                    a.href = url;
                    a.download = `coherence-loop-${timestamp}.gif`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
                
                gif.render();
                gifCaptureFrames = [];
            }
            
            // Keyboard event listeners
            document.addEventListener('keydown', (e) => {
                // Ignore hotkeys while typing in text inputs or editable fields
                const active = document.activeElement;
                if (active) {
                    const tag = active.tagName;
                    const type = active.type;
                    const isTextInput = tag === 'INPUT' && type !== 'range' && type !== 'checkbox' && type !== 'radio';
                    const isTextArea = tag === 'TEXTAREA';
                    const isEditable = active.isContentEditable;
                    if (isTextInput || isTextArea || isEditable) {
                        return;
                    }
                }
                
                // Prevent default for our hotkeys (but allow shift for future use)
                if (e.key === ' ' || e.key === 'r' || e.key === 'R' || 
                    e.key === 'j' || e.key === 'J' || e.key === 'Escape' ||
                    e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                    e.key === 'ArrowUp' || e.key === 'ArrowDown' ||
                    e.key === 's' || e.key === 'S' ||
                    e.key === 'g' || e.key === 'G') {
                    e.preventDefault();
                }
                
                // Space: Toggle freeze (set dilation to 1.0 = no expansion)
                if (e.key === ' ') {
                    freezeEnabled = !freezeEnabled;
                    if (freezeEnabled) {
                        // Store original dilation speed
                        originalDilationSpeed = dilationSpeed;
                        dilationSpeed = 1.0; // No dilation when frozen (1.0 = no expansion)
                    } else {
                        // Restore original dilation speed
                        dilationSpeed = originalDilationSpeed;
                    }
                    updateStatusIndicators();
                }
                
                // R: Randomize
                if (e.key === 'r' || e.key === 'R') {
                    randomizeAll();
                }
                
                // S: Snapshot PNG
                if (e.key === 's' || e.key === 'S') {
                    downloadSnapshot();
                }

                // V: Toggle visual menu (dev-toolbox, hotkey-legend, ux-toolbox)
                if (e.key === 'v' || e.key === 'V') {
                    e.preventDefault();
                    toggleFullScreen();
                    lastSelectedMenuPanel = 'visual';
                }
                
                // M: Toggle audio mappings panel
                if (e.key === 'm' || e.key === 'M') {
                    e.preventDefault();
                    const mappingsPanel = document.getElementById('audio-mappings-panel');
                    const devToolbox = document.getElementById('dev-toolbox');
                    
                    if (mappingsPanel) {
                        const isVisible = mappingsPanel.style.display !== 'none';
                        mappingsPanel.style.display = isVisible ? 'none' : 'block';
                        
                        // Position below dev-toolbox if it's visible
                        if (!isVisible && devToolbox && !devToolbox.hidden) {
                            const devRect = devToolbox.getBoundingClientRect();
                            mappingsPanel.style.top = (devRect.bottom + 10) + 'px';
                            mappingsPanel.style.right = '10px';
                        } else if (!isVisible) {
                            mappingsPanel.style.top = '10px';
                            mappingsPanel.style.right = '10px';
                        }
                    }
                    lastSelectedMenuPanel = 'mappings';
                }
                
                // A: Toggle audio analysis visualization panel
                if (e.key === 'a' || e.key === 'A') {
                    e.preventDefault();
                    const visualizationPanel = document.getElementById('audio-visualization-panel');
                    if (visualizationPanel) {
                        const isVisible = visualizationPanel.style.display !== 'none';
                        visualizationPanel.style.display = isVisible ? 'none' : 'block';
                    }
                    lastSelectedMenuPanel = 'analysis';
                }
                
                // H: Toggle last selected menu panel
                if (e.key === 'h' || e.key === 'H') {
                    e.preventDefault();
                    
                    if (!lastSelectedMenuPanel) {
                        // If no panel was selected yet, default to visual menu
                        toggleFullScreen();
                        lastSelectedMenuPanel = 'visual';
                        return;
                    }
                    
                    if (lastSelectedMenuPanel === 'visual') {
                        toggleFullScreen();
                    } else if (lastSelectedMenuPanel === 'mappings') {
                        const mappingsPanel = document.getElementById('audio-mappings-panel');
                        const devToolbox = document.getElementById('dev-toolbox');
                        
                        if (mappingsPanel) {
                            const isVisible = mappingsPanel.style.display !== 'none';
                            mappingsPanel.style.display = isVisible ? 'none' : 'block';
                            
                            if (!isVisible && devToolbox && !devToolbox.hidden) {
                                const devRect = devToolbox.getBoundingClientRect();
                                mappingsPanel.style.top = (devRect.bottom + 10) + 'px';
                                mappingsPanel.style.right = '10px';
                            } else if (!isVisible) {
                                mappingsPanel.style.top = '10px';
                                mappingsPanel.style.right = '10px';
                            }
                        }
                    } else if (lastSelectedMenuPanel === 'analysis') {
                        const visualizationPanel = document.getElementById('audio-visualization-panel');
                        if (visualizationPanel) {
                            const isVisible = visualizationPanel.style.display !== 'none';
                            visualizationPanel.style.display = isVisible ? 'none' : 'block';
                        }
                    }
                }
                
                // G: Toggle GIF recording (max 10s, forward + reverse loop)
                if (e.key === 'g' || e.key === 'G') {
                    if (gifRecording) {
                        stopGifCapture(false);
                    } else {
                        startGifCapture();
                    }
                }
                
                // 1: Toggle interpolation
                if (e.key === '1') {
                    if (interpolationEnabled) {
                        interpolationEnabled.checked = !interpolationEnabled.checked;
                        interpolator.setEnabled(interpolationEnabled.checked);
                    }
                }

                
                // Left/Right arrows: Cycle presets
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    if (presetNames.length === 0) {
                        updatePresetNames();
                    }
                    if (presetNames.length === 0) return;
                    
                    // Find current preset index
                    const currentPreset = presetSelect.value;
                    let currentIndex = presetNames.indexOf(currentPreset);
                    if (currentIndex === -1) currentIndex = 0;
                    
                    // Cycle
                    if (e.key === 'ArrowLeft') {
                        currentIndex = (currentIndex - 1 + presetNames.length) % presetNames.length;
                    } else {
                        currentIndex = (currentIndex + 1) % presetNames.length;
                    }
                    
                    // Load the preset
                    const presetName = presetNames[currentIndex];
                    presetSelect.value = presetName;
                    loadPreset(presetName);
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                }
                
                // Up arrow: accelerate auto params (rotation, hue shift, dilation)
                if (e.key === 'ArrowUp') {
                    // Get current values from interpolator
                    const currentAutoRotation = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                    const currentHueShift = interpolator.getCurrent('hueShiftAmount') ?? hueShiftAmount;
                    const currentDilation = interpolator.getCurrent('dilationSpeed') ?? dilationSpeed;
                    
                    // Increase auto rotation speed (up to a max) - slower step
                    const newAutoRotation = Math.min(360.0, currentAutoRotation + 0.5);
                    interpolator.setTarget('autoRotationSpeed', newAutoRotation);
                    autoRotationSpeed = newAutoRotation; // Update direct value for slider sync
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (newAutoRotation + 1) / 361.0)), 2));
                    autoRotationValue.textContent = newAutoRotation.toFixed(1) + '°';
                    
                    // Increase hue shift amount (up to max 0.2) - slower step
                    const newHueShift = Math.min(0.2, currentHueShift + 0.0002);
                    interpolator.setTarget('hueShiftAmount', newHueShift);
                    hueShiftAmount = newHueShift;
                    hueShiftSlider.value = newHueShift.toFixed(3);
                    hueShiftValue.textContent = newHueShift.toFixed(3);
                    
                    // Push dilation further away from 1.0 - slower step
                    const delta = currentDilation >= 1.0 ? 0.001 : -0.001;
                    const newDilation = Math.max(0.88, Math.min(1.22, currentDilation + delta));
                    interpolator.setTarget('dilationSpeed', newDilation);
                    dilationSpeed = newDilation;
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(newDilation);
                    dilationValue.textContent = newDilation.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // Down arrow: decelerate auto params towards neutral
                if (e.key === 'ArrowDown') {
                    // Get current values from interpolator
                    const currentAutoRotation = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                    const currentHueShift = interpolator.getCurrent('hueShiftAmount') ?? hueShiftAmount;
                    const currentDilation = interpolator.getCurrent('dilationSpeed') ?? dilationSpeed;
                    
                    // Gently damp auto rotation towards 0 - slower step
                    const newAutoRotation = currentAutoRotation * 0.98;
                    interpolator.setTarget('autoRotationSpeed', newAutoRotation);
                    autoRotationSpeed = newAutoRotation;
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (newAutoRotation + 1) / 361.0)), 2));
                    autoRotationValue.textContent = newAutoRotation.toFixed(1) + '°';
                    
                    // Gently damp hue shift towards 0 - slower step
                    const newHueShift = currentHueShift * 0.98;
                    interpolator.setTarget('hueShiftAmount', newHueShift);
                    hueShiftAmount = newHueShift;
                    hueShiftSlider.value = newHueShift.toFixed(3);
                    hueShiftValue.textContent = newHueShift.toFixed(3);
                    
                    // Bring dilation towards 1.0 (never snapping) - slower easing
                    const newDilation = currentDilation + (1.0 - currentDilation) * 0.02;
                    interpolator.setTarget('dilationSpeed', newDilation);
                    dilationSpeed = newDilation;
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(newDilation);
                    dilationValue.textContent = newDilation.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // J: Toggle jiggle
                if (e.key === 'j' || e.key === 'J') {
                    jiggleBtn.click();
                }
                
                // Esc: Clear screen
                if (e.key === 'Escape') {
                    // Clear both framebuffers
                    const gl = renderer.gl;
                    
                    // Clear history framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.historyFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Clear current framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.currentFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
            });
            
            // Note: We don't wrap loadPresets here because updatePresetNames
            // already calls the original function directly to avoid circular references.
            // If you need to update preset names after loading, call updatePresetNames() explicitly.
        })();
    </script>



<div id="my-app"></div><div id="torrent-scanner-popup" style="display: none;"><template shadowrootmode="open"><link rel="stylesheet" href="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/css/custom.css"><div id="yf-bt-wrapper" class="free"><div class="header"><img class="sts-logo" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/ts-free-logo.png"><div class="search-content"><input id="search-input" class="search-input" type="search" placeholder="Start your search here..."><span id="search-btn" class="search-btn"></span></div></div><div class="container"><div class="main-container"><div id="torrent-data" class="torrent-content"><div class="t-table"><div class="t-header"><div class="t-name">Torrent search results</div></div><div id="checked-sites" class="checked-sites-section"><div class="left">Checked Sites</div><div class="right"><span id="sites-count" class="sites-count">0</span></div></div><div id="table-body" class="t-body"><div id="loading" class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div><div class="table-message-container" id="table-message"><p>No items to list <br> Use the search bar above for instant results</p></div></div></div></div><div class="tooltip"><p class="tooltip-text">To see search results, type here and hit `Enter`</p></div><div class="footer"><span><span id="numberScanned" class="numberScanned">No results</span></span></div><div class="upgradeProPanel"><div class="upgradeProPanelTitle">Try our Torrent Scanner Plus to unlock:</div><div class="upgradeProPanelList"><div><p>Faster Results</p></div><div><p>Unlimited Search Results with detailed torrent info</p></div><div><p>Secure Torrenting</p></div></div><a class="upgrade-to-pro-button-2" id="buy-pro" href="https://shop.lavasoft.com/clickgate/join.aspx?ref=shop.lavasoft.com&amp;ujid=W9yhyAwEW5Q%3D" target="_blank">Get Torrent Scanner +</a></div></div><div class="sync-container nav-se-container"><div class="nav-se-content"><img class="sync-icon nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-sync.svg"><div class="nav-se-title">One more step to go before you start torrenting!</div><p class="nav-se-text">This extension can sync results with BitTorrent and/or uTorrent for instant downloading.</p><p class="nav-se-text">To activate this feature, please click on the button below, and then on the Chrome message to activate the 'Messaging Permission'.</p><button class="sync-permission-btn nav-se-btn">Activate Messaging Permission</button></div><div class="nav-se-content display-none"><img class="sync-icon nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-sync.svg"><div class="nav-se-title">Syncing...</div><p class="nav-se-text">Please allow Messaging Permissions in the proceeding Chrome message.</p></div><div class="nav-se-content display-none"><img class="sync-icon nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-success.svg"><div class="nav-se-title">Sync Complete</div><p class="nav-se-text">You have successfully activated the “Messaging Permission” feature. All your search results will sync with BitTorrent and/or uTorrent.</p></div></div><div class="license-container nav-se-container"><div class="nav-se-content"><img class="nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-key2.svg"><div class="nav-se-title">Enter License Key</div><p class="nav-se-text">Enter your license key and click on the activate button to start using <span>Torrent Scanner Plus.</span></p><input type="text" id="license-input-key" class="license-input-key" placeholder="Enter Key"><div class="license-spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div><button id="license-activate-button" class="license-activate-button nav-se-btn">Activate</button><p>Don't have a license key? <a class="license-buy-link" target="_blank">Click here</a></p></div><div class="nav-se-content display-none"><img class="nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-success.svg"><div class="nav-se-title">Happy Torrenting!</div><p class="nav-se-text">You are now an active PRO user</p><p class="nav-se-text">Your key is valid until <span class="expiry-date"></span></p></div><div class="nav-se-content display-none"><img class="nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-alert.svg"><div class="nav-se-title">Your license key has expired</div><p class="nav-se-text">Looks like your license key has expired, to renew your PRO license key, please select a license type:</p><a class="upgrade-to-pro-button-2 buy-license-expiry-button" href="https://shop.lavasoft.com/clickgate/join.aspx?ref=shop.lavasoft.com&amp;ujid=W9yhyAwEW5Q%3D" target="_blank">Buy Torrent Scanner +</a><p class="nav-se-text">Already have a license key? <a class="link" id="show-license-panel">Click here</a></p></div><div class="nav-se-content display-none"><img class="nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-success.svg"><p class="nav-se-text">Your key is valid until <span class="expiry-date"></span></p><p class="nav-se-text">Your License Key:</p><p class="nav-se-text"></p><p class="nav-se-text margin-top-50">Switch back to Torrent Scanner Free?</p><button class="activate-free-btn nav-se-btn">Revert to Free Version</button></div></div><div class="feedback-container nav-se-container"><div class="nav-se-content"><img class="nav-se-icon" src="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/img/assets/icon-feedback.svg"><div class="nav-se-title">Feedback</div><p class="nav-se-text">Help us improve Torrent Scanner, send us comments, bugs, feedback, and suggestions.</p><button id="feedback-button" class="feedback-button nav-se-btn">Send Feedback</button></div></div><div class="settings-container nav-se-container"><div class="nav-se-content"><div class="settings-title">Settings</div></div><div class="s-table"><div class="s-row"><div class="s-title">FAQ<div class="s-arrow"><span class="arrow-down"></span></div></div><div class="s-content faq-content"><p class="faq-text">FAQ: <a href="chrome-extension://aegnopegbbhjeeiganiajffnalhlkkjb/faq.html" target="_blank">Click here</a></p></div></div><div class="s-row"><div class="s-title">Rate the extension<div class="s-arrow"><span class="arrow-down"></span></div></div><div class="s-content"><p class="rate-text">How did you like the extension experience?</p><div class="rating"><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span><span class="rating-star">★</span></div><button class="rating-btn nav-se-btn" disabled="">Submit</button></div></div><div class="s-row"><div class="s-title">About<div class="s-arrow"><span class="arrow-down"></span></div></div><div class="s-content about-content"><div class="about-version">Version 1.4.0 <br><br> What's New</div><div class="about-new"><p></p><ul><li>Experience a complete new User Interface of the extension. It is enhanced and user friendly now.</li><li>Squashed some bugs.</li></ul><p></p></div></div></div><div class="s-row"><div class="s-title">Privacy Policy<div class="s-arrow"><span class="arrow-down"></span></div></div><div class="s-content"><div class="policy-text">Adaware Software (7270356 Canada Inc.) is the operator of the Adaware products suites and related services (the “<b>Company</b>”, ”<b>we</b>” or “<b>us</b>”). We respect your privacy rights and we are committed to protecting them. This privacy policy (“<b>Privacy Policy</b>” or simply “<b>policy</b>”) governs our products, services and websites that link to this Privacy Policy, and describes our practices of processing data from you. By “<b>you</b>”, we refer to either or all of the following: (i) visitors to our websites that links to this Privacy Policy (“<b>Visitor</b>” and “<b>Website</b>”, respectively); (ii) our customers using our software products and Services (“<b>User</b>”); and (c) a business customer, a business partner that has a contractual relationship with us or a prospective customer that is yet to be engaged in a contract with us (“Business Customer”). Unless explicitly mentioned otherwise, the information in this Privacy Policy refers to any and all data subject types (“you” or “your’). <br><br> For the purpose of this policy, the “<b>Service(s)</b>” shall include any software licensed by the Company, including features offered by or within the installed software or additional software scripts available therein (either downloaded from one of our websites, pre-installed on your device, downloaded through a third party website, obtained on a physical medium, or otherwise), or services provided through and/or on top such software, services offered on our websites, communication forums, support services, account operation, updates, enhancements, new features, premium support, extended guarantees, online version and free versions of a software or additional services or features as we ay make available from time to time. <br><br> If you are a California resident, please also see our <a href="https://www.adaware.com/CCPA/" target="_blank">CCPA Notice</a>. <br><br> <a href="https://www.adaware.com/privacy-policy/" target="_blank">Read more</a></div></div></div><div class="s-row" style="display: none;"><div class="s-title">Contact Us<div class="s-arrow"><span class="arrow-down"></span></div></div><div class="s-content"><div class="contact-text">For any payment and order-related support, please contact us at Email: <a href="mailto:support@torrentscanner.zendesk.com">support@torrentscanner.zendesk.com</a> or <a href="mailto:pcsoftwareinfo.com">pcsoftwareinfo.com</a><br><br>Phone: <a href="https://pcsoftwareinfo.com/contact.aspx" target="_blank">Click here</a></div></div></div></div></div></div><div class="nav"><button id="btnSync" class="nav-btn">Sync</button><button id="btnLicense" class="nav-btn">License</button><button id="btnHome" class="nav-btn">Home</button><button id="btnFeedback" class="nav-btn">Feedback</button><button id="btnSettings" class="nav-btn">Settings</button></div></div></template></div></body></html>