<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lucas - Audio Reactive Visualizer</title>
    <link rel="stylesheet" href="styles/main.css">
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Curve Editor Overlay -->
    <div id="curve-editor-overlay" class="curve-editor-overlay">
        <div class="curve-editor">
            <div class="curve-editor-header">
                <div class="curve-editor-title" id="curve-editor-title">Parameter Curve Editor</div>
                <button class="curve-editor-close" id="curve-editor-close">&times;</button>
            </div>
            <div class="curve-canvas-container">
                <canvas id="curve-canvas" class="curve-canvas"></canvas>
            </div>
            <div class="curve-controls">
                <div class="curve-control-group">
                    <label>Min Value</label>
                    <input type="number" id="curve-min" step="any" value="0">
                </div>
                <div class="curve-control-group">
                    <label>Max Value</label>
                    <input type="number" id="curve-max" step="any" value="1">
                </div>
            </div>
            <div class="curve-power-slider">
                <label>Curve Power (exponent): <span id="curve-power-value">1.0</span></label>
                <input type="range" id="curve-power" min="0.1" max="5" step="0.1" value="1.0">
            </div>
            <div class="curve-actions">
                <button class="curve-btn-action" id="curve-reset">Reset</button>
                <button class="curve-btn-action" id="curve-apply">Apply</button>
                <button class="curve-btn-action curve-btn-primary" id="curve-close">Done</button>
            </div>
        </div>
    </div>

    <!-- Shaders loaded from external files in shaders/ directory -->
    <script src="vendor/gif.js"></script>
    
    <div id="hotkey-legend">
        <h4>Hotkeys</h4>
        <div class="hotkey-item">
            <span class="hotkey-key">Space</span>
            <span class="hotkey-desc">Toggle Freeze</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">R</span>
            <span class="hotkey-desc">Randomize</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">← →</span>
            <span class="hotkey-desc">Cycle Presets</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">J</span>
            <span class="hotkey-desc">Toggle Jiggle</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">Esc</span>
            <span class="hotkey-desc">Clear Screen</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↑</span>
            <span class="hotkey-desc">Accelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↓</span>
            <span class="hotkey-desc">Decelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">S</span>
            <span class="hotkey-desc">Snapshot (PNG)</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">G</span>
            <span class="hotkey-desc">Record GIF (max 10s)</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">1</span>
            <span class="hotkey-desc">Toggle Interpolation</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">H</span>
            <span class="hotkey-desc">Toggle UI</span>
        </div>
    </div>
    
    <div id="status-indicators">
        <span id="freeze-indicator" style="display: none; background: #0af; color: #fff;">FREEZE</span>
        <span id="jiggle-indicator" style="display: none; background: #a0a; color: #fff;">JIGGLE</span>
        <span id="unsaved-indicator" style="display: none; background: #fa0; color: #fff;">UNSAVED</span>
        <span id="record-indicator" style="display: none; background: #e33; color: #fff;">RECORD</span>
    </div>
    
    <div id="ux-toolbox">
        <h4>Experimental</h4>
        
        <div class="section-header collapsed" id="interpolation-settings-header" style="margin-top: 0; margin-bottom: 6px; padding-top: 8px; border-top: 1px solid #333; cursor: pointer;">
            <span>Smooth Interpolation</span>
        </div>
        <div id="interpolation-settings-content" style="display: none; padding-left: 8px;">
            <div class="control-group">
                <label>
                    <input type="checkbox" id="interpolation-enabled" checked>
                    <span style="margin-left: 6px;">Enabled</span>
                </label>
            </div>
            
            <div class="control-group">
                <label for="interpolation-duration-slider">Duration (s)</label>
                <div class="control-row">
                    <input type="range" id="interpolation-duration-slider" min="0.05" max="2.0" value="0.5" step="0.05">
                    <div class="value" contenteditable="true" id="interpolation-duration-value">0.50</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="interpolation-easing-select">Easing Type</label>
                <select id="interpolation-easing-select" style="width: 100%; font-size: 9px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                    <option value="linear">Linear</option>
                    <option value="easeInOut" selected>Ease In-Out</option>
                    <option value="easeIn">Ease In</option>
                    <option value="easeOut">Ease Out</option>
                    <option value="spring">Spring</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="interpolation-spring-slider">Spring Constant</label>
                <div class="control-row">
                    <input type="range" id="interpolation-spring-slider" min="0.01" max="0.5" value="0.1" step="0.01">
                    <div class="value" contenteditable="true" id="interpolation-spring-value">0.10</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="interpolation-damping-slider">Damping</label>
                <div class="control-row">
                    <input type="range" id="interpolation-damping-slider" min="0.5" max="0.99" value="0.8" step="0.01">
                    <div class="value" contenteditable="true" id="interpolation-damping-value">0.80</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>
                    <input type="checkbox" id="interpolation-rotation-spring" checked>
                    <span style="margin-left: 6px;">Use Spring for Rotation</span>
                </label>
            </div>
        </div>
    </div>
    
    <div id="audio-mapping-panel">
        <h4>Audio Mapping</h4>
        
        <!-- Audio Input Controls -->
        <div id="audio-controls" style="background: rgba(20, 20, 20, 0.5); border: 1px solid #444; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
            <h4 style="margin: 0 0 6px 0; font-size: 9px; color: #aaa; text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600; border-bottom: 1px solid #333; padding-bottom: 4px;">Audio Input</h4>
            <select id="audio-device-select" style="width: 100%; font-size: 9px; padding: 3px; margin-bottom: 4px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="">Loading devices...</option>
            </select>
            <button id="enable-audio-btn" style="width: 100%; font-size: 9px; padding: 4px; margin-bottom: 4px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Enable Mic/Device</button>
            <button id="capture-tab-btn" style="width: 100%; font-size: 9px; padding: 4px; margin-bottom: 4px; background: #a0f; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Capture Tab Audio</button>
            <div id="audio-status" style="font-size: 8px; color: #888; margin-bottom: 4px;">Audio: Disabled</div>
            <div class="audio-reactive-toggle" style="display: flex; align-items: center; gap: 6px; margin-top: 4px;">
                <input type="checkbox" id="audio-reactive-enabled" checked style="cursor: pointer;">
                <label for="audio-reactive-enabled" style="font-size: 9px; color: #bbb; cursor: pointer; margin: 0;">Audio Reactive Mode</label>
            </div>
        </div>
        
        <!-- Audio Metrics Visualization -->
        <div id="audio-metrics-visualization">
            <h5>Audio Metrics Analysis</h5>
            <table class="metrics-table" id="metrics-table">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Current</th>
                        <th>Normalized</th>
                        <th>Min</th>
                        <th>Max</th>
                        <th>Avg</th>
                        <th>Range</th>
                        <th>Mapped To</th>
                    </tr>
                </thead>
                <tbody id="metrics-table-body">
                    <!-- Will be populated dynamically -->
                </tbody>
            </table>
        </div>
        
        <div id="audio-mapping-content">
            <!-- Search and Controls -->
            <div style="margin-bottom: 10px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                <div style="display: flex; gap: 6px; margin-bottom: 6px;">
                    <input type="text" id="mapping-search" placeholder="Search parameters..." 
                           style="flex: 1; font-size: 9px; padding: 4px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                    <button id="mapping-collapse-all" style="font-size: 9px; padding: 4px 8px; background: #444; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Collapse All</button>
                    <button id="mapping-expand-all" style="font-size: 9px; padding: 4px 8px; background: #444; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Expand All</button>
                </div>
                <div style="font-size: 8px; color: #888; margin-top: 6px; padding-top: 6px; border-top: 1px solid #333;">
                    <strong>Unmapped Audio Metrics:</strong> lowImbalance, stereoWidth (low/mid/high), panPosition (low/mid/high), spatialDepth (low/mid/high)
                </div>
            </div>
            <!-- Audio mapping controls will be generated dynamically -->
        </div>
    </div>
    
    <div id="dev-toolbox">
        <h3>Controls</h3>
        
        <div class="control-group">
            <label for="preset-select">Preset</label>
            <select id="preset-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="">-- Select --</option>
            </select>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <input type="text" id="preset-name-input" placeholder="Name" style="flex: 1; font-size: 10px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <button id="save-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                <button id="delete-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #a00; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Del</button>
            </div>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <button id="export-presets-btn" style="font-size: 10px; padding: 3px 6px; background: #0a0; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Export</button>
                <label for="import-presets-input" style="font-size: 10px; padding: 3px 6px; background: #fa0; color: #fff; border: none; border-radius: 3px; cursor: pointer; display: inline-block; height: auto; line-height: normal; box-sizing: border-box;">Import</label>
                <input type="file" id="import-presets-input" accept=".json,.txt" style="display: none;">
            </div>
        </div>
        
        <div class="section-header">Resolution</div>
        <div class="control-group">
            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                <button id="res-4k-btn" class="resolution-btn" data-resolution="4k" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">4K UHD</button>
                <button id="res-pc-btn" class="resolution-btn" data-resolution="pc" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Full HD</button>
                <button id="res-mobile-btn" class="resolution-btn" data-resolution="mobile" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Mobile</button>
                <button id="res-window-btn" class="resolution-btn" data-resolution="window" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Window</button>
            </div>
            <div id="current-resolution-display" style="margin-top: 4px; font-size: 9px; color: #aaa;">Current: Window Size</div>
        </div>
        
        <div class="section-header">Shape</div>
        <div class="control-group">
            <label for="spikiness-slider">Spikiness<span class="curve-btn" data-param="spikiness" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spikiness-slider" min="0" max="100" value="50" step="1">
                <div class="value" contenteditable="true" id="spikiness-value">0.50</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-frequency-slider">Frequency<span class="curve-btn" data-param="spikeFrequency" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spike-frequency-slider" min="2" max="20" value="5" step="0.1">
                <div class="value" contenteditable="true" id="spike-frequency-value">5.0</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-sharpness-slider">Sharpness<span class="curve-btn" data-param="spikeSharpness" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spike-sharpness-slider" min="0" max="100" value="0" step="1">
                <div class="value" contenteditable="true" id="spike-sharpness-value">0.00</div>
            </div>
        </div>
        
        <div class="section-header">Appearance</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-slider">Hue<span class="curve-btn" data-param="hue" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="hue-slider" min="0" max="360" value="45" step="1">
                    <div class="value" contenteditable="true" id="hue-value">45°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="scale-slider">Scale<span class="curve-btn" data-param="scale" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="scale-slider" min="0.05" max="1.0" value="0.2" step="0.01">
                    <div class="value" contenteditable="true" id="scale-value">0.20</div>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="control-group">
                <label for="fill-size-slider">Fill Size<span class="curve-btn" data-param="fillSize" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="fill-size-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="fill-size-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="fill-opacity-slider">Fill Opacity<span class="curve-btn" data-param="fillOpacity" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="fill-opacity-slider" min="0" max="100" value="60" step="1">
                    <div class="value" contenteditable="true" id="fill-opacity-value">0.60</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Emanation</div>
        <div class="control-group">
            <label for="dilation-slider">Dilation Speed<span class="curve-btn" data-param="dilationSpeed" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="dilation-slider" min="0" max="200" value="20" step="1">
                <div class="value" contenteditable="true" id="dilation-value">1.01</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="fade-slider">Fade Amount<span class="curve-btn" data-param="fadeAmount" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="fade-slider" min="0" max="100" value="30" step="1">
                <div class="value" contenteditable="true" id="fade-value">0.30</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="emanation-rate-slider">Rate (per sec)<span class="curve-btn" data-param="emanationRate" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="emanation-rate-slider" min="2" max="200" value="2" step="0.1">
                <div class="value" contenteditable="true" id="emanation-rate-value">2.0</div>
            </div>
        </div>
        
        <div class="section-header">Filters</div>
        <div class="two-column">
            <div class="control-group">
                <label for="noise-amount-slider">Noise Amount<span class="curve-btn" data-param="noiseAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="noise-amount-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="noise-amount-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="noise-rate-slider">Noise Rate (1.0 = every 2s)<span class="curve-btn" data-param="noiseRate" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="noise-rate-slider" min="0" max="100" value="0" step="0.1">
                    <div class="value" contenteditable="true" id="noise-rate-value">0.0</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blur-amount-slider">Blur Amount<span class="curve-btn" data-param="blurAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blur-amount-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="blur-amount-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blur-rate-slider">Blur Rate (1.0 = every 2s)<span class="curve-btn" data-param="blurRate" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blur-rate-slider" min="0" max="100" value="0" step="0.1">
                    <div class="value" contenteditable="true" id="blur-rate-value">0.0</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Rotation</div>
        <div class="two-column">
            <div class="control-group">
                <label for="rotation-slider">Manual<span class="curve-btn" data-param="rotation" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="rotation-slider" min="0" max="360" value="0" step="1">
                    <div class="value" contenteditable="true" id="rotation-value">0°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="auto-rotation-slider">Auto (deg/s)<span class="curve-btn" data-param="autoRotationSpeed" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="auto-rotation-slider" min="0" max="200" value="50" step="1">
                    <div class="value" contenteditable="true" id="auto-rotation-value">30°</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Effects</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-shift-slider">Hue Shift<span class="curve-btn" data-param="hueShiftAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="hue-shift-slider" min="0.0" max="0.2" value="0.05" step="0.001">
                    <div class="value" contenteditable="true" id="hue-shift-value">0.050</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blend-opacity-slider">Opacity<span class="curve-btn" data-param="blendOpacity" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blend-opacity-slider" min="0.0" max="1.0" value="0.3" step="0.01">
                    <div class="value" contenteditable="true" id="blend-opacity-value">0.30</div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="blend-mode-select">Blend Mode</label>
            <select id="blend-mode-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="additive">Additive</option>
                <option value="alpha" selected>Alpha Blend</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
            </select>
        </div>
        
        <div class="section-header">Actions</div>
        <div class="control-group">
            <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                <button id="randomize-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Randomize</button>
                <button id="jiggle-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #a0a; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Jiggle</button>
            </div>
            <label for="jiggle-amount-slider">Jiggle Amount<span class="curve-btn" data-param="jiggleAmount" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="jiggle-amount-slider" min="0" max="100" value="10" step="1">
                <div class="value" contenteditable="true" id="jiggle-amount-value">10%</div>
            </div>
            
            <div class="section-header collapsed" id="jiggle-settings-header" style="margin-top: 8px; margin-bottom: 6px; padding-top: 8px; border-top: 1px solid #333; cursor: pointer;">
                <span>Jiggle Settings</span>
            </div>
            <div id="jiggle-settings-content" style="display: none; padding-left: 8px;">
                <div style="display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap;">
                    <button id="jiggle-all-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">All</button>
                    <button id="jiggle-none-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">None</button>
                    <button id="jiggle-shape-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Shape</button>
                    <button id="jiggle-appearance-btn" style="font-size: 9px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Appearance</button>
                </div>
                <div style="font-size: 9px; color: #888; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Shape</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-spikiness" checked>
                    <span>Spikiness</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-spikeFrequency" checked>
                    <span>Frequency</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-spikeSharpness" checked>
                    <span>Sharpness</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Appearance</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-hue" checked>
                    <span>Hue</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-scale" checked>
                    <span>Scale</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-fillSize" checked>
                    <span>Fill Size</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-fillOpacity" checked>
                    <span>Fill Opacity</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Emanation</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-dilationSpeed" checked>
                    <span>Dilation Speed</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-fadeAmount" checked>
                    <span>Fade Amount</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-emanationRate" checked>
                    <span>Rate</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Filters</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-noiseAmount" checked>
                    <span>Noise Amount</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-noiseRate" checked>
                    <span>Noise Rate</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-blurAmount" checked>
                    <span>Blur Amount</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-blurRate" checked>
                    <span>Blur Rate</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Rotation</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-autoRotationSpeed" checked>
                    <span>Auto Rotation</span>
                </label>
                
                <div style="font-size: 9px; color: #888; margin-top: 8px; margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Effects</div>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-hueShiftAmount" checked>
                    <span>Hue Shift</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; font-size: 9px; margin-bottom: 4px; cursor: pointer;">
                    <input type="checkbox" id="jiggle-param-blendOpacity" checked>
                    <span>Blend Opacity</span>
                </label>
            </div>
        </div>
        
        <div class="section-header collapsed" id="debug-values-header" style="margin-top: 8px; margin-bottom: 6px; padding-top: 8px; border-top: 1px solid #333; cursor: pointer;">
            <span>Debug Values</span>
        </div>
        <div id="debug-values-content" style="display: none; padding-left: 8px;">
            <div id="debug-output" style="font-size: 8px; font-family: monospace; color: #aaa; line-height: 1.4; max-height: 400px; overflow-y: auto; background: #1a1a1a; padding: 6px; border-radius: 3px; border: 1px solid #333; white-space: pre-wrap;">
                <!-- Debug values will be populated here -->
            </div>
        </div>
    </div>
    
    <script src="audio/analyzer.js" id="analyzer-script"></script>
    <script>
        // Resolution configuration
        const RESOLUTIONS = {
            '4k': { width: 3840, height: 2160, name: '4K UHD' },
            'pc': { width: 1920, height: 1080, name: 'Full HD' },
            'mobile': { width: 1080, height: 1920, name: 'Mobile' },
            'window': { width: null, height: null, name: 'Window Size' }
        };
        
        // Parse URL parameters
        function getUrlParam(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        // Get current resolution setting
        let currentResolution = getUrlParam('resolution') || 'window';
        if (!RESOLUTIONS[currentResolution]) {
            currentResolution = 'window';
        }
        
        // Simple WebGL renderer
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.program = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                const res = RESOLUTIONS[currentResolution];
                if (res.width && res.height) {
                    // Fixed resolution
                    this.canvas.width = res.width;
                    this.canvas.height = res.height;
                } else {
                    // Window size
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Resize textures if they exist
                if (this.historyTexture && this.currentTexture) {
                    this.setupFramebuffers();
                }
            }
            
            setupFramebuffers() {
                const gl = this.gl;
                
                // Create or recreate history texture
                if (this.historyTexture) {
                    gl.deleteTexture(this.historyTexture);
                }
                if (this.historyFramebuffer) {
                    gl.deleteFramebuffer(this.historyFramebuffer);
                }
                
                this.historyTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.historyFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.historyTexture, 0);
                
                // Create or recreate current texture
                if (this.currentTexture) {
                    gl.deleteTexture(this.currentTexture);
                }
                if (this.currentFramebuffer) {
                    gl.deleteFramebuffer(this.currentFramebuffer);
                }
                
                this.currentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.currentFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.currentTexture, 0);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const info = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${info}`);
                }
                
                return shader;
            }
            
            init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource) {
                const gl = this.gl;
                
                // Compile shape shader
                const vertexShader = this.compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.program);
                    throw new Error(`Program linking error: ${info}`);
                }
                
                // Compile dilation shader
                const dilationVertexShader = this.compileShader(dilationVertexSource, gl.VERTEX_SHADER);
                const dilationFragmentShader = this.compileShader(dilationFragmentSource, gl.FRAGMENT_SHADER);
                this.dilationProgram = gl.createProgram();
                gl.attachShader(this.dilationProgram, dilationVertexShader);
                gl.attachShader(this.dilationProgram, dilationFragmentShader);
                gl.linkProgram(this.dilationProgram);
                
                if (!gl.getProgramParameter(this.dilationProgram, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.dilationProgram);
                    throw new Error(`Dilation program linking error: ${info}`);
                }
                
                // Setup full-screen quad (shared buffer)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1
                ]);
                
                this.quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Setup position attribute for shape program
                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup position attribute for dilation program
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup framebuffers
                this.setupFramebuffers();
                
                // Clear history texture to black
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                gl.useProgram(this.program);
            }
            
            setUniform(name, value, program = null) {
                const gl = this.gl;
                const targetProgram = program || this.program;
                const location = gl.getUniformLocation(targetProgram, name);
                
                if (location === null) return;
                
                if (typeof value === 'number') {
                    gl.uniform1f(location, value);
                } else if (Array.isArray(value)) {
                    if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    } else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                }
            }
            
            setBlendMode(mode, opacity) {
                const gl = this.gl;
                
                switch(mode) {
                    case 'additive':
                        // Additive: src + dst (bright, accumulates)
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'alpha':
                        // Alpha blend: src * alpha + dst * (1 - alpha)
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'multiply':
                        // Multiply: src * dst (darker)
                        gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'screen':
                        // Screen: 1 - (1 - src) * (1 - dst) (lighter)
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'overlay':
                        // Overlay: if dst < 0.5: 2 * multiply, else: 2 * screen - 1
                        // True overlay requires reading destination buffer (not possible with simple blend funcs)
                        // Approximation: use a combination that's closer to overlay behavior
                        // Using DST_COLOR with ONE gives multiply-like effect for darker areas
                        gl.blendFunc(gl.DST_COLOR, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    default:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                }
                
                // Apply opacity by modifying blend color (requires shader modification)
                // For now, opacity affects the shape shader output
            }
            
            render(uniforms, dilationFactor, shouldCaptureShape, fadeAmount, hueShiftAmount, emanationRate, noiseAmount, noiseRate, blurAmount, blurRate, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation) {
                const gl = this.gl;
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                const shapePositionLocation = gl.getAttribLocation(this.program, 'a_position');
                
                // Calculate center pixel coordinates for clearing
                const centerX = Math.floor(this.canvas.width / 2);
                const centerY = Math.floor(this.canvas.height / 2);
                
                // Step 1: Dilation pass - expand history texture
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                
                // Setup vertex attributes
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Set dilation uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                const dilationHistoryLocation = gl.getUniformLocation(this.dilationProgram, 'u_history');
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', dilationFactor, this.dilationProgram);
                this.setUniform('u_fadeAmount', fadeAmount, this.dilationProgram);
                this.setUniform('u_hueShiftAmount', hueShiftAmount, this.dilationProgram);
                this.setUniform('u_noiseAmount', noiseAmount, this.dilationProgram);
                this.setUniform('u_noiseRate', noiseRate, this.dilationProgram);
                this.setUniform('u_blurAmount', blurAmount, this.dilationProgram);
                this.setUniform('u_blurRate', blurRate, this.dilationProgram);
                this.setUniform('u_time', uniforms.u_time || 0.0, this.dilationProgram);
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Clear center 4 pixels to prevent white accumulation
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(centerX - 1, centerY - 1, 2, 2);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.disable(gl.SCISSOR_TEST);
                
                // Step 2: Draw current shape (only add to history if shouldCaptureShape is true)
                // This controls the emanation rate - how frequently new shapes are captured
                if (shouldCaptureShape) {
                    gl.useProgram(this.program);
                    gl.enableVertexAttribArray(shapePositionLocation);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Enable blending with configurable mode
                    gl.enable(gl.BLEND);
                    this.setBlendMode(blendMode, blendOpacity);
                    
                    Object.keys(uniforms).forEach(name => {
                        this.setUniform(name, uniforms[name]);
                    });
                    this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                    this.setUniform('u_rotation', totalRotation); // Capture total rotation at this moment
                    this.setUniform('u_autoRotationSpeed', 0.0); // Disable auto-rotation for captured shapes (they're frozen)
                    this.setUniform('u_blendOpacity', blendOpacity);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND);
                }
                
                // Step 3: Display current texture to screen
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for display
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 4: Draw current star on top of everything (always visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable blending with configurable mode
                gl.enable(gl.BLEND);
                this.setBlendMode(blendMode, blendOpacity);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                this.setUniform('u_rotation', rotation);
                this.setUniform('u_autoRotationSpeed', autoRotationSpeed);
                this.setUniform('u_blendOpacity', blendOpacity);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 5: Copy current texture to history for next frame (always, for smooth dilation)
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for copy
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        
        // Load shader from external file
        async function loadShader(path) {
            const response = await fetch(path);
            if (!response.ok) {
                throw new Error(`Failed to load shader: ${path}`);
            }
            return response.text();
        }

        // Initialize (async to load shaders)
        async function init() {
            const canvas = document.getElementById('canvas');
            const renderer = new SimpleRenderer(canvas);

            // Load shaders from external files
            const [vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource] = await Promise.all([
                loadShader('shaders/star.vert'),
                loadShader('shaders/star.frag'),
                loadShader('shaders/dilation.vert'),
                loadShader('shaders/dilation.frag')
            ]);

            renderer.init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource);

            return { renderer, canvas };
        }

        // Store renderer and canvas globally after async init
        let renderer, canvas;

        // Main application initialization (async IIFE)
        (async () => {
            // Initialize renderer with async shader loading
            const result = await init();
            renderer = result.renderer;
            canvas = result.canvas;

        // Curve Editor System
        (() => {
            const curveEditorOverlay = document.getElementById('curve-editor-overlay');
            const curveEditorClose = document.getElementById('curve-editor-close');
            const curveCanvas = document.getElementById('curve-canvas');
            const curveCtx = curveCanvas.getContext('2d');
            const curveMinInput = document.getElementById('curve-min');
            const curveMaxInput = document.getElementById('curve-max');
            const curvePowerSlider = document.getElementById('curve-power');
            const curvePowerValue = document.getElementById('curve-power-value');
            const curveEditorTitle = document.getElementById('curve-editor-title');
            const curveResetBtn = document.getElementById('curve-reset');
            const curveApplyBtn = document.getElementById('curve-apply');
            const curveDoneBtn = document.getElementById('curve-close');
            
            let currentParam = null;
            let curveSettings = {}; // Store curve settings per parameter
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Default curve settings
            function getDefaultCurveSettings() {
                return {
                    min: 0,
                    max: 1,
                    power: 1.0, // Linear by default
                    type: 'power' // 'power' for exponential, could extend to 'bezier' later
                };
            }
            
            // Parameter-specific default settings
            function getParamDefaultSettings(paramName) {
                const defaults = {
                    // Shape parameters (0-1 range)
                    'spikiness': { min: 0, max: 1, power: 1.0 },
                    'spikeSharpness': { min: 0, max: 1, power: 1.0 },
                    'fillSize': { min: 0, max: 1, power: 1.0 },
                    'fillOpacity': { min: 0, max: 1, power: 1.0 },
                    'blendOpacity': { min: 0, max: 1, power: 1.0 },
                    'jiggleAmount': { min: 0, max: 1, power: 1.0 },
                    
                    // Frequency parameters
                    'spikeFrequency': { min: 2, max: 20, power: 1.0 },
                    
                    // Angle parameters
                    'hue': { min: 0, max: 360, power: 1.0 },
                    'rotation': { min: 0, max: 360, power: 1.0 },
                    
                    // Scale parameters
                    'scale': { min: 0.05, max: 1.0, power: 1.0 },
                    
                    // Rate parameters (with exponential curves)
                    'emanationRate': { min: 2, max: 200, power: 1.0 },
                    'noiseRate': { min: 0, max: 10, power: 0.333 }, // Exponential (1/3 power)
                    'blurRate': { min: 0, max: 10, power: 0.333 }, // Exponential (1/3 power)
                    'autoRotationSpeed': { min: -1, max: 360, power: 0.5 }, // Exponential (0.5 power, range -1 to 360)
                    
                    // Amount parameters (with exponential curves)
                    'noiseAmount': { min: 0, max: 1, power: 0.25 }, // Exponential (1/4 power)
                    'blurAmount': { min: 0, max: 1, power: 0.25 }, // Exponential (1/4 power)
                    'fadeAmount': { min: 0, max: 5, power: 0.333 }, // Exponential (1/3 power, range 0-5)
                    'hueShiftAmount': { min: 0, max: 0.2, power: 1.0 },
                    
                    // Dilation speed (complex mapping - approximate with range)
                    'dilationSpeed': { min: 0.88, max: 1.22, power: 0.125 }, // Very slow exponential (1/8 power)
                };
                return defaults[paramName] || null;
            }
            
            // Get or create curve settings for a parameter
            function getCurveSettings(paramName) {
                if (!curveSettings[paramName]) {
                    // Start with parameter-specific defaults if available
                    const paramDefaults = getParamDefaultSettings(paramName);
                    curveSettings[paramName] = { ...getDefaultCurveSettings(), ...(paramDefaults || {}) };
                    // Load from localStorage if available (overrides defaults)
                    const saved = localStorage.getItem(`curve_${paramName}`);
                    if (saved) {
                        try {
                            curveSettings[paramName] = { ...curveSettings[paramName], ...JSON.parse(saved) };
                        } catch (e) {
                            console.warn('Failed to load curve settings for', paramName);
                        }
                    }
                }
                return curveSettings[paramName];
            }
            
            // Save curve settings
            function saveCurveSettings(paramName) {
                if (curveSettings[paramName]) {
                    localStorage.setItem(`curve_${paramName}`, JSON.stringify(curveSettings[paramName]));
                }
            }
            
            // Map slider value (0-100) to output using curve
            function mapValue(sliderValue, settings) {
                if (!settings) settings = getDefaultCurveSettings();
                const normalized = sliderValue / 100.0;
                const curved = Math.pow(normalized, settings.power);
                return settings.min + curved * (settings.max - settings.min);
            }
            
            // Reverse map: output value to slider (0-100)
            function reverseMapValue(outputValue, settings) {
                if (!settings) settings = getDefaultCurveSettings();
                const normalized = (outputValue - settings.min) / (settings.max - settings.min);
                if (normalized <= 0) return 0;
                if (normalized >= 1) return 100;
                const curved = Math.pow(normalized, 1.0 / settings.power);
                return curved * 100;
            }
            
            // Draw curve on canvas
            function drawCurve() {
                const width = curveCanvas.width = curveCanvas.offsetWidth;
                const height = curveCanvas.height = curveCanvas.offsetHeight;
                const padding = 40;
                const w = width - padding * 2;
                const h = height - padding * 2;
                
                curveCtx.clearRect(0, 0, width, height);
                curveCtx.fillStyle = '#0a0a0a';
                curveCtx.fillRect(0, 0, width, height);
                
                const settings = currentParam ? getCurveSettings(currentParam) : getDefaultCurveSettings();
                
                // Draw grid
                curveCtx.strokeStyle = '#222';
                curveCtx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = padding + (w * i / 10);
                    const y = padding + (h * i / 10);
                    curveCtx.beginPath();
                    curveCtx.moveTo(x, padding);
                    curveCtx.lineTo(x, padding + h);
                    curveCtx.stroke();
                    curveCtx.beginPath();
                    curveCtx.moveTo(padding, y);
                    curveCtx.lineTo(padding + w, y);
                    curveCtx.stroke();
                }
                
                // Draw axes
                curveCtx.strokeStyle = '#555';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                curveCtx.moveTo(padding, padding);
                curveCtx.lineTo(padding, padding + h);
                curveCtx.lineTo(padding + w, padding + h);
                curveCtx.stroke();
                
                // Draw curve
                curveCtx.strokeStyle = '#0af';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const x = padding + (w * i / 100);
                    const normalized = i / 100.0;
                    const curved = Math.pow(normalized, settings.power);
                    const outputValue = settings.min + curved * (settings.max - settings.min);
                    const normalizedOutput = (outputValue - settings.min) / (settings.max - settings.min);
                    const y = padding + h - (normalizedOutput * h);
                    if (i === 0) {
                        curveCtx.moveTo(x, y);
                    } else {
                        curveCtx.lineTo(x, y);
                    }
                }
                curveCtx.stroke();
                
                // Draw current slider position if applicable
                if (currentParam) {
                    const slider = document.getElementById(`${currentParam}-slider`);
                    if (slider) {
                        const sliderValue = parseFloat(slider.value);
                        const x = padding + (w * sliderValue / 100);
                        const output = mapValue(sliderValue, settings);
                        const normalizedOutput = (output - settings.min) / (settings.max - settings.min);
                        const y = padding + h - (normalizedOutput * h);
                        
                        curveCtx.fillStyle = '#ff0';
                        curveCtx.beginPath();
                        curveCtx.arc(x, y, 5, 0, Math.PI * 2);
                        curveCtx.fill();
                    }
                }
                
                // Draw labels
                curveCtx.fillStyle = '#aaa';
                curveCtx.font = '10px monospace';
                curveCtx.textAlign = 'center';
                curveCtx.fillText('Input (0-100)', padding + w / 2, height - 10);
                curveCtx.save();
                curveCtx.translate(15, padding + h / 2);
                curveCtx.rotate(-Math.PI / 2);
                curveCtx.fillText('Output', 0, 0);
                curveCtx.restore();
                
                // Draw min/max labels
                curveCtx.fillStyle = '#888';
                curveCtx.font = '9px monospace';
                curveCtx.textAlign = 'right';
                curveCtx.fillText(settings.max.toFixed(2), padding - 10, padding + 5);
                curveCtx.fillText(settings.min.toFixed(2), padding - 10, padding + h + 5);
                curveCtx.textAlign = 'left';
                curveCtx.fillText('0', padding + 5, height - 10);
                curveCtx.fillText('100', padding + w - 25, height - 10);
            }
            
            // Open curve editor for a parameter
            function openCurveEditor(paramName) {
                currentParam = paramName;
                const settings = getCurveSettings(paramName);
                
                // Update UI
                const paramLabel = document.querySelector(`[data-param="${paramName}"]`)?.parentElement?.textContent || paramName;
                curveEditorTitle.textContent = `Curve Editor: ${paramLabel}`;
                curveMinInput.value = settings.min;
                curveMaxInput.value = settings.max;
                curvePowerSlider.value = settings.power;
                curvePowerValue.textContent = settings.power.toFixed(2);
                
                // Show editor
                curveEditorOverlay.classList.add('active');
                drawCurve();
                
                // Update canvas on resize
                window.addEventListener('resize', drawCurve);
            }
            
            // Close curve editor
            function closeCurveEditor() {
                curveEditorOverlay.classList.remove('active');
                currentParam = null;
                window.removeEventListener('resize', drawCurve);
            }
            
            // Apply curve settings
            function applyCurveSettings() {
                if (!currentParam) return;
                
                const settings = getCurveSettings(currentParam);
                settings.min = parseFloat(curveMinInput.value) || 0;
                settings.max = parseFloat(curveMaxInput.value) || 1;
                settings.power = parseFloat(curvePowerSlider.value) || 1.0;
                
                // Ensure min < max
                if (settings.min >= settings.max) {
                    settings.max = settings.min + 0.01;
                    curveMaxInput.value = settings.max;
                }
                
                saveCurveSettings(currentParam);
                drawCurve();
                
                // Trigger update of current slider value
                const slider = document.getElementById(`${currentParam}-slider`);
                if (slider && slider.oninput) {
                    slider.oninput({ target: slider });
                }
            }
            
            // Reset curve to default
            function resetCurve() {
                if (!currentParam) return;
                curveSettings[currentParam] = getDefaultCurveSettings();
                curveMinInput.value = curveSettings[currentParam].min;
                curveMaxInput.value = curveSettings[currentParam].max;
                curvePowerSlider.value = curveSettings[currentParam].power;
                curvePowerValue.textContent = curveSettings[currentParam].power.toFixed(2);
                drawCurve();
            }
            
            // Event listeners
            curveEditorClose.addEventListener('click', closeCurveEditor);
            curveDoneBtn.addEventListener('click', () => {
                applyCurveSettings();
                closeCurveEditor();
            });
            curveApplyBtn.addEventListener('click', applyCurveSettings);
            curveResetBtn.addEventListener('click', resetCurve);
            
            curveMinInput.addEventListener('input', () => {
                applyCurveSettings();
            });
            
            curveMaxInput.addEventListener('input', () => {
                applyCurveSettings();
            });
            
            curvePowerSlider.addEventListener('input', (e) => {
                curvePowerValue.textContent = parseFloat(e.target.value).toFixed(2);
                applyCurveSettings();
            });
            
            // Click outside to close
            curveEditorOverlay.addEventListener('click', (e) => {
                if (e.target === curveEditorOverlay) {
                    closeCurveEditor();
                }
            });
            
            // Make curve editor available globally
            window.CurveEditor = {
                open: openCurveEditor,
                mapValue: mapValue,
                reverseMapValue: reverseMapValue,
                getCurveSettings: getCurveSettings
            };
        })();
        
        (() => {
            // Get slider elements
            const spikinessSlider = document.getElementById('spikiness-slider');
            const spikeFrequencySlider = document.getElementById('spike-frequency-slider');
            const spikeSharpnessSlider = document.getElementById('spike-sharpness-slider');
            const hueSlider = document.getElementById('hue-slider');
            const scaleSlider = document.getElementById('scale-slider');
            const dilationSlider = document.getElementById('dilation-slider');
            const fadeSlider = document.getElementById('fade-slider');
            const hueShiftSlider = document.getElementById('hue-shift-slider');
            const rotationSlider = document.getElementById('rotation-slider');
            const spikinessValue = document.getElementById('spikiness-value');
            const spikeFrequencyValue = document.getElementById('spike-frequency-value');
            const spikeSharpnessValue = document.getElementById('spike-sharpness-value');
            const hueValue = document.getElementById('hue-value');
            const scaleValue = document.getElementById('scale-value');
            const dilationValue = document.getElementById('dilation-value');
            const fadeValue = document.getElementById('fade-value');
            const hueShiftValue = document.getElementById('hue-shift-value');
            const rotationValue = document.getElementById('rotation-value');
            const blendModeSelect = document.getElementById('blend-mode-select');
            const blendOpacitySlider = document.getElementById('blend-opacity-slider');
            const blendOpacityValue = document.getElementById('blend-opacity-value');
            const fillSizeSlider = document.getElementById('fill-size-slider');
            const fillSizeValue = document.getElementById('fill-size-value');
            const fillOpacitySlider = document.getElementById('fill-opacity-slider');
            const fillOpacityValue = document.getElementById('fill-opacity-value');
            const randomizeBtn = document.getElementById('randomize-btn');
            const jiggleBtn = document.getElementById('jiggle-btn');
            const jiggleAmountSlider = document.getElementById('jiggle-amount-slider');
            const jiggleAmountValue = document.getElementById('jiggle-amount-value');
            
            // Jiggle settings drawer
            const jiggleSettingsHeader = document.getElementById('jiggle-settings-header');
            const jiggleSettingsContent = document.getElementById('jiggle-settings-content');
            
            // Initialize jiggle enabled params (all enabled by default)
            const jiggleParamNames = [
                'spikiness', 'spikeFrequency', 'spikeSharpness',
                'hue', 'scale', 'fillSize', 'fillOpacity',
                'dilationSpeed', 'fadeAmount', 'emanationRate',
                'noiseAmount', 'noiseRate', 'blurAmount', 'blurRate',
                'autoRotationSpeed', 'hueShiftAmount', 'blendOpacity'
            ];
            
            // Initialize jiggleEnabledParams object - all enabled by default
            let jiggleEnabledParams = {};
            jiggleParamNames.forEach(param => {
                jiggleEnabledParams[param] = true;
            });
            
            // Toggle jiggle settings drawer - set up handler
            // Note: This header is excluded from the generic section-header handler below
            function setupJiggleDrawerHandler() {
                const header = document.getElementById('jiggle-settings-header');
                const content = document.getElementById('jiggle-settings-content');
                if (header && content) {
                    header.style.userSelect = 'none'; // Prevent text selection
                    header.addEventListener('click', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const isCollapsed = this.classList.contains('collapsed');
                        console.log('Jiggle drawer clicked, isCollapsed:', isCollapsed); // Debug log
                        if (isCollapsed) {
                            this.classList.remove('collapsed');
                            content.style.display = 'block';
                        } else {
                            this.classList.add('collapsed');
                            content.style.display = 'none';
                        }
                    });
                    console.log('Jiggle drawer handler attached successfully'); // Debug log
                    return true;
                } else {
                    console.warn('Jiggle drawer elements not found:', { header: !!header, content: !!content }); // Debug log
                }
                return false;
            }
            
            // Set up the handler
            if (!setupJiggleDrawerHandler()) {
                // Fallback: try again after a short delay in case DOM isn't ready
                setTimeout(() => {
                    console.log('Retrying jiggle drawer handler setup...'); // Debug log
                    setupJiggleDrawerHandler();
                }, 100);
            }
            
            // Initialize checkboxes and add event listeners
            jiggleParamNames.forEach(param => {
                const checkbox = document.getElementById(`jiggle-param-${param}`);
                if (checkbox) {
                    checkbox.checked = jiggleEnabledParams[param];
                    checkbox.addEventListener('change', (e) => {
                        jiggleEnabledParams[param] = e.target.checked;
                    });
                }
            });
            
            // Quick action buttons
            const jiggleAllBtn = document.getElementById('jiggle-all-btn');
            const jiggleNoneBtn = document.getElementById('jiggle-none-btn');
            const jiggleShapeBtn = document.getElementById('jiggle-shape-btn');
            const jiggleAppearanceBtn = document.getElementById('jiggle-appearance-btn');
            
            if (jiggleAllBtn) {
                jiggleAllBtn.addEventListener('click', () => {
                    jiggleParamNames.forEach(param => {
                        jiggleEnabledParams[param] = true;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = true;
                    });
                });
            }
            
            if (jiggleNoneBtn) {
                jiggleNoneBtn.addEventListener('click', () => {
                    jiggleParamNames.forEach(param => {
                        jiggleEnabledParams[param] = false;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = false;
                    });
                });
            }
            
            if (jiggleShapeBtn) {
                jiggleShapeBtn.addEventListener('click', () => {
                    const shapeParams = ['spikiness', 'spikeFrequency', 'spikeSharpness'];
                    jiggleParamNames.forEach(param => {
                        const enabled = shapeParams.includes(param);
                        jiggleEnabledParams[param] = enabled;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = enabled;
                    });
                });
            }
            
            if (jiggleAppearanceBtn) {
                jiggleAppearanceBtn.addEventListener('click', () => {
                    const appearanceParams = ['hue', 'scale', 'fillSize', 'fillOpacity'];
                    jiggleParamNames.forEach(param => {
                        const enabled = appearanceParams.includes(param);
                        jiggleEnabledParams[param] = enabled;
                        const checkbox = document.getElementById(`jiggle-param-${param}`);
                        if (checkbox) checkbox.checked = enabled;
                    });
                });
            }
            
            // Get emanation rate slider before initializing values
            const emanationRateSlider = document.getElementById('emanation-rate-slider');
            const emanationRateValue = document.getElementById('emanation-rate-value');
            const autoRotationSlider = document.getElementById('auto-rotation-slider');
            const autoRotationValue = document.getElementById('auto-rotation-value');
            
            // Filter sliders
            const noiseAmountSlider = document.getElementById('noise-amount-slider');
            const noiseAmountValue = document.getElementById('noise-amount-value');
            const noiseRateSlider = document.getElementById('noise-rate-slider');
            const noiseRateValue = document.getElementById('noise-rate-value');
            const blurAmountSlider = document.getElementById('blur-amount-slider');
            const blurAmountValue = document.getElementById('blur-amount-value');
            const blurRateSlider = document.getElementById('blur-rate-slider');
            const blurRateValue = document.getElementById('blur-rate-value');
            
            // GIF capture state
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            let gifRecording = false;
            let gifCaptureFrames = [];
            let gifCaptureTimer = null;
            let gifCountdownTimer = null;
            let gifCaptureStart = 0;
            let gifCaptureWidth = 0;
            let gifCaptureHeight = 0;
            const GIF_FPS = 15;
            const GIF_MAX_MS = 10000; // 10s max
            
            // Get preset management elements before defining functions
            const presetSelect = document.getElementById('preset-select');
            const presetNameInput = document.getElementById('preset-name-input');
            const savePresetBtn = document.getElementById('save-preset-btn');
            const deletePresetBtn = document.getElementById('delete-preset-btn');
            const exportPresetsBtn = document.getElementById('export-presets-btn');
            const importPresetsInput = document.getElementById('import-presets-input');
            
            // Status indicators
            const freezeIndicator = document.getElementById('freeze-indicator');
            const jiggleIndicator = document.getElementById('jiggle-indicator');
            const unsavedIndicator = document.getElementById('unsaved-indicator');
            const statusIndicators = document.getElementById('status-indicators');
            const hotkeyLegend = document.getElementById('hotkey-legend');
            const recordIndicator = document.getElementById('record-indicator');
            
            // Position status indicators below hotkey legend
            function positionStatusIndicators() {
                if (hotkeyLegend && statusIndicators) {
                    const rect = hotkeyLegend.getBoundingClientRect();
                    statusIndicators.style.top = (rect.bottom + 6) + 'px';
                    statusIndicators.style.left = rect.left + 'px';
                }
            }
            
            // Position UX toolbox below status indicators
            const uxToolbox = document.getElementById('ux-toolbox');
            function positionUXToolbox() {
                if (statusIndicators && uxToolbox) {
                    const rect = statusIndicators.getBoundingClientRect();
                    uxToolbox.style.top = (rect.bottom + 6) + 'px';
                    uxToolbox.style.left = rect.left + 'px';
                }
            }
            
            // Position on load and resize
            positionStatusIndicators();
            positionUXToolbox();
            window.addEventListener('resize', () => {
                positionStatusIndicators();
                positionUXToolbox();
            });
            
            // ============================================
            // Smooth Interpolation System
            // ============================================
            
            class ParameterInterpolator {
                constructor() {
                    this.params = new Map(); // paramName -> {current, target, startTime, duration, startValue, easing}
                    this.springParams = new Map(); // paramName -> {current, target, velocity, spring, damping}
                    this.enabled = true;
                    this.defaultDuration = 0.5; // seconds
                    this.defaultEasing = 'easeInOut';
                    this.springConstant = 0.1;
                    this.springDamping = 0.8;
                    this.useSpringForRotation = true;
                }
                
                setEnabled(enabled) {
                    this.enabled = enabled;
                    if (!enabled) {
                        // Snap all params to targets
                        this.params.forEach((state, paramName) => {
                            state.current = state.target;
                        });
                        this.springParams.forEach((state, paramName) => {
                            state.current = state.target;
                            state.velocity = 0;
                        });
                    }
                }
                
                setTarget(paramName, targetValue, duration = null, easing = null, useSpring = false) {
                    if (!this.enabled) {
                        // If disabled, set current directly
                        if (useSpring || (this.useSpringForRotation && paramName === 'rotation')) {
                            const state = this.springParams.get(paramName) || { current: targetValue, velocity: 0, spring: this.springConstant, damping: this.springDamping };
                            state.target = targetValue;
                            state.spring = this.springConstant;
                            state.damping = this.springDamping;
                            this.springParams.set(paramName, state);
                        } else {
                            const state = this.params.get(paramName) || { current: targetValue };
                            state.current = targetValue;
                            state.target = targetValue;
                            this.params.set(paramName, state);
                        }
                        return;
                    }
                    
                    const currentValue = this.getCurrent(paramName);
                    const finalDuration = duration ?? this.defaultDuration;
                    const finalEasing = easing ?? this.defaultEasing;
                    
                    if (useSpring || (this.useSpringForRotation && paramName === 'rotation')) {
                        const state = this.springParams.get(paramName) || { current: currentValue, velocity: 0, spring: this.springConstant, damping: this.springDamping };
                        state.target = targetValue;
                        state.spring = this.springConstant;
                        state.damping = this.springDamping;
                        this.springParams.set(paramName, state);
                    } else {
                        this.params.set(paramName, {
                            current: currentValue,
                            target: targetValue,
                            startValue: currentValue,
                            startTime: Date.now(),
                            duration: finalDuration * 1000, // Convert to ms
                            easing: finalEasing
                        });
                    }
                }
                
                update() {
                    if (!this.enabled) return;
                    
                    const now = Date.now();
                    const deltaTime = 1/60; // Assume 60fps
                    
                    // Update standard interpolations
                    this.params.forEach((state, paramName) => {
                        const elapsed = now - state.startTime;
                        const progress = Math.min(elapsed / state.duration, 1);
                        
                        if (progress >= 1) {
                            state.current = state.target;
                        } else {
                            const t = this.applyEasing(progress, state.easing);
                            state.current = this.lerp(state.startValue, state.target, t);
                        }
                    });
                    
                    // Update spring-based interpolations
                    this.springParams.forEach((state, paramName) => {
                        const distance = state.target - state.current;
                        const force = distance * state.spring;
                        state.velocity = (state.velocity + force) * state.damping;
                        state.current += state.velocity * deltaTime;
                        
                        // Stop if very close and velocity is small
                        if (Math.abs(distance) < 0.001 && Math.abs(state.velocity) < 0.001) {
                            state.current = state.target;
                            state.velocity = 0;
                        }
                    });
                }
                
                getCurrent(paramName) {
                    if (this.springParams.has(paramName)) {
                        return this.springParams.get(paramName).current;
                    }
                    if (this.params.has(paramName)) {
                        return this.params.get(paramName).current;
                    }
                    // Return target if param doesn't exist yet (for initialization)
                    return null;
                }
                
                lerp(start, end, t) {
                    return start + (end - start) * t;
                }
                
                applyEasing(t, easing) {
                    switch(easing) {
                        case 'linear':
                            return t;
                        case 'easeIn':
                            return t * t;
                        case 'easeOut':
                            return 1 - (1 - t) * (1 - t);
                        case 'easeInOut':
                            return t < 0.5 
                                ? 2 * t * t 
                                : 1 - Math.pow(-2 * t + 2, 2) / 2;
                        default:
                            return t < 0.5 
                                ? 2 * t * t 
                                : 1 - Math.pow(-2 * t + 2, 2) / 2;
                    }
                }
                
                // Handle rotation wrapping (359° -> 1° should go forward, not backward)
                setTargetRotation(paramName, targetValue) {
                    const current = this.getCurrent(paramName) ?? targetValue;
                    
                    // Normalize angles to 0-360
                    const currentNorm = ((current % 360) + 360) % 360;
                    const targetNorm = ((targetValue % 360) + 360) % 360;
                    
                    // Find shortest path
                    let diff = targetNorm - currentNorm;
                    if (Math.abs(diff) > 180) {
                        diff = diff > 0 ? diff - 360 : diff + 360;
                    }
                    
                    this.setTarget(paramName, currentNorm + diff, null, null, this.useSpringForRotation);
                }
            }
            
            // Create global interpolator instance
            const interpolator = new ParameterInterpolator();
            
            // Wire up interpolation settings UI
            const interpolationEnabled = document.getElementById('interpolation-enabled');
            const interpolationDurationSlider = document.getElementById('interpolation-duration-slider');
            const interpolationDurationValue = document.getElementById('interpolation-duration-value');
            const interpolationEasingSelect = document.getElementById('interpolation-easing-select');
            const interpolationSpringSlider = document.getElementById('interpolation-spring-slider');
            const interpolationSpringValue = document.getElementById('interpolation-spring-value');
            const interpolationDampingSlider = document.getElementById('interpolation-damping-slider');
            const interpolationDampingValue = document.getElementById('interpolation-damping-value');
            const interpolationRotationSpring = document.getElementById('interpolation-rotation-spring');
            const interpolationSettingsHeader = document.getElementById('interpolation-settings-header');
            const interpolationSettingsContent = document.getElementById('interpolation-settings-content');
            
            // Toggle interpolation settings drawer
            if (interpolationSettingsHeader && interpolationSettingsContent) {
                interpolationSettingsHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isCollapsed = this.classList.contains('collapsed');
                    if (isCollapsed) {
                        this.classList.remove('collapsed');
                        interpolationSettingsContent.style.display = 'block';
                    } else {
                        this.classList.add('collapsed');
                        interpolationSettingsContent.style.display = 'none';
                    }
                });
            }
            
            // Debug values panel
            const debugValuesHeader = document.getElementById('debug-values-header');
            const debugValuesContent = document.getElementById('debug-values-content');
            const debugOutput = document.getElementById('debug-output');
            
            if (debugValuesHeader && debugValuesContent) {
                debugValuesHeader.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const isCollapsed = this.classList.contains('collapsed');
                    if (isCollapsed) {
                        this.classList.remove('collapsed');
                        debugValuesContent.style.display = 'block';
                    } else {
                        this.classList.add('collapsed');
                        debugValuesContent.style.display = 'none';
                    }
                });
            }
            
            // Function to update debug output
            function updateDebugOutput() {
                if (!debugOutput || debugValuesContent.style.display === 'none') return;
                
                const getInterpolatedCurrent = (param) => interpolator.getCurrent(param) ?? 'N/A';
                const getInterpolatedTarget = (param) => {
                    const state = interpolator.params.get(param);
                    const springState = interpolator.springParams.get(param);
                    if (springState) return springState.target.toFixed(4);
                    if (state) return state.target.toFixed(4);
                    return 'N/A';
                };
                const getInterpolationProgress = (param) => {
                    const state = interpolator.params.get(param);
                    if (!state) return 'N/A';
                    const elapsed = Date.now() - state.startTime;
                    const progress = Math.min(elapsed / state.duration, 1);
                    return (progress * 100).toFixed(1) + '%';
                };
                const getSpringVelocity = (param) => {
                    const state = interpolator.springParams.get(param);
                    if (!state) return 'N/A';
                    return state.velocity.toFixed(4);
                };
                
                const output = [];
                output.push('=== INTERPOLATION STATE ===');
                output.push(`Enabled: ${interpolator.enabled}`);
                output.push(`Active: ${interpolator.enabled && !jiggleEnabled}`);
                output.push(`Jiggle Enabled: ${jiggleEnabled}`);
                output.push(`Jiggle Amount: ${(jiggleAmount * 100).toFixed(1)}%`);
                output.push('');
                
                output.push('=== ROTATION ===');
                output.push(`Rotation (direct): ${rotation.toFixed(2)}°`);
                output.push(`Rotation (interp current): ${getInterpolatedCurrent('rotation')}°`);
                output.push(`Rotation (interp target): ${getInterpolatedTarget('rotation')}°`);
                output.push(`Rotation (base): ${baseRotation.toFixed(2)}°`);
                output.push(`Rotation (target base): ${targetBaseRotation.toFixed(2)}°`);
                const rotSpring = interpolator.springParams.get('rotation');
                if (rotSpring) {
                    output.push(`Rotation (spring velocity): ${rotSpring.velocity.toFixed(4)}`);
                }
                output.push(`Auto Rotation Speed (direct): ${autoRotationSpeed.toFixed(2)}°/s`);
                output.push(`Auto Rotation Speed (interp current): ${getInterpolatedCurrent('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (interp target): ${getInterpolatedTarget('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (base): ${baseAutoRotationSpeed.toFixed(2)}°/s`);
                output.push('');
                
                output.push('=== DILATION ===');
                output.push(`Dilation Speed (direct): ${dilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (interp current): ${getInterpolatedCurrent('dilationSpeed')}`);
                output.push(`Dilation Speed (interp target): ${getInterpolatedTarget('dilationSpeed')}`);
                output.push(`Dilation Speed (base): ${baseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (target base): ${targetBaseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (progress): ${getInterpolationProgress('dilationSpeed')}`);
                output.push(`Effective (freeze): ${freezeEnabled ? '1.0 (frozen)' : dilationSpeed.toFixed(4)}`);
                output.push('');
                
                output.push('=== SHAPE ===');
                output.push(`Spikiness: ${spikiness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikiness')} | target: ${getInterpolatedTarget('spikiness')} | base: ${baseSpikiness.toFixed(3)}`);
                output.push(`Spike Freq: ${spikeFrequency.toFixed(2)} | interp: ${getInterpolatedCurrent('spikeFrequency')} | target: ${getInterpolatedTarget('spikeFrequency')} | base: ${baseSpikeFrequency.toFixed(2)}`);
                output.push(`Spike Sharp: ${spikeSharpness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikeSharpness')} | target: ${getInterpolatedTarget('spikeSharpness')} | base: ${baseSpikeSharpness.toFixed(3)}`);
                output.push('');
                
                output.push('=== APPEARANCE ===');
                output.push(`Hue: ${hue.toFixed(1)}° | interp: ${getInterpolatedCurrent('hue')}° | target: ${getInterpolatedTarget('hue')}° | base: ${baseHue.toFixed(1)}°`);
                output.push(`Scale: ${scale.toFixed(3)} | interp: ${getInterpolatedCurrent('scale')} | target: ${getInterpolatedTarget('scale')} | base: ${baseScale.toFixed(3)}`);
                output.push(`Fill Size: ${fillSize.toFixed(3)} | interp: ${getInterpolatedCurrent('fillSize')} | target: ${getInterpolatedTarget('fillSize')} | base: ${baseFillSize.toFixed(3)}`);
                output.push(`Fill Opacity: ${fillOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('fillOpacity')} | target: ${getInterpolatedTarget('fillOpacity')} | base: ${baseFillOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== EMANATION ===');
                output.push(`Emanation Rate: ${emanationRate.toFixed(2)} | interp: ${getInterpolatedCurrent('emanationRate')} | target: ${getInterpolatedTarget('emanationRate')} | base: ${baseEmanationRate.toFixed(2)}`);
                output.push(`Fade Amount: ${fadeAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('fadeAmount')} | target: ${getInterpolatedTarget('fadeAmount')} | base: ${baseFadeAmount.toFixed(3)}`);
                output.push('');
                
                output.push('=== FILTERS ===');
                output.push(`Noise Amount: ${noiseAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('noiseAmount')} | target: ${getInterpolatedTarget('noiseAmount')} | base: ${baseNoiseAmount.toFixed(3)}`);
                output.push(`Noise Rate: ${noiseRate.toFixed(2)} | interp: ${getInterpolatedCurrent('noiseRate')} | target: ${getInterpolatedTarget('noiseRate')} | base: ${baseNoiseRate.toFixed(2)}`);
                output.push(`Blur Amount: ${blurAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('blurAmount')} | target: ${getInterpolatedTarget('blurAmount')} | base: ${baseBlurAmount.toFixed(3)}`);
                output.push(`Blur Rate: ${blurRate.toFixed(2)} | interp: ${getInterpolatedCurrent('blurRate')} | target: ${getInterpolatedTarget('blurRate')} | base: ${baseBlurRate.toFixed(2)}`);
                output.push('');
                
                output.push('=== EFFECTS ===');
                output.push(`Hue Shift: ${hueShiftAmount.toFixed(4)} | interp: ${getInterpolatedCurrent('hueShiftAmount')} | target: ${getInterpolatedTarget('hueShiftAmount')} | base: ${baseHueShiftAmount.toFixed(4)}`);
                output.push(`Blend Opacity: ${blendOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('blendOpacity')} | target: ${getInterpolatedTarget('blendOpacity')} | base: ${baseBlendOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== CALCULATED VALUES ===');
                const currentTime = (Date.now() - startTime) / 1000.0;
                const interpolatedRot = interpolator.getCurrent('rotation') ?? rotation;
                const interpolatedAutoRot = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                const totalRotation = interpolatedRot + (currentTime * interpolatedAutoRot);
                output.push(`Total Rotation: ${totalRotation.toFixed(2)}°`);
                output.push(`Time: ${currentTime.toFixed(2)}s`);
                
                debugOutput.textContent = output.join('\n');
            }
            
            // Interpolation enabled toggle
            if (interpolationEnabled) {
                interpolationEnabled.addEventListener('change', (e) => {
                    interpolator.setEnabled(e.target.checked);
                });
            }
            
            // Duration slider
            if (interpolationDurationSlider) {
                interpolationDurationSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    interpolator.defaultDuration = value;
                    interpolationDurationValue.textContent = value.toFixed(2);
                });
                handleValueEdit(interpolationDurationValue,
                    (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                    (val) => val.toFixed(2),
                    (val) => {
                        interpolator.defaultDuration = val;
                        interpolationDurationSlider.value = val;
                    }
                );
            }
            
            // Easing select
            if (interpolationEasingSelect) {
                interpolationEasingSelect.addEventListener('change', (e) => {
                    interpolator.defaultEasing = e.target.value;
                });
            }
            
            // Spring constant slider
            if (interpolationSpringSlider) {
                interpolationSpringSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    interpolator.springConstant = value;
                    interpolationSpringValue.textContent = value.toFixed(2);
                    // Update existing spring params
                    interpolator.springParams.forEach((state) => {
                        state.spring = value;
                    });
                });
                handleValueEdit(interpolationSpringValue,
                    (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                    (val) => val.toFixed(2),
                    (val) => {
                        interpolator.springConstant = val;
                        interpolationSpringSlider.value = val;
                    }
                );
            }
            
            // Damping slider
            if (interpolationDampingSlider) {
                interpolationDampingSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    interpolator.springDamping = value;
                    interpolationDampingValue.textContent = value.toFixed(2);
                    // Update existing spring params
                    interpolator.springParams.forEach((state) => {
                        state.damping = value;
                    });
                });
                handleValueEdit(interpolationDampingValue,
                    (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                    (val) => val.toFixed(2),
                    (val) => {
                        interpolator.springDamping = val;
                        interpolationDampingSlider.value = val;
                    }
                );
            }
            
            // Rotation spring toggle
            if (interpolationRotationSpring) {
                interpolationRotationSpring.addEventListener('change', (e) => {
                    interpolator.useSpringForRotation = e.target.checked;
                });
            }
            
            // Function to update debug output
            function updateDebugOutput() {
                if (!debugOutput || !debugValuesContent || debugValuesContent.style.display === 'none') return;
                
                const getInterpolatedCurrent = (param) => {
                    const val = interpolator.getCurrent(param);
                    return val !== null && val !== undefined ? val.toFixed(4) : 'N/A';
                };
                const getInterpolatedTarget = (param) => {
                    const state = interpolator.params.get(param);
                    const springState = interpolator.springParams.get(param);
                    if (springState) return springState.target.toFixed(4);
                    if (state) return state.target.toFixed(4);
                    return 'N/A';
                };
                const getInterpolationProgress = (param) => {
                    const state = interpolator.params.get(param);
                    if (!state) return 'N/A';
                    const elapsed = Date.now() - state.startTime;
                    const progress = Math.min(elapsed / state.duration, 1);
                    return (progress * 100).toFixed(1) + '%';
                };
                
                const output = [];
                output.push('=== INTERPOLATION STATE ===');
                output.push(`Enabled: ${interpolator.enabled}`);
                output.push(`Active: ${interpolator.enabled && !jiggleEnabled}`);
                output.push(`Jiggle Enabled: ${jiggleEnabled}`);
                output.push(`Jiggle Amount: ${(jiggleAmount * 100).toFixed(1)}%`);
                output.push('');
                
                output.push('=== ROTATION ===');
                output.push(`Rotation (direct): ${rotation.toFixed(2)}°`);
                output.push(`Rotation (interp current): ${getInterpolatedCurrent('rotation')}°`);
                output.push(`Rotation (interp target): ${getInterpolatedTarget('rotation')}°`);
                output.push(`Rotation (base): ${baseRotation.toFixed(2)}°`);
                output.push(`Rotation (target base): ${targetBaseRotation.toFixed(2)}°`);
                const rotSpring = interpolator.springParams.get('rotation');
                if (rotSpring) {
                    output.push(`Rotation (spring velocity): ${rotSpring.velocity.toFixed(4)}`);
                }
                output.push(`Auto Rotation Speed (direct): ${autoRotationSpeed.toFixed(2)}°/s`);
                output.push(`Auto Rotation Speed (interp current): ${getInterpolatedCurrent('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (interp target): ${getInterpolatedTarget('autoRotationSpeed')}°/s`);
                output.push(`Auto Rotation Speed (base): ${baseAutoRotationSpeed.toFixed(2)}°/s`);
                output.push('');
                
                output.push('=== DILATION ===');
                output.push(`Dilation Speed (direct): ${dilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (interp current): ${getInterpolatedCurrent('dilationSpeed')}`);
                output.push(`Dilation Speed (interp target): ${getInterpolatedTarget('dilationSpeed')}`);
                output.push(`Dilation Speed (base): ${baseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (target base): ${targetBaseDilationSpeed.toFixed(4)}`);
                output.push(`Dilation Speed (progress): ${getInterpolationProgress('dilationSpeed')}`);
                output.push(`Effective (freeze): ${freezeEnabled ? '1.0 (frozen)' : dilationSpeed.toFixed(4)}`);
                output.push('');
                
                output.push('=== SHAPE ===');
                output.push(`Spikiness: ${spikiness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikiness')} | target: ${getInterpolatedTarget('spikiness')} | base: ${baseSpikiness.toFixed(3)}`);
                output.push(`Spike Freq: ${spikeFrequency.toFixed(2)} | interp: ${getInterpolatedCurrent('spikeFrequency')} | target: ${getInterpolatedTarget('spikeFrequency')} | base: ${baseSpikeFrequency.toFixed(2)}`);
                output.push(`Spike Sharp: ${spikeSharpness.toFixed(3)} | interp: ${getInterpolatedCurrent('spikeSharpness')} | target: ${getInterpolatedTarget('spikeSharpness')} | base: ${baseSpikeSharpness.toFixed(3)}`);
                output.push('');
                
                output.push('=== APPEARANCE ===');
                output.push(`Hue: ${hue.toFixed(1)}° | interp: ${getInterpolatedCurrent('hue')}° | target: ${getInterpolatedTarget('hue')}° | base: ${baseHue.toFixed(1)}°`);
                output.push(`Scale: ${scale.toFixed(3)} | interp: ${getInterpolatedCurrent('scale')} | target: ${getInterpolatedTarget('scale')} | base: ${baseScale.toFixed(3)}`);
                output.push(`Fill Size: ${fillSize.toFixed(3)} | interp: ${getInterpolatedCurrent('fillSize')} | target: ${getInterpolatedTarget('fillSize')} | base: ${baseFillSize.toFixed(3)}`);
                output.push(`Fill Opacity: ${fillOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('fillOpacity')} | target: ${getInterpolatedTarget('fillOpacity')} | base: ${baseFillOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== EMANATION ===');
                output.push(`Emanation Rate: ${emanationRate.toFixed(2)} | interp: ${getInterpolatedCurrent('emanationRate')} | target: ${getInterpolatedTarget('emanationRate')} | base: ${baseEmanationRate.toFixed(2)}`);
                output.push(`Fade Amount: ${fadeAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('fadeAmount')} | target: ${getInterpolatedTarget('fadeAmount')} | base: ${baseFadeAmount.toFixed(3)}`);
                output.push('');
                
                output.push('=== FILTERS ===');
                output.push(`Noise Amount: ${noiseAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('noiseAmount')} | target: ${getInterpolatedTarget('noiseAmount')} | base: ${baseNoiseAmount.toFixed(3)}`);
                output.push(`Noise Rate: ${noiseRate.toFixed(2)} | interp: ${getInterpolatedCurrent('noiseRate')} | target: ${getInterpolatedTarget('noiseRate')} | base: ${baseNoiseRate.toFixed(2)}`);
                output.push(`Blur Amount: ${blurAmount.toFixed(3)} | interp: ${getInterpolatedCurrent('blurAmount')} | target: ${getInterpolatedTarget('blurAmount')} | base: ${baseBlurAmount.toFixed(3)}`);
                output.push(`Blur Rate: ${blurRate.toFixed(2)} | interp: ${getInterpolatedCurrent('blurRate')} | target: ${getInterpolatedTarget('blurRate')} | base: ${baseBlurRate.toFixed(2)}`);
                output.push('');
                
                output.push('=== EFFECTS ===');
                output.push(`Hue Shift: ${hueShiftAmount.toFixed(4)} | interp: ${getInterpolatedCurrent('hueShiftAmount')} | target: ${getInterpolatedTarget('hueShiftAmount')} | base: ${baseHueShiftAmount.toFixed(4)}`);
                output.push(`Blend Opacity: ${blendOpacity.toFixed(3)} | interp: ${getInterpolatedCurrent('blendOpacity')} | target: ${getInterpolatedTarget('blendOpacity')} | base: ${baseBlendOpacity.toFixed(3)}`);
                output.push('');
                
                output.push('=== CALCULATED VALUES ===');
                const currentTime = (Date.now() - startTime) / 1000.0;
                const interpolatedRot = interpolator.getCurrent('rotation') ?? rotation;
                const interpolatedAutoRot = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                const totalRotation = interpolatedRot + (currentTime * interpolatedAutoRot);
                output.push(`Total Rotation: ${totalRotation.toFixed(2)}°`);
                output.push(`Time: ${currentTime.toFixed(2)}s`);
                
                debugOutput.textContent = output.join('\n');
            }
            
            // Track last loaded preset for unsaved changes detection
            let lastLoadedPresetName = null;
            let lastLoadedPresetValues = null;
            
            // Function to update status indicators
            function updateStatusIndicators() {
                freezeIndicator.style.display = freezeEnabled ? 'inline-block' : 'none';
                jiggleIndicator.style.display = jiggleEnabled ? 'inline-block' : 'none';
                
                // Check if current values differ from last loaded preset
                if (lastLoadedPresetName && lastLoadedPresetValues) {
                    const currentValues = {
                        spikiness, spikeFrequency, spikeSharpness, hue, scale,
                        fillSize, fillOpacity, rotation, hueShiftAmount,
                        dilationSpeed, fadeAmount, emanationRate, autoRotationSpeed,
                        blendMode, blendOpacity
                    };
                    
                    // Compare values (with small tolerance for floating point)
                    let hasChanges = false;
                    for (const [key, currentValue] of Object.entries(currentValues)) {
                        const lastValue = lastLoadedPresetValues[key];
                        if (lastValue !== undefined && Math.abs(currentValue - lastValue) > 0.001) {
                            hasChanges = true;
                            break;
                        }
                    }
                    // Also check blendMode (string comparison)
                    if (currentValues.blendMode !== lastLoadedPresetValues.blendMode) {
                        hasChanges = true;
                    }
                    
                    unsavedIndicator.style.display = hasChanges ? 'inline-block' : 'none';
                } else {
                    unsavedIndicator.style.display = 'none';
                }
            }
            
            // Collapsible dev-tool sections
            const sectionHeaders = Array.from(document.querySelectorAll('#dev-toolbox .section-header'));
            sectionHeaders.forEach((header) => {
                // Skip jiggle-settings-header as it has its own custom handler
                if (header.id === 'jiggle-settings-header') {
                    return;
                }
                header.addEventListener('click', () => {
                    const collapsed = header.classList.toggle('collapsed');
                    let el = header.nextElementSibling;
                    while (el && !el.classList.contains('section-header')) {
                        if (collapsed) {
                            el.dataset._display = el.style.display || '';
                            el.style.display = 'none';
                        } else {
                            el.style.display = el.dataset._display || '';
                        }
                        el = el.nextElementSibling;
                    }
                });
            });
            
            // Preset management functions (need to be defined before we try to load presets)
            // Load presets from localStorage
            function loadPresets() {
                const presets = JSON.parse(localStorage.getItem('sandboxPresets') || '{}');
                presetSelect.innerHTML = '<option value="">-- Select Preset --</option>';
                Object.keys(presets).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    presetSelect.appendChild(option);
                });
                return presets;
            }
            
            // Load preset
            function loadPreset(name) {
                const presets = loadPresets();
                if (!presets[name]) {
                    alert('Preset not found');
                    return;
                }
                
                const preset = presets[name];
                
                // Set all values using interpolation for smooth transitions
                // Handle migration from old "spikes" parameter to new shape parameters
                if (preset.spikes !== undefined) {
                    // Old preset format: convert discrete spikes to continuous parameters
                    const oldSpikes = preset.spikes;
                    interpolator.setTarget('spikiness', 0.8); // Default spikiness for old presets
                    interpolator.setTarget('spikeFrequency', Math.max(2.0, Math.min(20.0, oldSpikes))); // Use old spike count as frequency
                    interpolator.setTarget('spikeSharpness', 0.0); // Default sharpness
                } else {
                    // New preset format
                    interpolator.setTarget('spikiness', preset.spikiness !== undefined ? preset.spikiness : 0.5);
                    interpolator.setTarget('spikeFrequency', preset.spikeFrequency !== undefined ? preset.spikeFrequency : 5.0);
                    interpolator.setTarget('spikeSharpness', preset.spikeSharpness !== undefined ? preset.spikeSharpness : 0.0);
                }
                interpolator.setTarget('hue', preset.hue);
                interpolator.setTarget('scale', preset.scale);
                interpolator.setTarget('hueShiftAmount', preset.hueShiftAmount);
                interpolator.setTargetRotation('rotation', preset.rotation); // Use rotation-specific setter for wrapping
                blendMode = preset.blendMode; // Blend mode doesn't need interpolation
                interpolator.setTarget('blendOpacity', preset.blendOpacity);
                interpolator.setTarget('fillSize', preset.fillSize !== undefined ? preset.fillSize : 0.0);
                interpolator.setTarget('fillOpacity', preset.fillOpacity !== undefined ? preset.fillOpacity : 0.6);
                interpolator.setTarget('emanationRate', preset.emanationRate !== undefined ? preset.emanationRate : 2.0);
                interpolator.setTarget('noiseAmount', preset.noiseAmount !== undefined ? preset.noiseAmount : 0.0);
                interpolator.setTarget('noiseRate', preset.noiseRate !== undefined ? preset.noiseRate : 0.0);
                interpolator.setTarget('blurAmount', preset.blurAmount !== undefined ? preset.blurAmount : 0.0);
                interpolator.setTarget('blurRate', preset.blurRate !== undefined ? preset.blurRate : 0.0);
                interpolator.setTarget('autoRotationSpeed', preset.autoRotationSpeed);
                
                // Also set direct values for slider updates (they'll sync via interpolator)
                spikiness = interpolator.getCurrent('spikiness') ?? (preset.spikiness !== undefined ? preset.spikiness : 0.5);
                spikeFrequency = interpolator.getCurrent('spikeFrequency') ?? (preset.spikeFrequency !== undefined ? preset.spikeFrequency : 5.0);
                spikeSharpness = interpolator.getCurrent('spikeSharpness') ?? (preset.spikeSharpness !== undefined ? preset.spikeSharpness : 0.0);
                hue = interpolator.getCurrent('hue') ?? preset.hue;
                scale = interpolator.getCurrent('scale') ?? preset.scale;
                hueShiftAmount = interpolator.getCurrent('hueShiftAmount') ?? preset.hueShiftAmount;
                rotation = interpolator.getCurrent('rotation') ?? preset.rotation;
                blendOpacity = interpolator.getCurrent('blendOpacity') ?? preset.blendOpacity;
                fillSize = interpolator.getCurrent('fillSize') ?? (preset.fillSize !== undefined ? preset.fillSize : 0.0);
                fillOpacity = interpolator.getCurrent('fillOpacity') ?? (preset.fillOpacity !== undefined ? preset.fillOpacity : 0.6);
                emanationRate = interpolator.getCurrent('emanationRate') ?? (preset.emanationRate !== undefined ? preset.emanationRate : 2.0);
                noiseAmount = interpolator.getCurrent('noiseAmount') ?? (preset.noiseAmount !== undefined ? preset.noiseAmount : 0.0);
                noiseRate = interpolator.getCurrent('noiseRate') ?? (preset.noiseRate !== undefined ? preset.noiseRate : 0.0);
                blurAmount = interpolator.getCurrent('blurAmount') ?? (preset.blurAmount !== undefined ? preset.blurAmount : 0.0);
                blurRate = interpolator.getCurrent('blurRate') ?? (preset.blurRate !== undefined ? preset.blurRate : 0.0);
                autoRotationSpeed = interpolator.getCurrent('autoRotationSpeed') ?? preset.autoRotationSpeed;
                
                // Handle dilation speed separately (needs slider conversion)
                dilationSpeed = preset.dilationSlider ? (() => {
                    const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                    const range = (1.22 - 0.88) / (1.0 - midPower);
                    const min = 1.0 - midPower * range;
                    return min + Math.pow(parseFloat(preset.dilationSlider) / 200.0, 1.0 / 8.0) * range;
                })() : (interpolator.getCurrent('dilationSpeed') ?? 1.01);
                interpolator.setTarget('dilationSpeed', dilationSpeed);
                
                // Handle fade amount separately (needs slider conversion)
                fadeAmount = preset.fadeSlider ? Math.pow(parseFloat(preset.fadeSlider) / 100.0, 1.0 / 3.0) * 5.0 : (interpolator.getCurrent('fadeAmount') ?? 0.3);
                interpolator.setTarget('fadeAmount', fadeAmount);
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = hue;
                hueValue.textContent = hue + '°';
                scaleSlider.value = scale;
                scaleValue.textContent = scale.toFixed(2);
                dilationSlider.value = preset.dilationSlider || 20;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(parseFloat(dilationSlider.value) / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = preset.fadeSlider || 30;
                fadeAmount = Math.pow(parseFloat(fadeSlider.value) / 100.0, 1.0 / 3.0) * 5.0;
                fadeValue.textContent = fadeAmount.toFixed(3);
                hueShiftSlider.value = hueShiftAmount;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                rotationSlider.value = rotation;
                rotationValue.textContent = rotation + '°';
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                emanationRateSlider.value = emanationRate;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                noiseRateSlider.value = noiseRateToSlider(noiseRate);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                blurAmountSlider.value = blurAmountToSlider(blurAmount);
                blurAmountValue.textContent = blurAmount.toFixed(2);
                blurRateSlider.value = blurRateToSlider(blurRate);
                blurRateValue.textContent = blurRate.toFixed(2);
                // Use stored slider value if available, otherwise reverse map from speed value
                if (preset.autoRotationSlider !== undefined) {
                    autoRotationSlider.value = preset.autoRotationSlider;
                    autoRotationSpeed = -1.0 + Math.pow(preset.autoRotationSlider / 200.0, 0.5) * 361.0;
                } else {
                    // Fallback: reverse map from speed value
                    const sliderValue = Math.round(200 * Math.pow((autoRotationSpeed + 1) / 361.0, 2));
                    autoRotationSlider.value = sliderValue;
                }
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Restore jiggle settings if present
                if (preset.jiggleAmount !== undefined) {
                    jiggleAmount = preset.jiggleAmount;
                    jiggleAmountSlider.value = Math.round(jiggleAmount * 100);
                    jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
                }
                
                if (preset.jiggleEnabledParams) {
                    // Restore enabled params from preset
                    jiggleParamNames.forEach(param => {
                        if (preset.jiggleEnabledParams[param] !== undefined) {
                            jiggleEnabledParams[param] = preset.jiggleEnabledParams[param];
                            const checkbox = document.getElementById(`jiggle-param-${param}`);
                            if (checkbox) checkbox.checked = jiggleEnabledParams[param];
                        }
                    });
                }
                
                // Restore audio mapping config if present
                if (preset.audioMappingConfig && window.setAudioMappingConfig) {
                    // Deep copy to avoid reference issues
                    const restoredConfig = JSON.parse(JSON.stringify(preset.audioMappingConfig));
                    window.setAudioMappingConfig(restoredConfig);
                }
                
                // Restore dilation polarity flip if present
                if (preset.dilationPolarityFlip !== undefined) {
                    const dilationPolarityFlip = document.getElementById('dilation-polarity-flip');
                    if (dilationPolarityFlip) {
                        dilationPolarityFlip.checked = preset.dilationPolarityFlip;
                    }
                }
                
                // Update base values to match loaded preset
                updateBaseValues();
                
                // Update dropdown to show the loaded preset
                presetSelect.value = name;
            }
            
            // Initialize presets dropdown
            loadPresets();
            
            // Try to load last active preset BEFORE initializing default values
            const lastActivePreset = localStorage.getItem('sandboxLastActivePreset');
            let presetLoaded = false;
            if (lastActivePreset) {
                const presets = loadPresets();
                if (presets[lastActivePreset]) {
                    presetSelect.value = lastActivePreset;
                    presetLoaded = true;
                }
            }
            
            // Helper function to map slider value using curve editor
            function mapParamValue(paramName, sliderValue, sliderMax = 100) {
                const settings = window.CurveEditor?.getCurveSettings(paramName);
                if (settings && window.CurveEditor) {
                    // Normalize slider value to 0-100 range
                    const normalized = (sliderValue / sliderMax) * 100;
                    return window.CurveEditor.mapValue(normalized, settings);
                }
                return null; // Will fall back to original mapping
            }
            
            // Helper function to reverse map value to slider using curve editor
            function reverseMapParamValue(paramName, value, sliderMax = 100) {
                const settings = window.CurveEditor?.getCurveSettings(paramName);
                if (settings && window.CurveEditor) {
                    const sliderValue = window.CurveEditor.reverseMapValue(value, settings);
                    // Convert from 0-100 range to actual slider range
                    return (sliderValue / 100.0) * sliderMax;
                }
                return null; // Will fall back to original mapping
            }
            
            // Current values (initialize from sliders, or from preset if one was loaded)
            const initialSpikinessSlider = parseFloat(spikinessSlider.value);
            let spikiness = mapParamValue('spikiness', initialSpikinessSlider) ?? (initialSpikinessSlider / 100.0);
            
            const initialSpikeFrequencySlider = parseFloat(spikeFrequencySlider.value);
            let spikeFrequency = mapParamValue('spikeFrequency', initialSpikeFrequencySlider, 20) ?? initialSpikeFrequencySlider;
            
            const initialSpikeSharpnessSlider = parseFloat(spikeSharpnessSlider.value);
            let spikeSharpness = mapParamValue('spikeSharpness', initialSpikeSharpnessSlider) ?? (initialSpikeSharpnessSlider / 100.0);
            
            const initialHueSlider = parseFloat(hueSlider.value);
            let hue = mapParamValue('hue', initialHueSlider, 360) ?? initialHueSlider;
            
            const initialScaleSlider = parseFloat(scaleSlider.value);
            let scale = mapParamValue('scale', initialScaleSlider, 1.0) ?? initialScaleSlider;
            
            // Initialize dilation speed
            const initialDilationSlider = parseFloat(dilationSlider.value);
            let dilationSpeed = mapParamValue('dilationSpeed', initialDilationSlider, 200);
            if (dilationSpeed === null) {
                // Fallback to original exponential mapping
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(initialDilationSlider / 200.0, 1.0 / 8.0) * range;
            }
            
            // Initialize fade amount
            const initialFadeSlider = parseFloat(fadeSlider.value);
            fadeAmount = mapParamValue('fadeAmount', initialFadeSlider) ?? (Math.pow(initialFadeSlider / 100.0, 1.0 / 3.0) * 5.0);
            
            const initialHueShiftSlider = parseFloat(hueShiftSlider.value);
            let hueShiftAmount = mapParamValue('hueShiftAmount', initialHueShiftSlider, 0.2) ?? initialHueShiftSlider;
            
            const initialRotationSlider = parseFloat(rotationSlider.value);
            let rotation = mapParamValue('rotation', initialRotationSlider, 360) ?? initialRotationSlider;
            
            let blendMode = blendModeSelect.value;
            
            const initialBlendOpacitySlider = parseFloat(blendOpacitySlider.value);
            let blendOpacity = mapParamValue('blendOpacity', initialBlendOpacitySlider, 1.0) ?? initialBlendOpacitySlider;
            
            const initialFillSizeSlider = parseFloat(fillSizeSlider.value);
            let fillSize = mapParamValue('fillSize', initialFillSizeSlider) ?? (initialFillSizeSlider / 100.0);
            
            const initialFillOpacitySlider = parseFloat(fillOpacitySlider.value);
            let fillOpacity = mapParamValue('fillOpacity', initialFillOpacitySlider) ?? (initialFillOpacitySlider / 100.0);
            
            const initialEmanationRateSlider = parseFloat(emanationRateSlider.value);
            let emanationRate = mapParamValue('emanationRate', initialEmanationRateSlider, 200) ?? initialEmanationRateSlider;
            
            // Initialize noise amount with curve editor mapping
            const initialNoiseSlider = parseFloat(noiseAmountSlider.value);
            let noiseAmount = mapParamValue('noiseAmount', initialNoiseSlider) ?? (Math.pow(initialNoiseSlider / 100.0, 1.0 / 4.0));
            
            // Initialize noise rate
            const initialNoiseRateSlider = parseFloat(noiseRateSlider.value);
            let noiseRate = mapParamValue('noiseRate', initialNoiseRateSlider) ?? (Math.pow(initialNoiseRateSlider / 100.0, 1.0 / 3.0) * 10.0);
            
            // Initialize blur amount
            const initialBlurSlider = parseFloat(blurAmountSlider.value);
            let blurAmount = mapParamValue('blurAmount', initialBlurSlider) ?? (Math.pow(initialBlurSlider / 100.0, 1.0 / 4.0));
            
            // Initialize blur rate
            const initialBlurRateSlider = parseFloat(blurRateSlider.value);
            let blurRate = mapParamValue('blurRate', initialBlurRateSlider) ?? (Math.pow(initialBlurRateSlider / 100.0, 1.0 / 3.0) * 10.0);
            
            const initialJiggleAmountSlider = parseFloat(jiggleAmountSlider.value);
            let jiggleAmount = mapParamValue('jiggleAmount', initialJiggleAmountSlider) ?? (initialJiggleAmountSlider / 100.0);
            jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            let jiggleEnabled = false;
            
            // Hotkey / playback state
            let freezeEnabled = false;
            let originalDilationSpeed = dilationSpeed;
            
            // Store base values for jiggle (when jiggle is off, these match current values)
            let baseSpikiness = spikiness;
            let baseSpikeFrequency = spikeFrequency;
            let baseSpikeSharpness = spikeSharpness;
            let baseHue = hue;
            let baseScale = scale;
            let baseFillSize = fillSize;
            let baseFillOpacity = fillOpacity;
            let baseRotation = rotation;
            let baseHueShiftAmount = hueShiftAmount;
            let baseDilationSpeed = dilationSpeed;
            let baseFadeAmount = fadeAmount;
            let baseEmanationRate = emanationRate;
            let baseNoiseAmount = noiseAmount;
            let baseNoiseRate = noiseRate;
            let baseBlurAmount = blurAmount;
            let baseBlurRate = blurRate;
            let baseBlendOpacity = blendOpacity;
            
            // Initialize auto rotation speed
            const initialAutoRotationSlider = parseFloat(autoRotationSlider.value);
            let autoRotationSpeed = mapParamValue('autoRotationSpeed', initialAutoRotationSlider, 200);
            if (autoRotationSpeed === null) {
                // Fallback to original exponential mapping
                autoRotationSpeed = -1.0 + Math.pow(initialAutoRotationSlider / 200.0, 0.5) * 361.0;
            }
            
            // Now initialize baseAutoRotationSpeed after autoRotationSpeed is declared
            let baseAutoRotationSpeed = autoRotationSpeed;
            
            // Initialize all parameters in the interpolator with their initial values
            // This ensures interpolation works from the start
            interpolator.setTarget('spikiness', spikiness, 0); // Instant for initial values
            interpolator.setTarget('spikeFrequency', spikeFrequency, 0);
            interpolator.setTarget('spikeSharpness', spikeSharpness, 0);
            interpolator.setTarget('hue', hue, 0);
            interpolator.setTarget('scale', scale, 0);
            interpolator.setTarget('fillSize', fillSize, 0);
            interpolator.setTarget('fillOpacity', fillOpacity, 0);
            interpolator.setTargetRotation('rotation', rotation, 0); // Use rotation-specific setter
            interpolator.setTarget('hueShiftAmount', hueShiftAmount, 0);
            interpolator.setTarget('dilationSpeed', dilationSpeed, 0);
            interpolator.setTarget('fadeAmount', fadeAmount, 0);
            interpolator.setTarget('emanationRate', emanationRate, 0);
            interpolator.setTarget('autoRotationSpeed', autoRotationSpeed, 0);
            interpolator.setTarget('noiseAmount', noiseAmount, 0);
            interpolator.setTarget('noiseRate', noiseRate, 0);
            interpolator.setTarget('blurAmount', blurAmount, 0);
            interpolator.setTarget('blurRate', blurRate, 0);
            interpolator.setTarget('blendOpacity', blendOpacity, 0);
            
            // Target origins for jiggle when user edits params during jiggle
            // Jiggle will smoothly ease its orbit center toward these targets
            let targetBaseSpikiness = baseSpikiness;
            let targetBaseSpikeFrequency = baseSpikeFrequency;
            let targetBaseSpikeSharpness = baseSpikeSharpness;
            let targetBaseHue = baseHue;
            let targetBaseScale = baseScale;
            let targetBaseFillSize = baseFillSize;
            let targetBaseFillOpacity = baseFillOpacity;
            let targetBaseRotation = baseRotation;
            let targetBaseHueShiftAmount = baseHueShiftAmount;
            let targetBaseDilationSpeed = baseDilationSpeed;
            let targetBaseFadeAmount = baseFadeAmount;
            let targetBaseEmanationRate = baseEmanationRate;
            let targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
            let targetBaseNoiseAmount = baseNoiseAmount;
            let targetBaseNoiseRate = baseNoiseRate;
            let targetBaseBlurAmount = baseBlurAmount;
            let targetBaseBlurRate = baseBlurRate;
            let targetBaseBlendOpacity = baseBlendOpacity;
            
            // Now load the preset if one was found (this will override the default values)
            if (presetLoaded) {
                loadPreset(lastActivePreset);
            } else {
                // If no preset loaded, initialize status indicators
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
        
            // Helper function to handle editable value changes
            // Direct input bypasses clamping - allows any value
            function handleValueEdit(valueElement, parseFn, formatFn, updateFn) {
                valueElement.addEventListener('blur', (e) => {
                    const text = e.target.textContent.trim();
                    const numValue = parseFn(text);
                    if (!isNaN(numValue)) {
                        // No clamping - accept the value as-is
                        const formatted = formatFn(numValue);
                        e.target.textContent = formatted;
                        updateFn(numValue);
                    } else {
                        // Restore previous value on invalid input
                        const currentValue = parseFn(e.target.textContent);
                        if (!isNaN(currentValue)) {
                            e.target.textContent = formatFn(currentValue);
                        }
                    }
                });
                
                valueElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    }
                });
            }
            
            // Update sliders
            spikinessSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('spikiness', sliderValue) ?? (sliderValue / 100.0);
                interpolator.setTarget('spikiness', targetValue);
                spikiness = targetValue; // Update direct value for display
                spikinessValue.textContent = targetValue.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikinessValue, 
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    interpolator.setTarget('spikiness', val);
                    spikiness = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikiness');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikinessSlider.value = reverseMapParamValue('spikiness', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        spikinessSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            spikeFrequencySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('spikeFrequency', sliderValue, 20) ?? sliderValue;
                interpolator.setTarget('spikeFrequency', targetValue);
                spikeFrequency = targetValue;
                spikeFrequencyValue.textContent = targetValue.toFixed(1);
                updateBaseValues();
            });
            
            handleValueEdit(spikeFrequencyValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    interpolator.setTarget('spikeFrequency', val);
                    spikeFrequency = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikeFrequency');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikeFrequencySlider.value = reverseMapParamValue('spikeFrequency', clampedForDisplay, 20) ?? clampedForDisplay;
                    } else {
                        const clampedForSlider = Math.max(2, Math.min(20, val));
                        spikeFrequencySlider.value = clampedForSlider;
                    }
                    updateBaseValues();
                }
            );
            
            spikeSharpnessSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('spikeSharpness', sliderValue) ?? (sliderValue / 100.0);
                interpolator.setTarget('spikeSharpness', targetValue);
                spikeSharpness = targetValue;
                spikeSharpnessValue.textContent = targetValue.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikeSharpnessValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    interpolator.setTarget('spikeSharpness', val);
                    spikeSharpness = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikeSharpness');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikeSharpnessSlider.value = reverseMapParamValue('spikeSharpness', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        spikeSharpnessSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            hueSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('hue', sliderValue, 360) ?? sliderValue;
                interpolator.setTarget('hue', targetValue);
                hue = targetValue;
                hueValue.textContent = Math.round(targetValue) + '°';
                updateBaseValues();
            });
            
            handleValueEdit(hueValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    interpolator.setTarget('hue', val);
                    hue = val;
                    const settings = window.CurveEditor?.getCurveSettings('hue');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        hueSlider.value = reverseMapParamValue('hue', clampedForDisplay, 360) ?? Math.round(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(360, val));
                        hueSlider.value = Math.round(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            scaleSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetValue = mapParamValue('scale', sliderValue, 1.0) ?? sliderValue;
                interpolator.setTarget('scale', targetValue);
                scale = targetValue;
                scaleValue.textContent = targetValue.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(scaleValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    interpolator.setTarget('scale', val);
                    scale = val;
                    const settings = window.CurveEditor?.getCurveSettings('scale');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        const sliderVal = reverseMapParamValue('scale', clampedForDisplay, 1.0) ?? clampedForDisplay;
                        scaleSlider.value = sliderVal.toFixed(2);
                        scaleValue.textContent = clampedForDisplay.toFixed(2);
                    } else {
                        const clampedForSlider = Math.max(0.05, Math.min(1.0, val));
                        scaleSlider.value = clampedForSlider.toFixed(2);
                        scaleValue.textContent = clampedForSlider.toFixed(2);
                    }
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map dilation speed to slider value
            function dilationSpeedToSlider(speed) {
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                // Reverse: speed = min + (slider/200)^(1/8) * range
                // slider = 200 * ((speed - min) / range)^8
                const normalized = (speed - min) / range;
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
            }
            
            dilationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                dilationSpeed = mapParamValue('dilationSpeed', sliderValue, 200);
                if (dilationSpeed === null) {
                    // Fallback to original exponential mapping
                    const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                    const range = (1.22 - 0.88) / (1.0 - midPower);
                    const min = 1.0 - midPower * range;
                    dilationSpeed = min + Math.pow(sliderValue / 200.0, 1.0 / 8.0) * range;
                }
                dilationValue.textContent = dilationSpeed.toFixed(4);
            });
            
            handleValueEdit(dilationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(4),
                (val) => {
                    dilationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0.88, Math.min(1.22, val));
                    dilationSlider.value = dilationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map fade amount to slider value
            function fadeAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/3) * 5.0
                // slider = 100 * (amount / 5.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount / 5.0)), 3));
            }
            
            fadeSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fadeAmount = mapParamValue('fadeAmount', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 5.0);
                fadeValue.textContent = fadeAmount.toFixed(3);
            });
            
            handleValueEdit(fadeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    fadeAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(5.0, val));
                    fadeSlider.value = fadeAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            hueShiftSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                hueShiftAmount = mapParamValue('hueShiftAmount', sliderValue, 0.2) ?? sliderValue;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                updateBaseValues();
            });
            
            handleValueEdit(hueShiftValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    hueShiftAmount = val;
                    const settings = window.CurveEditor?.getCurveSettings('hueShiftAmount');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        hueShiftSlider.value = reverseMapParamValue('hueShiftAmount', clampedForDisplay, 0.2) ?? clampedForDisplay.toFixed(3);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(0.2, val));
                        hueShiftSlider.value = clampedForSlider.toFixed(3);
                    }
                    updateBaseValues();
                }
            );
            
            rotationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                const targetRotation = mapParamValue('rotation', sliderValue, 360) ?? sliderValue;
                interpolator.setTargetRotation('rotation', targetRotation);
                rotation = targetRotation; // Update direct value for display
                rotationValue.textContent = Math.round(targetRotation) + '°';
                updateBaseValues();
            });
            
            handleValueEdit(rotationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    interpolator.setTargetRotation('rotation', val);
                    rotation = val;
                    const settings = window.CurveEditor?.getCurveSettings('rotation');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        rotationSlider.value = reverseMapParamValue('rotation', clampedForDisplay, 360) ?? Math.round(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(360, val));
                        rotationSlider.value = Math.round(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            blendModeSelect.addEventListener('change', (e) => {
                blendMode = e.target.value;
                updateStatusIndicators();
            });
            
            blendOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blendOpacity = mapParamValue('blendOpacity', sliderValue, 1.0) ?? sliderValue;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blendOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blendOpacity = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blendOpacitySlider.value = clampedForSlider.toFixed(2);
                    updateBaseValues();
                }
            );
            
            fillSizeSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fillSize = mapParamValue('fillSize', sliderValue) ?? (sliderValue / 100.0);
                fillSizeValue.textContent = fillSize.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillSizeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillSize = val;
                    const settings = window.CurveEditor?.getCurveSettings('fillSize');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        fillSizeSlider.value = reverseMapParamValue('fillSize', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        fillSizeSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            fillOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fillOpacity = mapParamValue('fillOpacity', sliderValue) ?? (sliderValue / 100.0);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillOpacity = val;
                    const settings = window.CurveEditor?.getCurveSettings('fillOpacity');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        fillOpacitySlider.value = reverseMapParamValue('fillOpacity', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        fillOpacitySlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            emanationRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                emanationRate = mapParamValue('emanationRate', sliderValue, 200) ?? sliderValue;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                updateStatusIndicators();
            });
            
            handleValueEdit(emanationRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    emanationRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(2, Math.min(200, val));
                    emanationRateSlider.value = clampedForSlider;
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map noise amount to slider value
            function noiseAmountToSlider(amount) {
                // Use curve editor reverse mapping if available
                const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                if (settings && window.CurveEditor) {
                    return window.CurveEditor.reverseMapValue(amount, settings);
                }
                // Fallback to default exponential mapping
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount)), 4));
            }
            
            // Noise amount slider with curve editor mapping
            noiseAmountSlider.addEventListener('input', (e) => {
                // Map slider value (0-100) to noise amount using curve editor
                const sliderValue = parseFloat(e.target.value);
                const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                if (settings && window.CurveEditor) {
                    noiseAmount = window.CurveEditor.mapValue(sliderValue, settings);
                } else {
                    // Fallback to default exponential mapping
                    noiseAmount = Math.pow(sliderValue / 100.0, 1.0 / 4.0);
                }
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(noiseAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    noiseAmount = val;
                    // Update slider position using curve editor reverse mapping
                    // This will clamp the slider display to the curve's min/max range
                    const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        noiseAmountSlider.value = noiseAmountToSlider(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        noiseAmountSlider.value = noiseAmountToSlider(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map noise rate to slider value (slow exponential curve)
            function noiseRateToSlider(rate) {
                // Map rate (0-10) to slider (0-100) with exponential curve
                // rate = (slider / 100)^(1/3) * 10.0
                // slider = 100 * (rate / 10.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, rate / 10.0)), 3) * 10) / 10; // Round to 0.1
            }
            
            // Noise rate slider (0-100 slider maps to 0-10 rate with slow exponential curve, where 1.0 = every 2 seconds)
            noiseRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                noiseRate = mapParamValue('noiseRate', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 10.0);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(noiseRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    noiseRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(10, val));
                    noiseRateSlider.value = noiseRateToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Blur amount slider
            // Helper function to reverse-map blur amount to slider value
            function blurAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/4)
                // slider = 100 * amount^4
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount)), 4));
            }
            
            // Blur amount slider with exponential mapping (0-100 slider to 0-1, granular near 0)
            blurAmountSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blurAmount = mapParamValue('blurAmount', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 4.0));
                blurAmountValue.textContent = blurAmount.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blurAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blurAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blurAmountSlider.value = blurAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map blur rate to slider value (slow exponential curve)
            function blurRateToSlider(rate) {
                // Map rate (0-10) to slider (0-100) with exponential curve
                // rate = (slider / 100)^(1/3) * 10.0
                // slider = 100 * (rate / 10.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, rate / 10.0)), 3) * 10) / 10; // Round to 0.1
            }
            
            // Blur rate slider (0-100 slider maps to 0-10 rate with slow exponential curve, where 1.0 = every 2 seconds)
            blurRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blurRate = mapParamValue('blurRate', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 10.0);
                blurRateValue.textContent = blurRate.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blurRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blurRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(10, val));
                    blurRateSlider.value = blurRateToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map auto rotation speed to slider value
            function autoRotationSpeedToSlider(speed) {
                // Reverse: speed = -1 + (slider/200)^0.5 * 361
                // slider = 200 * ((speed + 1) / 361)^2
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, (speed + 1) / 361.0)), 2));
            }
            
            autoRotationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                let targetSpeed = mapParamValue('autoRotationSpeed', sliderValue, 200);
                if (targetSpeed === null) {
                    // Fallback to original exponential mapping
                    targetSpeed = -1.0 + Math.pow(sliderValue / 200.0, 0.5) * 361.0;
                }
                interpolator.setTarget('autoRotationSpeed', targetSpeed);
                autoRotationSpeed = targetSpeed; // Update direct value for display
                autoRotationValue.textContent = targetSpeed.toFixed(1) + '°';
                updateStatusIndicators();
            });
            
            handleValueEdit(autoRotationValue,
                (text) => parseFloat(text.replace(/[^0-9.-]/g, '')),
                (val) => val.toFixed(1) + '°',
                (val) => {
                    autoRotationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(-1, Math.min(360, val));
                    autoRotationSlider.value = autoRotationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Wire up curve editor buttons
            document.querySelectorAll('.curve-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paramName = btn.getAttribute('data-param');
                    if (paramName && window.CurveEditor) {
                        window.CurveEditor.open(paramName);
                    }
                });
            });
            
            // Save current state as preset
            function savePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please enter a preset name');
                    return;
                }
                
                // Get audio mapping config if available
                const audioMappingConfig = window.getAudioMappingConfig ? window.getAudioMappingConfig() : {};
                
                // Get dilation polarity flip setting
                const dilationPolarityFlip = document.getElementById('dilation-polarity-flip');
                const dilationPolarityFlipValue = dilationPolarityFlip ? dilationPolarityFlip.checked : false;
                
                const preset = {
                    spikiness: spikiness,
                    spikeFrequency: spikeFrequency,
                    spikeSharpness: spikeSharpness,
                    hue: hue,
                    scale: scale,
                    fillSize: fillSize,
                    fillOpacity: fillOpacity,
                    dilationSlider: parseFloat(dilationSlider.value), // Store slider value for proper restoration
                    fadeSlider: parseFloat(fadeSlider.value), // Store slider value for proper restoration
                    hueShiftAmount: hueShiftAmount,
                    rotation: rotation,
                    blendMode: blendMode,
                    blendOpacity: blendOpacity,
                    emanationRate: emanationRate,
                    noiseAmount: noiseAmount,
                    noiseRate: noiseRate,
                    blurAmount: blurAmount,
                    blurRate: blurRate,
                    autoRotationSpeed: autoRotationSpeed, // Store actual value (will reverse map to slider on load)
                    autoRotationSlider: parseFloat(autoRotationSlider.value), // Also store slider for easier restoration
                    jiggleAmount: jiggleAmount, // Store jiggle amount
                    jiggleEnabledParams: { ...jiggleEnabledParams }, // Store jiggle enabled params (copy object)
                    audioMappingConfig: JSON.parse(JSON.stringify(audioMappingConfig)), // Deep copy audio mapping config
                    dilationPolarityFlip: dilationPolarityFlipValue // Store dilation polarity flip setting
                };
                
                const presets = loadPresets();
                presets[name] = preset;
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                updatePresetNames(); // Update preset names list for cycling
                presetNameInput.value = '';
                alert(`Preset "${name}" saved!`);
            }
            
            // Delete preset
            function deletePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please select a preset to delete');
                    return;
                }
                
                if (!confirm(`Delete preset "${name}"?`)) {
                    return;
                }
                
                const presets = loadPresets();
                delete presets[name];
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetSelect.value = '';
            }
            
            // Event listeners
            presetSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadPreset(e.target.value);
                    localStorage.setItem('sandboxLastActivePreset', e.target.value);
                    updatePresetNames(); // Update preset names list for cycling
                }
            });
            
            savePresetBtn.addEventListener('click', () => {
                const presetName = presetNameInput.value.trim();
                savePreset(presetName);
                if (presetName) {
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                    presetSelect.value = presetName;
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            deletePresetBtn.addEventListener('click', () => {
                const presetToDelete = presetSelect.value;
                deletePreset(presetToDelete);
                if (localStorage.getItem('sandboxLastActivePreset') === presetToDelete) {
                    localStorage.removeItem('sandboxLastActivePreset');
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            // Export presets to JSON file
            exportPresetsBtn.addEventListener('click', () => {
                const presets = loadPresets();
                const jsonString = JSON.stringify(presets, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sandbox-presets.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(`Exported ${Object.keys(presets).length} preset(s) to sandbox-presets.json`);
            });
            
            // Import presets from JSON file
            importPresetsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        
                        if (typeof importedPresets !== 'object' || Array.isArray(importedPresets)) {
                            alert('Invalid preset file format. Expected an object with preset names as keys.');
                            return;
                        }
                        
                        // Load current presets
                        const currentPresets = loadPresets();
                        
                        // Merge imported presets with current presets (imported presets take precedence for conflicts)
                        let importedCount = 0;
                        let overwrittenCount = 0;
                        for (const [name, preset] of Object.entries(importedPresets)) {
                            if (currentPresets[name]) {
                                overwrittenCount++;
                            } else {
                                importedCount++;
                            }
                            currentPresets[name] = preset;
                        }
                        
                        // Save merged presets
                        localStorage.setItem('sandboxPresets', JSON.stringify(currentPresets));
                        loadPresets();
                        
                        // Update preset names list for hotkeys (if updatePresetNames is defined)
                        if (typeof updatePresetNames === 'function') {
                            updatePresetNames();
                        }
                        
                        // Reset file input
                        e.target.value = '';
                        
                        const message = `Imported ${importedCount} new preset(s)${overwrittenCount > 0 ? ` and overwrote ${overwrittenCount} existing preset(s)` : ''}.`;
                        alert(message);
                    } catch (error) {
                        alert(`Error importing presets: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            });
            
            // Randomize function
            function randomizeAll() {
                // Randomize all parameters within their valid ranges
                
                // Shape parameters
                spikiness = Math.random();
                spikeFrequency = 2 + Math.random() * 18; // 2-20
                spikeSharpness = Math.random();
                hue = Math.random() * 360;
                scale = 0.05 + Math.random() * 0.95; // 0.05-1.0
                fillSize = Math.random();
                fillOpacity = Math.random();
                rotation = Math.random() * 360;
                hueShiftAmount = Math.random() * 0.2; // 0-0.2
                
                // Blend parameters
                const blendModes = ['additive', 'alpha', 'multiply', 'screen', 'overlay'];
                blendMode = blendModes[Math.floor(Math.random() * blendModes.length)];
                blendOpacity = Math.random();
                
                // Emanation parameters
                // Dilation speed: 0.88-1.22 (use slider range 0-200, map to actual value)
                const randomDilationSlider = Math.random() * 200;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(randomDilationSlider / 200.0, 1.0 / 8.0) * range;
                
                // Fade amount: 0-5.0 (use slider range 0-100, map to actual value)
                const randomFadeSlider = Math.random() * 100;
                fadeAmount = Math.pow(randomFadeSlider / 100.0, 1.0 / 3.0) * 5.0;
                
                // Emanation rate: 2-200
                emanationRate = 2 + Math.random() * 198;
                
                // Filter parameters
                noiseAmount = Math.random(); // 0-1
                noiseRate = Math.random() * 10.0; // 0-10 (time-based: interval = 2.0 / rate)
                blurAmount = Math.random(); // 0-1
                blurRate = Math.random() * 10.0; // 0-10 (time-based: interval = 2.0 / rate)
                
                // Auto rotation speed: -1 to 360 (use slider range 0-200, map to actual value)
                const randomAutoRotationSlider = Math.random() * 200;
                autoRotationSpeed = -1.0 + Math.pow(randomAutoRotationSlider / 200.0, 0.5) * 361.0;
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = Math.round(hue);
                hueValue.textContent = Math.round(hue) + '°';
                scaleSlider.value = scale.toFixed(2);
                scaleValue.textContent = scale.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                rotationSlider.value = Math.round(rotation);
                rotationValue.textContent = Math.round(rotation) + '°';
                hueShiftSlider.value = hueShiftAmount.toFixed(3);
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                
                // Update blend controls
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity.toFixed(2);
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                
                // Update emanation controls
                dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = fadeAmountToSlider(fadeAmount);
                fadeValue.textContent = fadeAmount.toFixed(3);
                emanationRateSlider.value = emanationRate.toFixed(1);
                emanationRateValue.textContent = emanationRate.toFixed(1);
                
                // Update filter controls
                noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                noiseRateSlider.value = noiseRateToSlider(noiseRate);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                blurAmountSlider.value = blurAmountToSlider(blurAmount);
                blurAmountValue.textContent = blurAmount.toFixed(2);
                blurRateSlider.value = blurRateToSlider(blurRate);
                blurRateValue.textContent = blurRate.toFixed(2);
                
                // Update auto rotation
                autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Update base values
                baseSpikiness = spikiness;
                baseSpikeFrequency = spikeFrequency;
                baseSpikeSharpness = spikeSharpness;
                baseHue = hue;
                baseScale = scale;
                baseFillSize = fillSize;
                baseFillOpacity = fillOpacity;
                baseRotation = rotation;
                baseHueShiftAmount = hueShiftAmount;
                baseDilationSpeed = dilationSpeed;
                baseFadeAmount = fadeAmount;
                baseEmanationRate = emanationRate;
                baseAutoRotationSpeed = autoRotationSpeed;
                baseNoiseAmount = noiseAmount;
                baseNoiseRate = noiseRate;
                baseBlurAmount = blurAmount;
                baseBlurRate = blurRate;
                baseBlendOpacity = blendOpacity;
                
                // Update target bases to match
                targetBaseSpikiness = baseSpikiness;
                targetBaseSpikeFrequency = baseSpikeFrequency;
                targetBaseSpikeSharpness = baseSpikeSharpness;
                targetBaseHue = baseHue;
                targetBaseScale = baseScale;
                targetBaseFillSize = baseFillSize;
                targetBaseFillOpacity = baseFillOpacity;
                targetBaseRotation = baseRotation;
                targetBaseHueShiftAmount = baseHueShiftAmount;
                targetBaseDilationSpeed = baseDilationSpeed;
                targetBaseFadeAmount = baseFadeAmount;
                targetBaseEmanationRate = baseEmanationRate;
                targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                targetBaseNoiseAmount = baseNoiseAmount;
                targetBaseNoiseRate = baseNoiseRate;
                targetBaseBlurAmount = baseBlurAmount;
                targetBaseBlurRate = baseBlurRate;
                targetBaseBlendOpacity = baseBlendOpacity;
            }
            
            // Resolution controls
            function updateResolution(resolutionKey) {
                currentResolution = resolutionKey;
                const res = RESOLUTIONS[resolutionKey];
                
                // Update URL without page reload
                const url = new URL(window.location);
                if (resolutionKey === 'window') {
                    url.searchParams.delete('resolution');
                } else {
                    url.searchParams.set('resolution', resolutionKey);
                }
                window.history.replaceState({}, '', url);
                
                // Update UI
                document.querySelectorAll('.resolution-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-resolution="${resolutionKey}"]`).classList.add('active');
                
                // Update display
                const display = document.getElementById('current-resolution-display');
                if (res.width && res.height) {
                    display.textContent = `Current: ${res.name} (${res.width}×${res.height})`;
                } else {
                    display.textContent = `Current: ${res.name}`;
                }
                
                // Resize canvas
                renderer.resize();
            }
            
            // Set initial active button
            document.querySelector(`[data-resolution="${currentResolution}"]`).classList.add('active');
            updateResolution(currentResolution); // Update display
            
            // Resolution button event listeners
            document.querySelectorAll('.resolution-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const resolution = e.target.dataset.resolution;
                    updateResolution(resolution);
                });
            });
            
            randomizeBtn.addEventListener('click', randomizeAll);
            
            // Jiggle functionality
            jiggleAmountSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                jiggleAmount = mapParamValue('jiggleAmount', sliderValue) ?? (sliderValue / 100.0);
                jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            });
            
            handleValueEdit(jiggleAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')) / 100.0, // Convert percentage to 0-1
                (val) => Math.round(val * 100) + '%',
                (val) => {
                    jiggleAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    jiggleAmountSlider.value = Math.round(clampedForSlider * 100);
                }
            );
            
            jiggleBtn.addEventListener('click', () => {
                jiggleEnabled = !jiggleEnabled;
                jiggleBtn.textContent = jiggleEnabled ? 'Stop Jiggle' : 'Jiggle';
                jiggleBtn.style.background = jiggleEnabled ? '#a00' : '#a0a';
                
                if (!jiggleEnabled) {
                    // Keep current jiggled values and update base values to match
                    // This way the values persist when jiggle is turned off
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    // Targets match new bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                    
                    // Sync interpolator targets to current values so interpolation continues smoothly
                    interpolator.setTarget('spikiness', spikiness, 0); // Instant sync
                    interpolator.setTarget('spikeFrequency', spikeFrequency, 0);
                    interpolator.setTarget('spikeSharpness', spikeSharpness, 0);
                    interpolator.setTarget('hue', hue, 0);
                    interpolator.setTarget('scale', scale, 0);
                    interpolator.setTarget('fillSize', fillSize, 0);
                    interpolator.setTarget('fillOpacity', fillOpacity, 0);
                    interpolator.setTargetRotation('rotation', rotation, 0);
                    interpolator.setTarget('hueShiftAmount', hueShiftAmount, 0);
                    interpolator.setTarget('dilationSpeed', dilationSpeed, 0);
                    interpolator.setTarget('fadeAmount', fadeAmount, 0);
                    interpolator.setTarget('emanationRate', emanationRate, 0);
                    interpolator.setTarget('autoRotationSpeed', autoRotationSpeed, 0);
                    interpolator.setTarget('noiseAmount', noiseAmount, 0);
                    interpolator.setTarget('noiseRate', noiseRate, 0);
                    interpolator.setTarget('blurAmount', blurAmount, 0);
                    interpolator.setTarget('blurRate', blurRate, 0);
                    interpolator.setTarget('blendOpacity', blendOpacity, 0);
                    
                    // Update sliders to reflect current values (they should already match, but ensure sync)
                    spikinessSlider.value = Math.round(spikiness * 100);
                    spikeFrequencySlider.value = spikeFrequency;
                    spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                    hueSlider.value = Math.round(hue);
                    scaleSlider.value = scale.toFixed(2);
                    fillSizeSlider.value = Math.round(fillSize * 100);
                    fillOpacitySlider.value = Math.round(fillOpacity * 100);
                    rotationSlider.value = Math.round(rotation);
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                    fadeSlider.value = fadeAmountToSlider(fadeAmount);
                    emanationRateSlider.value = emanationRate.toFixed(1);
                    autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                    noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                    noiseRateSlider.value = noiseRateToSlider(noiseRate);
                    blurAmountSlider.value = blurAmountToSlider(blurAmount);
                    blurRateSlider.value = blurRateToSlider(blurRate);
                    blendOpacitySlider.value = blendOpacity.toFixed(2);
                    
                    // Update status indicators (unsaved state may have changed)
                    updateStatusIndicators();
                } else {
                    // Store current values as base when starting jiggle
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    // Targets start at current bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                }
                
                // Update jiggle indicator
                updateStatusIndicators();
            });
            
            // Update base values when sliders change
            function updateBaseValues() {
                if (!jiggleEnabled) {
                    // When jiggle is off, bases track current values directly
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                } else {
                    // When jiggle is on, treat current values as new desired origins
                    // Jiggle will smoothly ease its orbit center toward these targets
                    targetBaseSpikiness = spikiness;
                    targetBaseSpikeFrequency = spikeFrequency;
                    targetBaseSpikeSharpness = spikeSharpness;
                    targetBaseHue = hue;
                    targetBaseScale = scale;
                    targetBaseFillSize = fillSize;
                    targetBaseFillOpacity = fillOpacity;
                    targetBaseRotation = rotation;
                    targetBaseHueShiftAmount = hueShiftAmount;
                    targetBaseDilationSpeed = dilationSpeed;
                    targetBaseFadeAmount = fadeAmount;
                    targetBaseEmanationRate = emanationRate;
                    targetBaseAutoRotationSpeed = autoRotationSpeed;
                    targetBaseNoiseAmount = noiseAmount;
                    targetBaseNoiseRate = noiseRate;
                    targetBaseBlurAmount = blurAmount;
                    targetBaseBlurRate = blurRate;
                    targetBaseBlendOpacity = blendOpacity;
                }
                // Update status indicators to check for unsaved changes
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
            
            let startTime = Date.now();
            let lastCaptureTime = 0;
            const TARGET_FPS = 60;
            const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
            
            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;
                
                // Update interpolation system (only if enabled and jiggle is off)
                // When jiggle is enabled, it bypasses interpolation and sets values directly
                const interpolationActive = interpolator.enabled && !jiggleEnabled;
                if (interpolationActive) {
                    interpolator.update();
                }
                
                // Get values for rendering
                // When jiggle is enabled OR interpolation is disabled, use direct values
                // When jiggle is off AND interpolation is enabled, use interpolated values
                let interpolatedRotation, interpolatedAutoRotationSpeed, interpolatedHueShiftAmount;
                let interpolatedDilationSpeed, interpolatedEmanationRate, interpolatedNoiseAmount;
                let interpolatedNoiseRate, interpolatedBlurAmount, interpolatedBlurRate;
                let interpolatedSpikiness, interpolatedSpikeFrequency, interpolatedSpikeSharpness;
                let interpolatedHue, interpolatedScale, interpolatedFillSize;
                let interpolatedFillOpacity, interpolatedFadeAmount, interpolatedBlendOpacity;
                
                if (interpolationActive) {
                    // Use interpolated values when interpolation is enabled and jiggle is off
                    interpolatedRotation = interpolator.getCurrent('rotation') ?? rotation;
                    interpolatedAutoRotationSpeed = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                    interpolatedHueShiftAmount = interpolator.getCurrent('hueShiftAmount') ?? hueShiftAmount;
                    interpolatedDilationSpeed = interpolator.getCurrent('dilationSpeed') ?? dilationSpeed;
                    interpolatedEmanationRate = interpolator.getCurrent('emanationRate') ?? emanationRate;
                    interpolatedNoiseAmount = interpolator.getCurrent('noiseAmount') ?? noiseAmount;
                    interpolatedNoiseRate = interpolator.getCurrent('noiseRate') ?? noiseRate;
                    interpolatedBlurAmount = interpolator.getCurrent('blurAmount') ?? blurAmount;
                    interpolatedBlurRate = interpolator.getCurrent('blurRate') ?? blurRate;
                    interpolatedSpikiness = interpolator.getCurrent('spikiness') ?? spikiness;
                    interpolatedSpikeFrequency = interpolator.getCurrent('spikeFrequency') ?? spikeFrequency;
                    interpolatedSpikeSharpness = interpolator.getCurrent('spikeSharpness') ?? spikeSharpness;
                    interpolatedHue = interpolator.getCurrent('hue') ?? hue;
                    interpolatedScale = interpolator.getCurrent('scale') ?? scale;
                    interpolatedFillSize = interpolator.getCurrent('fillSize') ?? fillSize;
                    interpolatedFillOpacity = interpolator.getCurrent('fillOpacity') ?? fillOpacity;
                    interpolatedFadeAmount = interpolator.getCurrent('fadeAmount') ?? fadeAmount;
                    interpolatedBlendOpacity = interpolator.getCurrent('blendOpacity') ?? blendOpacity;
                    
                    // When interpolation is active, use interpolated values as the base for audio offsets
                    // Copy interpolated values to direct values so audio offsets can modify them
                    rotation = interpolatedRotation;
                    autoRotationSpeed = interpolatedAutoRotationSpeed;
                    hueShiftAmount = interpolatedHueShiftAmount;
                    dilationSpeed = interpolatedDilationSpeed;
                    emanationRate = interpolatedEmanationRate;
                    noiseAmount = interpolatedNoiseAmount;
                    noiseRate = interpolatedNoiseRate;
                    blurAmount = interpolatedBlurAmount;
                    blurRate = interpolatedBlurRate;
                    spikiness = interpolatedSpikiness;
                    spikeFrequency = interpolatedSpikeFrequency;
                    spikeSharpness = interpolatedSpikeSharpness;
                    hue = interpolatedHue;
                    scale = interpolatedScale;
                    fillSize = interpolatedFillSize;
                    fillOpacity = interpolatedFillOpacity;
                    fadeAmount = interpolatedFadeAmount;
                    blendOpacity = interpolatedBlendOpacity;
                } else {
                    // Use direct values when jiggle is active OR interpolation is disabled
                    interpolatedRotation = rotation;
                    interpolatedAutoRotationSpeed = autoRotationSpeed;
                    interpolatedHueShiftAmount = hueShiftAmount;
                    interpolatedDilationSpeed = dilationSpeed;
                    interpolatedEmanationRate = emanationRate;
                    interpolatedNoiseAmount = noiseAmount;
                    interpolatedNoiseRate = noiseRate;
                    interpolatedBlurAmount = blurAmount;
                    interpolatedBlurRate = blurRate;
                    interpolatedSpikiness = spikiness;
                    interpolatedSpikeFrequency = spikeFrequency;
                    interpolatedSpikeSharpness = spikeSharpness;
                    interpolatedHue = hue;
                    interpolatedScale = scale;
                    interpolatedFillSize = fillSize;
                    interpolatedFillOpacity = fillOpacity;
                    interpolatedFadeAmount = fadeAmount;
                    interpolatedBlendOpacity = blendOpacity;
                }
                
                // Apply jiggle if enabled
                if (jiggleEnabled && jiggleAmount > 0) {
                    // Ease bases toward targets so jiggle orbits move smoothly when user edits params
                    const originLerp = 0.1;
                    baseSpikiness += (targetBaseSpikiness - baseSpikiness) * originLerp;
                    baseSpikeFrequency += (targetBaseSpikeFrequency - baseSpikeFrequency) * originLerp;
                    baseSpikeSharpness += (targetBaseSpikeSharpness - baseSpikeSharpness) * originLerp;
                    baseHue += (targetBaseHue - baseHue) * originLerp;
                    baseScale += (targetBaseScale - baseScale) * originLerp;
                    baseFillSize += (targetBaseFillSize - baseFillSize) * originLerp;
                    baseFillOpacity += (targetBaseFillOpacity - baseFillOpacity) * originLerp;
                    baseRotation += (targetBaseRotation - baseRotation) * originLerp;
                    baseHueShiftAmount += (targetBaseHueShiftAmount - baseHueShiftAmount) * originLerp;
                    baseDilationSpeed += (targetBaseDilationSpeed - baseDilationSpeed) * originLerp;
                    baseFadeAmount += (targetBaseFadeAmount - baseFadeAmount) * originLerp;
                    baseEmanationRate += (targetBaseEmanationRate - baseEmanationRate) * originLerp;
                    baseAutoRotationSpeed += (targetBaseAutoRotationSpeed - baseAutoRotationSpeed) * originLerp;
                    baseNoiseAmount += (targetBaseNoiseAmount - baseNoiseAmount) * originLerp;
                    baseNoiseRate += (targetBaseNoiseRate - baseNoiseRate) * originLerp;
                    baseBlurAmount += (targetBaseBlurAmount - baseBlurAmount) * originLerp;
                    baseBlurRate += (targetBaseBlurRate - baseBlurRate) * originLerp;
                    baseBlendOpacity += (targetBaseBlendOpacity - baseBlendOpacity) * originLerp;
                    
                    // Use time-based seed for smooth jiggle
                    const seed = currentTime * 2.0; // Speed of jiggle
                    
                    // Apply random offsets to each parameter based on jiggle amount
                    // Using sin/cos with different frequencies for each parameter for smooth variation
                    // Only apply jiggle if the parameter is enabled in jiggleEnabledParams
                    
                    if (jiggleEnabledParams.spikiness) {
                        spikiness = baseSpikiness + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        spikiness = Math.max(0, Math.min(1, spikiness));
                    }
                    
                    if (jiggleEnabledParams.spikeFrequency) {
                        spikeFrequency = baseSpikeFrequency + (Math.sin(seed * 1.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 9.0; // ±9 range
                        spikeFrequency = Math.max(2, Math.min(20, spikeFrequency));
                    }
                    
                    if (jiggleEnabledParams.spikeSharpness) {
                        spikeSharpness = baseSpikeSharpness + (Math.sin(seed * 1.1) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        spikeSharpness = Math.max(0, Math.min(1, spikeSharpness));
                    }
                    
                    if (jiggleEnabledParams.hue) {
                        hue = baseHue + (Math.sin(seed * 0.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 180.0; // ±180 range
                        hue = ((hue % 360) + 360) % 360; // Wrap around
                    }
                    
                    if (jiggleEnabledParams.scale) {
                        scale = baseScale + (Math.sin(seed * 1.5) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.3; // ±0.3 range
                        scale = Math.max(0.05, Math.min(1.0, scale));
                    }
                    
                    if (jiggleEnabledParams.fillSize) {
                        fillSize = baseFillSize + (Math.sin(seed * 1.2) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        fillSize = Math.max(0, Math.min(1, fillSize));
                    }
                    
                    if (jiggleEnabledParams.fillOpacity) {
                        fillOpacity = baseFillOpacity + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                        fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                    }
                    
                    // Manual rotation does not jiggle; keep rotation from user / auto-rotation
                    
                    if (jiggleEnabledParams.hueShiftAmount) {
                        hueShiftAmount = baseHueShiftAmount + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1; // ±0.1 range
                        hueShiftAmount = Math.max(0, Math.min(0.2, hueShiftAmount));
                    }
                    
                    if (jiggleEnabledParams.dilationSpeed) {
                        // Dilation speed: jiggle around base, range ~0.88-1.22, so use ±0.1 range
                        dilationSpeed = baseDilationSpeed + (Math.sin(seed * 0.9) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1;
                        dilationSpeed = Math.max(0.88, Math.min(1.22, dilationSpeed));
                    }
                    
                    if (jiggleEnabledParams.fadeAmount) {
                        // Fade amount: jiggle around base, range 0-5, so use ±1.0 range
                        fadeAmount = baseFadeAmount + (Math.sin(seed * 1.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 1.0;
                        fadeAmount = Math.max(0, Math.min(5.0, fadeAmount));
                    }
                    
                    if (jiggleEnabledParams.emanationRate) {
                        // Emanation rate: jiggle around base, range 2-200, so use ±20 range
                        emanationRate = baseEmanationRate + (Math.sin(seed * 1.0) * 0.5 + 0.5 - 0.5) * jiggleAmount * 20.0;
                        emanationRate = Math.max(2, Math.min(200, emanationRate));
                    }
                    
                    if (jiggleEnabledParams.autoRotationSpeed) {
                        // Auto rotation speed: jiggle around base, range -1 to 360, so use ±30 range
                        autoRotationSpeed = baseAutoRotationSpeed + (Math.sin(seed * 0.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 30.0;
                        autoRotationSpeed = Math.max(-1, Math.min(360, autoRotationSpeed));
                    }
                    
                    if (jiggleEnabledParams.noiseAmount) {
                        // Noise amount: jiggle around base, range 0-1, so use ±0.2 range
                        noiseAmount = baseNoiseAmount + (Math.sin(seed * 1.9) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.2;
                        noiseAmount = Math.max(0, Math.min(1, noiseAmount));
                    }
                    
                    if (jiggleEnabledParams.noiseRate) {
                        // Noise rate: jiggle around base, range 0-10, so use ±2.0 range
                        noiseRate = baseNoiseRate + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount * 2.0;
                        noiseRate = Math.max(0, Math.min(10, noiseRate));
                    }
                    
                    if (jiggleEnabledParams.blurAmount) {
                        // Blur amount: jiggle around base, range 0-1, so use ±0.2 range
                        blurAmount = baseBlurAmount + (Math.sin(seed * 2.0) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.2;
                        blurAmount = Math.max(0, Math.min(1, blurAmount));
                    }
                    
                    if (jiggleEnabledParams.blurRate) {
                        // Blur rate: jiggle around base, range 0-10, so use ±2.0 range
                        blurRate = baseBlurRate + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount * 2.0;
                        blurRate = Math.max(0, Math.min(10, blurRate));
                    }
                    
                    if (jiggleEnabledParams.blendOpacity) {
                        // Blend opacity: jiggle around base, range 0-1, so use ±0.1 range
                        blendOpacity = baseBlendOpacity + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1;
                        blendOpacity = Math.max(0, Math.min(1, blendOpacity));
                    }
                }
                
                // Apply audio-driven offsets if enabled (after jiggle so audio modulates jiggle values)
                // IMPORTANT: Apply audio offsets AFTER interpolation values are retrieved, so they affect the final rendered values
                if (window.getAudioOffset && window.audioReactiveEnabled) {
                    const audioOffsetSpikiness = window.getAudioOffset('spikiness') || 0;
                    const audioOffsetSpikeFrequency = window.getAudioOffset('spikeFrequency') || 0;
                    const audioOffsetSpikeSharpness = window.getAudioOffset('spikeSharpness') || 0;
                    const audioOffsetHue = window.getAudioOffset('hue') || 0;
                    const audioOffsetScale = window.getAudioOffset('scale') || 0;
                    const audioOffsetDilationSpeed = window.getAudioOffset('dilationSpeed') || 0;
                    const audioOffsetFadeAmount = window.getAudioOffset('fadeAmount') || 0;
                    const audioOffsetHueShiftAmount = window.getAudioOffset('hueShiftAmount') || 0;
                    const audioOffsetRotation = window.getAudioOffset('rotation') || 0;
                    const audioOffsetFillSize = window.getAudioOffset('fillSize') || 0;
                    const audioOffsetFillOpacity = window.getAudioOffset('fillOpacity') || 0;
                    const audioOffsetBlendOpacity = window.getAudioOffset('blendOpacity') || 0;
                    
                    // Get parameter ranges - use jiggle ranges if jiggle is enabled, otherwise use reasonable defaults
                    // This ensures audio reactivity works even when jiggle is disabled
                    const useJiggleRanges = jiggleEnabled && jiggleAmount > 0;
                    const paramRanges = {
                        spikiness: useJiggleRanges ? jiggleAmount : 0.2,  // ±20% of full range
                        spikeFrequency: useJiggleRanges ? jiggleAmount * 9.0 : 3.0,  // ±3 units
                        spikeSharpness: useJiggleRanges ? jiggleAmount : 0.2,
                        hue: useJiggleRanges ? jiggleAmount * 180.0 : 60.0,  // ±60 degrees
                        scale: useJiggleRanges ? jiggleAmount * 0.3 : 0.15,  // ±15% of scale
                        dilationSpeed: useJiggleRanges ? jiggleAmount * 0.1 : 0.05,  // ±0.05
                        fadeAmount: useJiggleRanges ? jiggleAmount * 5.0 : 1.0,  // ±1.0
                        hueShiftAmount: useJiggleRanges ? jiggleAmount * 0.1 : 0.05,  // ±0.05
                        rotation: useJiggleRanges ? jiggleAmount * 180.0 : 60.0,  // ±60 degrees
                        fillSize: useJiggleRanges ? jiggleAmount : 0.2,
                        fillOpacity: useJiggleRanges ? jiggleAmount : 0.2,
                        blendOpacity: useJiggleRanges ? jiggleAmount * 0.1 : 0.1
                    };
                    
                    // Apply audio offsets - modulate current values (which may have jiggle applied)
                    // When interpolation is enabled, apply to interpolated values; otherwise apply to direct values
                    const config = window.getAudioMappingConfig ? window.getAudioMappingConfig() : {};
                    
                    // Apply audio offsets - modulate current values (which may have jiggle or interpolation applied)
                    if (config.spikiness?.enabled) {
                        spikiness += audioOffsetSpikiness * paramRanges.spikiness;
                        spikiness = Math.max(0, Math.min(1, spikiness));
                    }
                    if (config.spikeFrequency?.enabled) {
                        spikeFrequency += audioOffsetSpikeFrequency * paramRanges.spikeFrequency;
                        spikeFrequency = Math.max(2, Math.min(20, spikeFrequency));
                    }
                    if (config.spikeSharpness?.enabled) {
                        spikeSharpness += audioOffsetSpikeSharpness * paramRanges.spikeSharpness;
                        spikeSharpness = Math.max(0, Math.min(1, spikeSharpness));
                    }
                    if (config.hue?.enabled) {
                        hue += audioOffsetHue * paramRanges.hue;
                        hue = ((hue % 360) + 360) % 360;
                    }
                    if (config.scale?.enabled) {
                        scale += audioOffsetScale * paramRanges.scale;
                        scale = Math.max(0.05, Math.min(1.0, scale));
                    }
                    if (config.dilationSpeed?.enabled) {
                        dilationSpeed += audioOffsetDilationSpeed * paramRanges.dilationSpeed;
                        dilationSpeed = Math.max(0.88, Math.min(1.22, dilationSpeed));
                    }
                    if (config.fadeAmount?.enabled) {
                        fadeAmount += audioOffsetFadeAmount * paramRanges.fadeAmount;
                        fadeAmount = Math.max(0, Math.min(5, fadeAmount));
                    }
                    if (config.hueShiftAmount?.enabled) {
                        hueShiftAmount += audioOffsetHueShiftAmount * paramRanges.hueShiftAmount;
                        hueShiftAmount = Math.max(0, Math.min(0.2, hueShiftAmount));
                    }
                    if (config.rotation?.enabled) {
                        rotation += audioOffsetRotation * paramRanges.rotation;
                        rotation = ((rotation % 360) + 360) % 360;
                    }
                    if (config.fillSize?.enabled) {
                        fillSize += audioOffsetFillSize * paramRanges.fillSize;
                        fillSize = Math.max(0, Math.min(1, fillSize));
                    }
                    if (config.fillOpacity?.enabled) {
                        fillOpacity += audioOffsetFillOpacity * paramRanges.fillOpacity;
                        fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                    }
                    if (config.blendOpacity?.enabled) {
                        blendOpacity += audioOffsetBlendOpacity * paramRanges.blendOpacity;
                        blendOpacity = Math.max(0, Math.min(1, blendOpacity));
                    }
                    
                    // When interpolation is active, sync interpolated values to modified direct values
                    if (interpolationActive) {
                        interpolatedRotation = rotation;
                        interpolatedAutoRotationSpeed = autoRotationSpeed;
                        interpolatedHueShiftAmount = hueShiftAmount;
                        interpolatedDilationSpeed = dilationSpeed;
                        interpolatedEmanationRate = emanationRate;
                        interpolatedNoiseAmount = noiseAmount;
                        interpolatedNoiseRate = noiseRate;
                        interpolatedBlurAmount = blurAmount;
                        interpolatedBlurRate = blurRate;
                        interpolatedSpikiness = spikiness;
                        interpolatedSpikeFrequency = spikeFrequency;
                        interpolatedSpikeSharpness = spikeSharpness;
                        interpolatedHue = hue;
                        interpolatedScale = scale;
                        interpolatedFillSize = fillSize;
                        interpolatedFillOpacity = fillOpacity;
                        interpolatedFadeAmount = fadeAmount;
                        interpolatedBlendOpacity = blendOpacity;
                    }
                }
                
                // Calculate capture interval from interpolated emanation rate (emanations per second)
                const captureInterval = 1.0 / interpolatedEmanationRate;
                
                // Check if it's time to capture a new shape
                const shouldCaptureShape = (currentTime - lastCaptureTime) >= captureInterval;
                if (shouldCaptureShape) {
                    lastCaptureTime = currentTime;
                }
                
                // Calculate total rotation (interpolated manual + auto) for capturing
                // This ensures captured shapes preserve their rotation at capture time
                const totalRotation = interpolatedRotation + (currentTime * interpolatedAutoRotationSpeed);
                
                // Apply freeze: if frozen, set dilation to 1.0 (no expansion)
                const effectiveDilationSpeed = freezeEnabled ? 1.0 : interpolatedDilationSpeed;
                
                // Use interpolated values for rendering
                renderer.render({
                    u_time: currentTime,
                    u_spikiness: interpolatedSpikiness,
                    u_spikeFrequency: interpolatedSpikeFrequency,
                    u_spikeSharpness: interpolatedSpikeSharpness,
                    u_hue: interpolatedHue,
                    u_scale: interpolatedScale,
                    u_fillSize: interpolatedFillSize,
                    u_fillOpacity: interpolatedFillOpacity
                }, effectiveDilationSpeed, shouldCaptureShape, interpolatedFadeAmount, interpolatedHueShiftAmount, interpolatedEmanationRate, interpolatedNoiseAmount, interpolatedNoiseRate, interpolatedBlurAmount, interpolatedBlurRate, interpolatedRotation, blendMode, interpolatedBlendOpacity, interpolatedAutoRotationSpeed, totalRotation);
                
                // Update debug output
                updateDebugOutput();
            }
            
            // Use setInterval for fixed 60fps instead of requestAnimationFrame
            setInterval(render, FRAME_TIME);
            render(); // Initial render
            
            // Hotkey handlers
            let presetNames = [];
            
            // Store reference to original loadPresets before it gets wrapped
            const originalLoadPresetsForHotkeys = loadPresets;
            
            // Update preset names list (use original function to avoid circular reference)
            function updatePresetNames() {
                const presets = originalLoadPresetsForHotkeys();
                presetNames = Object.keys(presets);
            }
            updatePresetNames();
            
            // Track current preset index
            let currentPresetIndex = -1;
            
            // Find current preset index
            function findCurrentPresetIndex() {
                const currentPreset = presetSelect.value;
                currentPresetIndex = presetNames.indexOf(currentPreset);
                if (currentPresetIndex === -1 && presetNames.length > 0) {
                    currentPresetIndex = 0;
                }
            }
            
            function downloadSnapshot() {
                try {
                    if (!canvas) return;
                    const dataUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    const ts = new Date();
                    const pad = (n) => String(n).padStart(2, '0');
                    const timestamp = `${ts.getFullYear()}-${pad(ts.getMonth() + 1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}`;
                    a.href = dataUrl;
                    a.download = `coherence-sandbox-${timestamp}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } catch (err) {
                    console.error('Snapshot failed', err);
                }
            }

	    function toggleFullScreen() {
		let devtool = document.querySelector('#dev-toolbox');
		let hotleg = document.querySelector('#hotkey-legend');
		let uxToolbox = document.querySelector('#ux-toolbox');

		devtool.hidden = !devtool.hidden;
		hotleg.hidden = !hotleg.hidden;
		if (uxToolbox) uxToolbox.hidden = !uxToolbox.hidden;
	    }
            
            // GIF capture helpers
            function startGifCapture() {
                if (gifRecording) return;
                gifRecording = true;
                gifCaptureFrames = [];
                gifCaptureStart = Date.now();
                
                const maxWidth = 720;
                gifCaptureWidth = Math.min(maxWidth, canvas.width);
                gifCaptureHeight = Math.round(gifCaptureWidth * (canvas.height / canvas.width));
                captureCanvas.width = gifCaptureWidth;
                captureCanvas.height = gifCaptureHeight;
                
                if (recordIndicator) {
                    recordIndicator.style.display = 'inline-block';
                    recordIndicator.textContent = 'RECORD 10.0s';
                    positionStatusIndicators();
                }
                
                const captureFrame = () => {
                    try {
                        captureCtx.clearRect(0, 0, gifCaptureWidth, gifCaptureHeight);
                        captureCtx.drawImage(canvas, 0, 0, gifCaptureWidth, gifCaptureHeight);
                        const frame = captureCtx.getImageData(0, 0, gifCaptureWidth, gifCaptureHeight);
                        gifCaptureFrames.push(frame);
                    } catch (err) {
                        console.error('GIF capture frame failed', err);
                    }
                };
                
                captureFrame();
                
                gifCaptureTimer = setInterval(() => {
                    captureFrame();
                    if (Date.now() - gifCaptureStart >= GIF_MAX_MS) {
                        stopGifCapture(true);
                    }
                }, 1000 / GIF_FPS);
                
                gifCountdownTimer = setInterval(() => {
                    if (!gifRecording) return;
                    const elapsed = Date.now() - gifCaptureStart;
                    const remaining = Math.max(0, GIF_MAX_MS - elapsed);
                    const seconds = (remaining / 1000).toFixed(1);
                    if (recordIndicator) {
                        recordIndicator.textContent = `RECORD ${seconds}s`;
                    }
                }, 100);
            }
            
            function stopGifCapture(autoStop = false) {
                if (!gifRecording) return;
                gifRecording = false;
                if (gifCaptureTimer) {
                    clearInterval(gifCaptureTimer);
                    gifCaptureTimer = null;
                }
                if (gifCountdownTimer) {
                    clearInterval(gifCountdownTimer);
                    gifCountdownTimer = null;
                }
                if (recordIndicator) {
                    recordIndicator.style.display = 'none';
                    recordIndicator.textContent = 'RECORD';
                }
                
                if (gifCaptureFrames.length < 2) {
                    gifCaptureFrames = [];
                    return;
                }
                
                let gif;
                try {
                    gif = new GIF({
                        workers: 2,
                        quality: 10,
                        workerScript: 'vendor/gif.worker.js',
                        width: gifCaptureWidth,
                        height: gifCaptureHeight
                    });
                } catch (err) {
                    console.warn('GIF capture is not supported in this environment.', err);
                    gifCaptureFrames = [];
                    return;
                }
                
                const combinedFrames = gifCaptureFrames.concat(
                    gifCaptureFrames.length > 2 ? gifCaptureFrames.slice(1, -1).reverse() : []
                );
                
                combinedFrames.forEach((frame) => {
                    gif.addFrame(frame, { delay: 1000 / GIF_FPS });
                });
                
                gif.on('finished', (blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const ts = new Date();
                    const pad = (n) => String(n).padStart(2, '0');
                    const timestamp = `${ts.getFullYear()}-${pad(ts.getMonth() + 1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}`;
                    a.href = url;
                    a.download = `coherence-loop-${timestamp}.gif`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
                
                gif.render();
                gifCaptureFrames = [];
            }
            
            // Keyboard event listeners
            document.addEventListener('keydown', (e) => {
                // Ignore hotkeys while typing in text inputs or editable fields
                const active = document.activeElement;
                if (active) {
                    const tag = active.tagName;
                    const type = active.type;
                    const isTextInput = tag === 'INPUT' && type !== 'range' && type !== 'checkbox' && type !== 'radio';
                    const isTextArea = tag === 'TEXTAREA';
                    const isEditable = active.isContentEditable;
                    if (isTextInput || isTextArea || isEditable) {
                        return;
                    }
                }
                
                // Prevent default for our hotkeys (but allow shift for future use)
                if (e.key === ' ' || e.key === 'r' || e.key === 'R' || 
                    e.key === 'j' || e.key === 'J' || e.key === 'Escape' ||
                    e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                    e.key === 'ArrowUp' || e.key === 'ArrowDown' ||
                    e.key === 's' || e.key === 'S' ||
                    e.key === 'g' || e.key === 'G') {
                    e.preventDefault();
                }
                
                // Space: Toggle freeze (set dilation to 1.0 = no expansion)
                if (e.key === ' ') {
                    freezeEnabled = !freezeEnabled;
                    if (freezeEnabled) {
                        // Store original dilation speed
                        originalDilationSpeed = dilationSpeed;
                        dilationSpeed = 1.0; // No dilation when frozen (1.0 = no expansion)
                    } else {
                        // Restore original dilation speed
                        dilationSpeed = originalDilationSpeed;
                    }
                    updateStatusIndicators();
                }
                
                // R: Randomize
                if (e.key === 'r' || e.key === 'R') {
                    randomizeAll();
                }
                
                // S: Snapshot PNG
                if (e.key === 's' || e.key === 'S') {
                    downloadSnapshot();
                }

                if (e.key === 'h' || e.key === 'H') {
		    toggleFullScreen();
                }
                
                // G: Toggle GIF recording (max 10s, forward + reverse loop)
                if (e.key === 'g' || e.key === 'G') {
                    if (gifRecording) {
                        stopGifCapture(false);
                    } else {
                        startGifCapture();
                    }
                }
                
                // 1: Toggle interpolation
                if (e.key === '1') {
                    if (interpolationEnabled) {
                        interpolationEnabled.checked = !interpolationEnabled.checked;
                        interpolator.setEnabled(interpolationEnabled.checked);
                    }
                }

                
                // Left/Right arrows: Cycle presets
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    if (presetNames.length === 0) {
                        updatePresetNames();
                    }
                    if (presetNames.length === 0) return;
                    
                    // Find current preset index
                    const currentPreset = presetSelect.value;
                    let currentIndex = presetNames.indexOf(currentPreset);
                    if (currentIndex === -1) currentIndex = 0;
                    
                    // Cycle
                    if (e.key === 'ArrowLeft') {
                        currentIndex = (currentIndex - 1 + presetNames.length) % presetNames.length;
                    } else {
                        currentIndex = (currentIndex + 1) % presetNames.length;
                    }
                    
                    // Load the preset
                    const presetName = presetNames[currentIndex];
                    presetSelect.value = presetName;
                    loadPreset(presetName);
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                }
                
                // Up arrow: accelerate auto params (rotation, hue shift, dilation)
                if (e.key === 'ArrowUp') {
                    // Get current values from interpolator
                    const currentAutoRotation = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                    const currentHueShift = interpolator.getCurrent('hueShiftAmount') ?? hueShiftAmount;
                    const currentDilation = interpolator.getCurrent('dilationSpeed') ?? dilationSpeed;
                    
                    // Increase auto rotation speed (up to a max) - slower step
                    const newAutoRotation = Math.min(360.0, currentAutoRotation + 0.5);
                    interpolator.setTarget('autoRotationSpeed', newAutoRotation);
                    autoRotationSpeed = newAutoRotation; // Update direct value for slider sync
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (newAutoRotation + 1) / 361.0)), 2));
                    autoRotationValue.textContent = newAutoRotation.toFixed(1) + '°';
                    
                    // Increase hue shift amount (up to max 0.2) - slower step
                    const newHueShift = Math.min(0.2, currentHueShift + 0.0002);
                    interpolator.setTarget('hueShiftAmount', newHueShift);
                    hueShiftAmount = newHueShift;
                    hueShiftSlider.value = newHueShift.toFixed(3);
                    hueShiftValue.textContent = newHueShift.toFixed(3);
                    
                    // Push dilation further away from 1.0 - slower step
                    const delta = currentDilation >= 1.0 ? 0.001 : -0.001;
                    const newDilation = Math.max(0.88, Math.min(1.22, currentDilation + delta));
                    interpolator.setTarget('dilationSpeed', newDilation);
                    dilationSpeed = newDilation;
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(newDilation);
                    dilationValue.textContent = newDilation.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // Down arrow: decelerate auto params towards neutral
                if (e.key === 'ArrowDown') {
                    // Get current values from interpolator
                    const currentAutoRotation = interpolator.getCurrent('autoRotationSpeed') ?? autoRotationSpeed;
                    const currentHueShift = interpolator.getCurrent('hueShiftAmount') ?? hueShiftAmount;
                    const currentDilation = interpolator.getCurrent('dilationSpeed') ?? dilationSpeed;
                    
                    // Gently damp auto rotation towards 0 - slower step
                    const newAutoRotation = currentAutoRotation * 0.98;
                    interpolator.setTarget('autoRotationSpeed', newAutoRotation);
                    autoRotationSpeed = newAutoRotation;
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (newAutoRotation + 1) / 361.0)), 2));
                    autoRotationValue.textContent = newAutoRotation.toFixed(1) + '°';
                    
                    // Gently damp hue shift towards 0 - slower step
                    const newHueShift = currentHueShift * 0.98;
                    interpolator.setTarget('hueShiftAmount', newHueShift);
                    hueShiftAmount = newHueShift;
                    hueShiftSlider.value = newHueShift.toFixed(3);
                    hueShiftValue.textContent = newHueShift.toFixed(3);
                    
                    // Bring dilation towards 1.0 (never snapping) - slower easing
                    const newDilation = currentDilation + (1.0 - currentDilation) * 0.02;
                    interpolator.setTarget('dilationSpeed', newDilation);
                    dilationSpeed = newDilation;
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(newDilation);
                    dilationValue.textContent = newDilation.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // J: Toggle jiggle
                if (e.key === 'j' || e.key === 'J') {
                    jiggleBtn.click();
                }
                
                // Esc: Clear screen
                if (e.key === 'Escape') {
                    // Clear both framebuffers
                    const gl = renderer.gl;
                    
                    // Clear history framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.historyFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Clear current framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.currentFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
            });
            
            // Note: We don't wrap loadPresets here because updatePresetNames
            // already calls the original function directly to avoid circular references.
            // If you need to update preset names after loading, call updatePresetNames() explicitly.
        })();
        
        // Audio Mapping System
        (() => {
            let audioAnalyzer = null;
            let audioMappingConfig = {};
            let audioReactiveEnabled = false;
            let lastSelectedMenu = null;
            
            // Audio parameter mappings: visualParam -> audioMetric
            // Each visual parameter has a unique mapping (no duplicate visual parameters)
            const audioMappings = {
                spikiness: 'collision',
                spikeFrequency: 'audioAmp',
                spikeSharpness: 'harshness',
                hue: 'bandEnergy',
                scale: 'compression',
                dilationSpeed: 'emptiness',  // Changed to avoid duplicate with scale
                fadeAmount: 'mud',  // Changed to avoid duplicate
                hueShiftAmount: 'phaseRisk',
                rotation: 'lowImbalance',  // Changed to avoid duplicate with hueShiftAmount
                fillSize: 'audioAmp',  // Same as spikeFrequency - both can use audioAmp
                fillOpacity: 'coherence',
                blendOpacity: 'mud'  // Same as fadeAmount - both can use mud
            };
            
            // Available audio metrics that are not yet mapped to visual parameters:
            // - lowImbalance (now mapped to rotation)
            // - stereoWidth (array: [low, mid, high]) - unmapped
            // - panPosition (array: [low, mid, high]) - unmapped
            // - spatialDepth (array: [low, mid, high]) - unmapped
            // Note: Some audio metrics are used by multiple visual parameters (audioAmp, mud)
            // This is intentional - multiple parameters can react to the same audio feature
            
            // Initialize audio analyzer
            async function initAudioAnalyzer() {
                if (typeof AudioAnalyzer === 'undefined') {
                    console.warn('AudioAnalyzer not loaded');
                    return;
                }
                
                audioAnalyzer = new AudioAnalyzer();
                
                // Load audio devices
                await loadAudioDevices();
                
                // Setup audio enable button
                setupAudioButton();
            }
            
            // Load audio devices (without requesting permission - just shows available devices)
            async function loadAudioDevices(requestPermission = false) {
                const deviceSelect = document.getElementById('audio-device-select');
                if (!deviceSelect || !audioAnalyzer) return;

                try {
                    const devices = await audioAnalyzer.getAudioDevices(requestPermission);
                    deviceSelect.innerHTML = '<option value="">Default Device</option>';

                    devices.forEach(device => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        option.textContent = device.label;
                        // Mark if we don't have the real label yet
                        if (!device.hasLabel) {
                            option.dataset.needsRefresh = 'true';
                        }
                        deviceSelect.appendChild(option);
                    });

                    // Restore last selected device
                    const lastDeviceId = localStorage.getItem('audioLastDeviceId');
                    if (lastDeviceId) {
                        deviceSelect.value = lastDeviceId;
                    }

                    // If we got devices without real labels, show a hint
                    const needsPermission = devices.some(d => !d.hasLabel);
                    if (needsPermission && devices.length > 0) {
                        // Add a hint option
                        const hint = document.createElement('option');
                        hint.disabled = true;
                        hint.textContent = '─ Click "Enable Mic" for device names ─';
                        hint.style.color = '#888';
                        deviceSelect.insertBefore(hint, deviceSelect.options[1]);
                    }
                } catch (err) {
                    console.error('Failed to load audio devices:', err);
                    deviceSelect.innerHTML = '<option value="">Click "Enable Mic" to see devices</option>';
                }
            }
            
            // Setup audio enable button
            function setupAudioButton() {
                const btn = document.getElementById('enable-audio-btn');
                const tabBtn = document.getElementById('capture-tab-btn');
                const status = document.getElementById('audio-status');
                const deviceSelect = document.getElementById('audio-device-select');

                if (!btn || !status || !audioAnalyzer) return;

                // Helper to reset UI state
                function resetAudioUI() {
                    btn.textContent = 'Enable Mic/Device';
                    btn.style.background = '#0af';
                    tabBtn.textContent = 'Capture Tab Audio';
                    tabBtn.style.background = '#a0f';
                    status.textContent = 'Audio: Disabled';
                    status.style.color = '#888';
                    if (deviceSelect) deviceSelect.disabled = false;
                }

                // Helper to set active state
                function setActiveUI(mode, isTab) {
                    if (isTab) {
                        tabBtn.textContent = 'Stop Tab Capture';
                        tabBtn.style.background = '#f44';
                        btn.style.background = '#555';
                    } else {
                        btn.textContent = 'Disable Audio';
                        btn.style.background = '#f44';
                        tabBtn.style.background = '#555';
                    }
                    status.textContent = `Audio: ${mode}${isTab ? ' (Tab)' : ''}`;
                    status.style.color = audioAnalyzer.isStereo ? '#0f0' : '#ff0';
                    if (deviceSelect) deviceSelect.disabled = true;
                }

                // Listen for tab audio ending (user stopped sharing)
                window.addEventListener('tabAudioEnded', () => {
                    resetAudioUI();
                });

                // Mic/Device button handler
                btn.addEventListener('click', async () => {
                    if (audioAnalyzer.isEnabled) {
                        // Disable audio
                        audioAnalyzer.disableAudio();
                        resetAudioUI();
                    } else {
                        // Enable audio from mic/device
                        try {
                            const selectedDeviceId = deviceSelect?.value || null;

                            // Cache the selected device
                            if (selectedDeviceId) {
                                localStorage.setItem('audioLastDeviceId', selectedDeviceId);
                            } else {
                                localStorage.removeItem('audioLastDeviceId');
                            }

                            await audioAnalyzer.enableAudio(selectedDeviceId, true);
                            const mode = audioAnalyzer.isStereo ? 'STEREO' : 'MONO';
                            setActiveUI(mode, false);

                            // Now we have permission - refresh device list to show real names
                            // (do this in background, don't wait)
                            loadAudioDevices(false).catch(() => {});
                        } catch (err) {
                            console.error('Failed to enable audio:', err);
                            alert('Failed to enable audio: ' + err.message);
                        }
                    }
                });

                // Tab capture button handler
                if (tabBtn) {
                    tabBtn.addEventListener('click', async () => {
                        if (audioAnalyzer.isEnabled) {
                            // Disable audio
                            audioAnalyzer.disableAudio();
                            resetAudioUI();
                        } else {
                            // Enable tab audio capture
                            try {
                                await audioAnalyzer.enableTabAudio();
                                const mode = audioAnalyzer.isStereo ? 'STEREO' : 'MONO';
                                setActiveUI(mode, true);
                            } catch (err) {
                                console.error('Failed to capture tab audio:', err);
                                alert('Failed to capture tab audio: ' + err.message);
                            }
                        }
                    });
                }
            }
            
            // Setup audio reactive toggle
            function setupAudioReactiveToggle() {
                const toggle = document.getElementById('audio-reactive-enabled');
                if (!toggle) return;
                
                // Set initial state
                window.setAudioReactiveEnabled(toggle.checked);
                
                toggle.addEventListener('change', (e) => {
                    window.setAudioReactiveEnabled(e.target.checked);
                });
            }
            
            // Initialize audio mapping UI
            function initAudioMappingUI() {
                const panel = document.getElementById('audio-mapping-panel');
                const content = document.getElementById('audio-mapping-content');
                if (!panel || !content) return;
                
                // Setup search filter
                const searchInput = document.getElementById('mapping-search');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        const searchTerm = e.target.value.toLowerCase();
                        document.querySelectorAll('.mapping-param-group').forEach(group => {
                            const paramName = group.querySelector('.mapping-param-name')?.textContent?.toLowerCase() || '';
                            const source = group.querySelector('.mapping-source')?.textContent?.toLowerCase() || '';
                            if (paramName.includes(searchTerm) || source.includes(searchTerm) || searchTerm === '') {
                                group.style.display = '';
                            } else {
                                group.style.display = 'none';
                            }
                        });
                    });
                }
                
                // Setup collapse/expand all buttons
                const collapseAllBtn = document.getElementById('mapping-collapse-all');
                const expandAllBtn = document.getElementById('mapping-expand-all');
                
                if (collapseAllBtn) {
                    collapseAllBtn.addEventListener('click', () => {
                        document.querySelectorAll('.mapping-param-group').forEach(group => {
                            if (group.style.display !== 'none') {
                                group.classList.add('collapsed');
                            }
                        });
                    });
                }
                
                if (expandAllBtn) {
                    expandAllBtn.addEventListener('click', () => {
                        document.querySelectorAll('.mapping-param-group').forEach(group => {
                            group.classList.remove('collapsed');
                        });
                    });
                }
                
                // Create mapping controls for each parameter
                Object.keys(audioMappings).forEach(paramName => {
                    const audioMetric = audioMappings[paramName];
                    const mappingId = `mapping-${paramName}`;
                    
                    // Initialize config with defaults
                    if (!audioMappingConfig[paramName]) {
                        audioMappingConfig[paramName] = {
                            enabled: false,
                            sensitivity: 1.0,
                            smoothing: 0.8,
                            multiplier: 1.0,
                            offset: 0.0
                        };
                    }
                    
                    const config = audioMappingConfig[paramName];
                    
                    // Create parameter group
                    const group = document.createElement('div');
                    group.className = 'mapping-param-group';
                    group.id = `mapping-group-${paramName}`;
                    
                    group.innerHTML = `
                        <div class="mapping-param-header">
                            <input type="checkbox" id="${mappingId}-enabled" ${config.enabled ? 'checked' : ''}>
                            <span class="mapping-param-name">${paramName}</span>
                            <span class="mapping-source">from ${audioMetric}</span>
                            <span class="mapping-collapse-indicator">▼</span>
                        </div>
                        <div class="mapping-compact-view">
                            <div class="mapping-compact-info">
                                <span>Current:</span>
                                <span id="${mappingId}-compact-current" class="mapping-compact-value">0.000</span>
                                <div class="mapping-compact-bar">
                                    <div id="${mappingId}-compact-bar" class="mapping-compact-bar-fill" style="width: 50%;"></div>
                                </div>
                            </div>
                        </div>
                        <div class="mapping-param-content">
                            <div class="mapping-diagnostic">
                                <canvas class="mapping-range-display" id="${mappingId}-range" width="200" height="60"></canvas>
                                <div class="mapping-minmax-display">
                                    <span id="${mappingId}-minmax">Min: 0.000 | Max: 1.000</span>
                                    <span id="${mappingId}-current" class="mapping-current-value">Current: 0.000</span>
                                </div>
                            </div>
                            <div class="mapping-control">
                                <label>Sensitivity</label>
                                <div class="mapping-control-row">
                                    <input type="range" id="${mappingId}-sensitivity" min="0" max="3" value="${config.sensitivity}" step="0.1">
                                    <input type="number" id="${mappingId}-sensitivity-num" value="${config.sensitivity}" step="0.1" min="0" max="10">
                                </div>
                            </div>
                            <div class="mapping-control">
                                <label>Smoothing</label>
                                <div class="mapping-control-row">
                                    <input type="range" id="${mappingId}-smoothing" min="0.5" max="0.99" value="${config.smoothing}" step="0.01">
                                    <input type="number" id="${mappingId}-smoothing-num" value="${config.smoothing}" step="0.01" min="0.5" max="0.99">
                                </div>
                            </div>
                            <div class="mapping-control">
                                <label>Multiplier</label>
                                <div class="mapping-control-row">
                                    <input type="range" id="${mappingId}-multiplier" min="-5" max="5" value="${config.multiplier}" step="0.1">
                                    <input type="number" id="${mappingId}-multiplier-num" value="${config.multiplier}" step="0.1">
                                </div>
                            </div>
                            <div class="mapping-control">
                                <label>Offset</label>
                                <div class="mapping-control-row">
                                    <input type="range" id="${mappingId}-offset" min="-1" max="1" value="${config.offset}" step="0.01">
                                    <input type="number" id="${mappingId}-offset-num" value="${config.offset}" step="0.01">
                                </div>
                            </div>
                        </div>
                    `;
                    
                    // Add collapse toggle functionality
                    const header = group.querySelector('.mapping-param-header');
                    const collapseIndicator = group.querySelector('.mapping-collapse-indicator');
                    let isCollapsed = false;
                    
                    // Prevent checkbox from triggering collapse
                    const headerCheckbox = group.querySelector(`#${mappingId}-enabled`);
                    headerCheckbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    
                    header.addEventListener('click', (e) => {
                        // Don't collapse if clicking the checkbox
                        if (e.target === headerCheckbox || e.target.closest('input[type="checkbox"]')) {
                            return;
                        }
                        isCollapsed = !isCollapsed;
                        if (isCollapsed) {
                            group.classList.add('collapsed');
                        } else {
                            group.classList.remove('collapsed');
                        }
                    });
                    
                    content.appendChild(group);
                    
                    // Wire up controls
                    const enabledCheckbox = document.getElementById(`${mappingId}-enabled`);
                    const sensitivitySlider = document.getElementById(`${mappingId}-sensitivity`);
                    const sensitivityNum = document.getElementById(`${mappingId}-sensitivity-num`);
                    const smoothingSlider = document.getElementById(`${mappingId}-smoothing`);
                    const smoothingNum = document.getElementById(`${mappingId}-smoothing-num`);
                    const multiplierSlider = document.getElementById(`${mappingId}-multiplier`);
                    const multiplierNum = document.getElementById(`${mappingId}-multiplier-num`);
                    const offsetSlider = document.getElementById(`${mappingId}-offset`);
                    const offsetNum = document.getElementById(`${mappingId}-offset-num`);
                    
                    enabledCheckbox.addEventListener('change', (e) => {
                        config.enabled = e.target.checked;
                    });
                    
                    const syncSliderNum = (slider, num, prop) => {
                        slider.addEventListener('input', (e) => {
                            const val = parseFloat(e.target.value);
                            config[prop] = val;
                            num.value = val;
                        });
                        num.addEventListener('input', (e) => {
                            const val = parseFloat(e.target.value);
                            config[prop] = val;
                            slider.value = val;
                        });
                    };
                    
                    syncSliderNum(sensitivitySlider, sensitivityNum, 'sensitivity');
                    syncSliderNum(smoothingSlider, smoothingNum, 'smoothing');
                    syncSliderNum(multiplierSlider, multiplierNum, 'multiplier');
                    syncSliderNum(offsetSlider, offsetNum, 'offset');
                });
            }
            
            // Smooth audio-driven offsets
            const audioOffsets = {};
            Object.keys(audioMappings).forEach(param => {
                audioOffsets[param] = 0.0;
            });
            
            // Update audio-driven parameter offsets
            // Always calculates offsets for display purposes, but only applies them when enabled
            function updateAudioOffsets() {
                if (!audioAnalyzer) {
                    Object.keys(audioMappings).forEach(param => {
                        audioOffsets[param] = 0.0;
                    });
                    return;
                }
                
                if (!audioAnalyzer.isEnabled) {
                    // Reset all offsets if audio is not enabled
                    Object.keys(audioMappings).forEach(param => {
                        audioOffsets[param] = 0.0;
                    });
                    return;
                }
                
                let metrics, normalizedMetrics;
                try {
                    metrics = audioAnalyzer.getMetrics();
                    normalizedMetrics = audioAnalyzer.normalizedMetrics || {};
                } catch (e) {
                    console.warn('Error getting metrics in updateAudioOffsets:', e);
                    return;
                }
                
                Object.keys(audioMappings).forEach(paramName => {
                    const config = audioMappingConfig[paramName];
                    if (!config) {
                        audioOffsets[paramName] = 0.0;
                        return;
                    }
                    
                    const audioMetric = audioMappings[paramName];
                    let rawValue = 0.5;
                    
                    // Get normalized metric value - prefer normalizedMetrics if available
                    // normalizedMetrics uses property names without 'u_' prefix
                    if (audioMetric === 'bandEnergy') {
                        // Use mid band for bandEnergy mappings
                        if (normalizedMetrics.bandEnergy && Array.isArray(normalizedMetrics.bandEnergy) && normalizedMetrics.bandEnergy[1] !== undefined) {
                            rawValue = normalizedMetrics.bandEnergy[1];
                        } else if (metrics.u_bandEnergy && Array.isArray(metrics.u_bandEnergy) && metrics.u_bandEnergy[1] !== undefined) {
                            rawValue = metrics.u_bandEnergy[1];
                        }
                    } else {
                        // Try normalizedMetrics first (property name matches audioMetric)
                        if (normalizedMetrics[audioMetric] !== undefined && normalizedMetrics[audioMetric] !== null) {
                            rawValue = normalizedMetrics[audioMetric];
                        } else if (metrics[`u_${audioMetric}`] !== undefined) {
                            // Fallback to raw metric (with 'u_' prefix)
                            const metricValue = metrics[`u_${audioMetric}`];
                            rawValue = Array.isArray(metricValue) ? (metricValue[1] !== undefined ? metricValue[1] : metricValue[0] || 0.5) : metricValue;
                        }
                    }
                    
                    // Apply multiplier and offset
                    let mappedValue = (rawValue - 0.5) * config.sensitivity * config.multiplier + config.offset;
                    
                    // Always calculate and smooth the offset (for display purposes)
                    // The enable checkbox only controls whether it's applied in the render loop
                    audioOffsets[paramName] = audioOffsets[paramName] * config.smoothing + mappedValue * (1 - config.smoothing);
                });
            }
            
            // Update metrics visualization table
            function updateMetricsVisualization() {
                if (!audioAnalyzer || !audioAnalyzer.isEnabled) {
                    const tbody = document.getElementById('metrics-table-body');
                    if (tbody) tbody.innerHTML = '<tr><td colspan="8" style="text-align: center; color: #888; padding: 20px;">Audio not enabled</td></tr>';
                    return;
                }
                
                // Check if methods exist
                if (!('getMinMax' in audioAnalyzer) || 
                    !('getNormalizedMetric' in audioAnalyzer) ||
                    !('getMetrics' in audioAnalyzer)) {
                    return;
                }
                
                const metrics = audioAnalyzer.getMetrics();
                const normalizedMetrics = audioAnalyzer.normalizedMetrics || {};
                const tbody = document.getElementById('metrics-table-body');
                if (!tbody) return;
                
                // Define all available metrics
                const allMetrics = [
                    { name: 'audioAmp', label: 'Audio Amp', isArray: false },
                    { name: 'bandEnergy', label: 'Band Energy', isArray: true, indices: ['Low', 'Mid', 'High'] },
                    { name: 'harshness', label: 'Harshness', isArray: false },
                    { name: 'mud', label: 'Mud', isArray: false },
                    { name: 'compression', label: 'Compression', isArray: false },
                    { name: 'collision', label: 'Collision', isArray: false },
                    { name: 'lowImbalance', label: 'Low Imbalance', isArray: false },
                    { name: 'emptiness', label: 'Emptiness', isArray: false },
                    { name: 'coherence', label: 'Coherence', isArray: false },
                    { name: 'phaseRisk', label: 'Phase Risk', isArray: false },
                    { name: 'stereoWidth', label: 'Stereo Width', isArray: true, indices: ['Low', 'Mid', 'High'] },
                    { name: 'panPosition', label: 'Pan Position', isArray: true, indices: ['Low', 'Mid', 'High'] },
                    { name: 'spatialDepth', label: 'Spatial Depth', isArray: true, indices: ['Low', 'Mid', 'High'] }
                ];
                
                let html = '';
                
                allMetrics.forEach(metricDef => {
                    if (metricDef.isArray) {
                        // Handle array metrics
                        for (let i = 0; i < 3; i++) {
                            const metricName = metricDef.name;
                            const label = `${metricDef.label} ${metricDef.indices[i]}`;
                            
                            // Get values
                            let currentRaw = 0.5;
                            let currentNorm = 0.5;
                            let minMax = { min: 0, max: 1 };
                            let avg = 0.5;
                            
                            try {
                                minMax = audioAnalyzer.getMinMax(metricName, i);
                                currentNorm = audioAnalyzer.getNormalizedMetric(metricName, i);
                                
                                // Get raw current value
                                const rawMetric = metrics[`u_${metricName}`];
                                if (rawMetric && Array.isArray(rawMetric)) {
                                    currentRaw = rawMetric[i];
                                }
                                
                                // Calculate average from history
                                try {
                                    const history = audioAnalyzer.metricHistory && audioAnalyzer.metricHistory[metricName];
                                    if (history && Array.isArray(history) && history[i] && Array.isArray(history[i]) && history[i].length > 0) {
                                        const sum = history[i].reduce((a, b) => a + b, 0);
                                        avg = sum / history[i].length;
                                    }
                                } catch (e) {
                                    // Ignore history errors
                                }
                            } catch (e) {
                                // Use defaults
                            }
                            
                            // Find which visual parameters map to this metric
                            const mappedParams = Object.keys(audioMappings)
                                .filter(param => {
                                    const mappedMetric = audioMappings[param];
                                    if (mappedMetric === metricName && metricDef.name === 'bandEnergy') {
                                        // For bandEnergy, check if it uses this index (we use mid band [1] by default)
                                        return i === 1;
                                    }
                                    return mappedMetric === metricName;
                                })
                                .filter(param => audioMappingConfig[param]?.enabled);
                            
                            const mappedTo = mappedParams.length > 0 
                                ? mappedParams.join(', ') 
                                : '<span style="color: #555;">none</span>';
                            
                            // Calculate range bar positions
                            const rangeStart = (minMax.min / 1.0) * 100;
                            const rangeWidth = ((minMax.max - minMax.min) / 1.0) * 100;
                            const currentX = (currentRaw / 1.0) * 100;
                            const normalizedX = (currentNorm / 1.0) * 100;
                            
                            html += `
                                <tr>
                                    <td class="metric-name">${label}</td>
                                    <td class="metric-value">${currentRaw.toFixed(3)}</td>
                                    <td class="metric-normalized">${currentNorm.toFixed(3)}</td>
                                    <td class="metric-min">${minMax.min.toFixed(3)}</td>
                                    <td class="metric-max">${minMax.max.toFixed(3)}</td>
                                    <td class="metric-avg">${avg.toFixed(3)}</td>
                                    <td>
                                        <div class="metric-bar-container">
                                            <div class="metric-bar-range" style="left: ${rangeStart}%; width: ${rangeWidth}%;"></div>
                                            <div class="metric-bar-current" style="left: ${currentX}%;"></div>
                                            <div class="metric-bar-normalized" style="left: ${normalizedX}%;"></div>
                                        </div>
                                    </td>
                                    <td class="mapping-targets">${mappedTo}</td>
                                </tr>
                            `;
                        }
                    } else {
                        // Handle scalar metrics
                        const metricName = metricDef.name;
                        const label = metricDef.label;
                        
                        // Skip if metric doesn't exist (e.g., phaseRisk when not stereo)
                        if (metricName === 'phaseRisk' && !audioAnalyzer.isStereo) return;
                        if (metricName.startsWith('stereo') || metricName.startsWith('pan') || metricName.startsWith('spatial')) {
                            if (!audioAnalyzer.isStereo) return;
                        }
                        
                        // Get values
                        let currentRaw = 0.5;
                        let currentNorm = 0.5;
                        let minMax = { min: 0, max: 1 };
                        let avg = 0.5;
                        
                        try {
                            minMax = audioAnalyzer.getMinMax(metricName);
                            currentNorm = audioAnalyzer.getNormalizedMetric(metricName);
                            
                            // Get raw current value
                            const rawMetric = metrics[`u_${metricName}`];
                            if (rawMetric !== undefined) {
                                currentRaw = Array.isArray(rawMetric) ? rawMetric[0] : rawMetric;
                            }
                            
                                // Calculate average from history
                                try {
                                    const history = audioAnalyzer.metricHistory && audioAnalyzer.metricHistory[metricName];
                                    if (history && Array.isArray(history) && history.length > 0) {
                                        const sum = history.reduce((a, b) => a + b, 0);
                                        avg = sum / history.length;
                                    }
                                } catch (e) {
                                    // Ignore history errors
                                }
                        } catch (e) {
                            // Use defaults
                        }
                        
                        // Find which visual parameters map to this metric
                        const mappedParams = Object.keys(audioMappings)
                            .filter(param => audioMappings[param] === metricName)
                            .filter(param => audioMappingConfig[param]?.enabled);
                        
                        const mappedTo = mappedParams.length > 0 
                            ? mappedParams.join(', ') 
                            : '<span style="color: #555;">none</span>';
                        
                        // Calculate range bar positions
                        const rangeStart = (minMax.min / 1.0) * 100;
                        const rangeWidth = ((minMax.max - minMax.min) / 1.0) * 100;
                        const currentX = (currentRaw / 1.0) * 100;
                        const normalizedX = (currentNorm / 1.0) * 100;
                        
                        html += `
                            <tr>
                                <td class="metric-name">${label}</td>
                                <td class="metric-value">${currentRaw.toFixed(3)}</td>
                                <td class="metric-normalized">${currentNorm.toFixed(3)}</td>
                                <td class="metric-min">${minMax.min.toFixed(3)}</td>
                                <td class="metric-max">${minMax.max.toFixed(3)}</td>
                                <td class="metric-avg">${avg.toFixed(3)}</td>
                                <td>
                                    <div class="metric-bar-container">
                                        <div class="metric-bar-range" style="left: ${rangeStart}%; width: ${rangeWidth}%;"></div>
                                        <div class="metric-bar-current" style="left: ${currentX}%;"></div>
                                        <div class="metric-bar-normalized" style="left: ${normalizedX}%;"></div>
                                    </div>
                                </td>
                                <td class="mapping-targets">${mappedTo}</td>
                            </tr>
                        `;
                    }
                });
                
                tbody.innerHTML = html || '<tr><td colspan="8" style="text-align: center; color: #888; padding: 20px;">No metrics available</td></tr>';
            }
            
            // Update diagnostic displays
            // Always shows values regardless of mapping enabled state
            function updateDiagnostics() {
                if (!audioAnalyzer) {
                    return;
                }
                
                if (!audioAnalyzer.isEnabled) {
                    // Show placeholder values when audio is disabled
                    Object.keys(audioMappings).forEach(paramName => {
                        const mappingId = `mapping-${paramName}`;
                        const minmaxDisplay = document.getElementById(`${mappingId}-minmax`);
                        const currentDisplay = document.getElementById(`${mappingId}-current`);
                        const rangeDisplay = document.getElementById(`${mappingId}-range`);
                        const compactCurrent = document.getElementById(`${mappingId}-compact-current`);
                        const compactBar = document.getElementById(`${mappingId}-compact-bar`);
                        
                        if (minmaxDisplay) minmaxDisplay.textContent = 'Min: 0.000 | Max: 1.000';
                        if (currentDisplay) currentDisplay.textContent = 'Current: 0.000';
                        if (compactCurrent) {
                            compactCurrent.textContent = '0.000';
                            compactCurrent.style.color = '#888';
                        }
                        if (compactBar) compactBar.style.width = '50%';
                        if (rangeDisplay && rangeDisplay instanceof HTMLCanvasElement) {
                            const ctx = rangeDisplay.getContext('2d');
                            const width = rangeDisplay.width = rangeDisplay.offsetWidth || 200;
                            const height = rangeDisplay.height = rangeDisplay.offsetHeight || 60;
                            ctx.clearRect(0, 0, width, height);
                        }
                    });
                    return;
                }
                
                // Check if methods exist
                if (!('getMinMax' in audioAnalyzer) || 
                    !('getNormalizedMetric' in audioAnalyzer) ||
                    !('getMetrics' in audioAnalyzer) ||
                    typeof audioAnalyzer.getMinMax !== 'function' || 
                    typeof audioAnalyzer.getNormalizedMetric !== 'function' ||
                    typeof audioAnalyzer.getMetrics !== 'function') {
                    return;
                }
                
                // Get metrics once for all parameters
                let metrics, normalizedMetrics;
                try {
                    metrics = audioAnalyzer.getMetrics();
                    normalizedMetrics = audioAnalyzer.normalizedMetrics || {};
                    
                    // Debug: log occasionally to verify metrics are updating
                    if (Math.random() < 0.01) {
                        console.log('updateDiagnostics - metrics:', {
                            audioAmp: metrics.u_audioAmp?.toFixed(3),
                            collision: metrics.u_collision?.toFixed(3),
                            hasNormalized: !!normalizedMetrics.audioAmp,
                            normalizedAmp: normalizedMetrics.audioAmp?.toFixed(3)
                        });
                    }
                } catch (e) {
                    console.warn('Error getting metrics in updateDiagnostics:', e);
                    return;
                }
                
                Object.keys(audioMappings).forEach(paramName => {
                    const audioMetric = audioMappings[paramName];
                    const mappingId = `mapping-${paramName}`;
                    
                    const rangeDisplay = document.getElementById(`${mappingId}-range`);
                    const minmaxDisplay = document.getElementById(`${mappingId}-minmax`);
                    const currentDisplay = document.getElementById(`${mappingId}-current`);
                    
                    if (!rangeDisplay || !minmaxDisplay || !currentDisplay) return;
                    
                    // Get min/max for this metric
                    let minMax = { min: 0, max: 1 };
                    try {
                        if (audioMetric === 'bandEnergy') {
                            minMax = audioAnalyzer.getMinMax('bandEnergy', 1);
                        } else {
                            minMax = audioAnalyzer.getMinMax(audioMetric);
                        }
                    } catch (e) {
                        console.warn('Error getting min/max for', audioMetric, e);
                        minMax = { min: 0, max: 1 };
                    }
                    
                    // Get current normalized value
                    let currentNorm = 0.5;
                    try {
                        if (audioMetric === 'bandEnergy') {
                            currentNorm = audioAnalyzer.getNormalizedMetric('bandEnergy', 1);
                        } else {
                            currentNorm = audioAnalyzer.getNormalizedMetric(audioMetric);
                        }
                    } catch (e) {
                        console.warn('Error getting normalized metric for', audioMetric, e);
                        currentNorm = 0.5;
                    }
                    
                    // Get current raw value (use already retrieved metrics)
                    let currentRaw = 0.5;
                    try {
                        if (audioMetric === 'bandEnergy') {
                            currentRaw = metrics.u_bandEnergy ? metrics.u_bandEnergy[1] : 0.5;
                        } else {
                            currentRaw = metrics[`u_${audioMetric}`] || 0.5;
                        }
                    } catch (e) {
                        console.warn('Error getting raw metric for', audioMetric, e);
                        currentRaw = 0.5;
                    }
                    
                    // Update displays - always update regardless of enabled state
                    minmaxDisplay.textContent = `Min: ${minMax.min.toFixed(3)} | Max: ${minMax.max.toFixed(3)}`;
                    currentDisplay.textContent = `Current: ${currentNorm.toFixed(3)}`;
                    
                    // Update display color based on whether value is changing
                    if (currentNorm !== 0.5 || currentRaw !== 0.5) {
                        currentDisplay.style.color = '#0af';
                    } else {
                        currentDisplay.style.color = '#888';
                    }
                    
                    // Update compact view (shown when collapsed)
                    const compactCurrent = document.getElementById(`${mappingId}-compact-current`);
                    const compactBar = document.getElementById(`${mappingId}-compact-bar`);
                    if (compactCurrent) {
                        compactCurrent.textContent = currentNorm.toFixed(3);
                        // Color code based on value
                        if (Math.abs(currentNorm - 0.5) > 0.1) {
                            compactCurrent.style.color = '#0af';
                        } else {
                            compactCurrent.style.color = '#888';
                        }
                    }
                    if (compactBar) {
                        // Map normalized value (0-1) to bar width (0-100%)
                        const barWidth = Math.max(0, Math.min(100, currentNorm * 100));
                        compactBar.style.width = `${barWidth}%`;
                    }
                    
                    // Draw range visualization
                    if (!(rangeDisplay instanceof HTMLCanvasElement)) {
                        // Convert to canvas if not already
                        const canvas = document.createElement('canvas');
                        canvas.className = rangeDisplay.className;
                        canvas.style.cssText = rangeDisplay.style.cssText;
                        canvas.id = rangeDisplay.id;
                        rangeDisplay.parentNode.replaceChild(canvas, rangeDisplay);
                        return;
                    }
                    const ctx = rangeDisplay.getContext('2d');
                    const width = rangeDisplay.width = rangeDisplay.offsetWidth || 200;
                    const height = rangeDisplay.height = rangeDisplay.offsetHeight || 60;
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    // Draw min/max range
                    const rangeStart = (minMax.min / 1.0) * width;
                    const rangeEnd = (minMax.max / 1.0) * width;
                    ctx.fillStyle = 'rgba(0, 170, 255, 0.2)';
                    ctx.fillRect(rangeStart, 0, rangeEnd - rangeStart, height);
                    
                    // Draw current normalized position
                    const currentX = currentNorm * width;
                    ctx.strokeStyle = '#0af';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(currentX, 0);
                    ctx.lineTo(currentX, height);
                    ctx.stroke();
                    
                    // Draw current raw position
                    const rawX = currentRaw * width;
                    ctx.strokeStyle = '#fa0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(rawX, 0);
                    ctx.lineTo(rawX, height);
                    ctx.stroke();
                    
                    // Draw offset indicator
                    const config = audioMappingConfig[paramName];
                    if (config && config.enabled) {
                        const offset = audioOffsets[paramName] || 0;
                        const offsetX = (0.5 + offset) * width;
                        ctx.fillStyle = '#0f0';
                        ctx.fillRect(offsetX - 1, height - 8, 2, 8);
                    }
                });
            }
            
            // Toggle audio mapping panel
            function toggleAudioMappingPanel() {
                const panel = document.getElementById('audio-mapping-panel');
                if (!panel) return;
                panel.classList.toggle('visible');
                lastSelectedMenu = 'audio-mapping';
            }
            
            // Hotkey handler
            document.addEventListener('keydown', (e) => {
                if (e.key === 'm' || e.key === 'M') {
                    if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                        toggleAudioMappingPanel();
                    }
                }
            });
            
            // Initialize on load - wait for AudioAnalyzer to be available
            let audioMappingInitialized = false;
            
            // Function to wait for AudioAnalyzer to be available
            async function waitForAudioAnalyzer(maxAttempts = 100, delay = 50) {
                // First check if script is loaded
                const script = document.getElementById('analyzer-script');
                if (script) {
                    // Wait for script to load if it hasn't already
                    if (script.readyState && script.readyState !== 'complete' && script.readyState !== 'loaded') {
                        await new Promise((resolve, reject) => {
                            const timeout = setTimeout(() => {
                                script.removeEventListener('load', resolve);
                                script.removeEventListener('error', reject);
                                resolve(); // Continue with polling
                            }, 2000);
                            
                            script.addEventListener('load', () => {
                                clearTimeout(timeout);
                                resolve();
                            }, { once: true });
                            script.addEventListener('error', () => {
                                clearTimeout(timeout);
                                reject(new Error('Script failed to load'));
                            }, { once: true });
                        }).catch(() => {
                            // Continue with polling if script load fails
                        });
                    }
                }
                
                // Poll for AudioAnalyzer class
                for (let i = 0; i < maxAttempts; i++) {
                    if (typeof AudioAnalyzer !== 'undefined' && typeof AudioAnalyzer === 'function') {
                        console.log(`AudioAnalyzer available after ${i * delay}ms`);
                        return true;
                    }
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
                console.error(`AudioAnalyzer not available after ${maxAttempts * delay}ms`);
                return false;
            }
            
            // Initialize after DOM is ready and AudioAnalyzer is loaded
            async function initializeAudioMapping() {
                // Wait for DOM to be ready
                if (document.readyState === 'loading') {
                    await new Promise(resolve => {
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', resolve, { once: true });
                        } else {
                            resolve();
                        }
                    });
                }
                
                // Wait for AudioAnalyzer to be available
                const analyzerReady = await waitForAudioAnalyzer();
                if (!analyzerReady) {
                    console.error('AudioAnalyzer not available after waiting - audio mapping will not work');
                    // Still initialize UI but disable functionality
                    initAudioMappingUI();
                    setupAudioReactiveToggle();
                    return;
                }
                
                // Now initialize
                try {
                    await initAudioAnalyzer();
                    initAudioMappingUI();
                    setupAudioReactiveToggle();
                    audioMappingInitialized = true;
                    console.log('Audio mapping initialized successfully');
                } catch (err) {
                    console.error('Failed to initialize audio mapping:', err);
                }
            }
            
            // Start initialization - use multiple strategies to ensure it works
            if (document.readyState === 'complete' || document.readyState === 'interactive') {
                // DOM already ready, start immediately
                initializeAudioMapping();
            } else {
                // Wait for DOM
                document.addEventListener('DOMContentLoaded', initializeAudioMapping, { once: true });
            }
            
            // Fallback: also try after a short delay in case DOMContentLoaded already fired
            setTimeout(() => {
                if (!audioMappingInitialized) {
                    console.log('Retrying audio mapping initialization...');
                    initializeAudioMapping();
                }
            }, 100);
            
            // Update loop
            let updateFrameCount = 0;
            function audioMappingUpdate() {
                updateFrameCount++;
                
                // Always update diagnostics and metrics visualization if analyzer exists
                if (audioMappingInitialized && audioAnalyzer) {
                    try {
                        // Always update offsets for display (even if audio reactive is off)
                        updateAudioOffsets();
                        updateDiagnostics();
                        updateMetricsVisualization();
                        
                        // Debug: log every 60 frames to verify loop is running and values are updating
                        if (updateFrameCount % 60 === 0 && audioAnalyzer.isEnabled) {
                            const testMetrics = audioAnalyzer.getMetrics();
                            const testNormalized = audioAnalyzer.normalizedMetrics || null;
                            console.log('Audio mapping update:', {
                                frame: updateFrameCount,
                                audioEnabled: audioAnalyzer.isEnabled,
                                audioReactiveEnabled: window.audioReactiveEnabled,
                                hasMetrics: !!testMetrics,
                                hasNormalizedMetrics: !!testNormalized,
                                audioAmp: testMetrics?.u_audioAmp?.toFixed(3),
                                normalizedAmp: testNormalized?.audioAmp?.toFixed(3),
                                collision: testMetrics?.u_collision?.toFixed(3),
                                normalizedCollision: testNormalized?.collision?.toFixed(3),
                                normalizedKeys: testNormalized ? Object.keys(testNormalized) : []
                            });
                        }
                    } catch (e) {
                        console.error('Error in audio mapping update loop:', e);
                    }
                }
                requestAnimationFrame(audioMappingUpdate);
            }
            audioMappingUpdate();
            
            // Export for use in render loop
            window.getAudioOffset = (paramName) => {
                return audioOffsets[paramName] || 0.0;
            };
            
            // Make audioReactiveEnabled accessible globally
            // Initialize to true since checkbox is checked by default
            window.audioReactiveEnabled = true;
            audioReactiveEnabled = true;
            window.setAudioReactiveEnabled = (enabled) => {
                window.audioReactiveEnabled = enabled;
                audioReactiveEnabled = enabled;
            };
            
            window.getAudioMappingConfig = () => audioMappingConfig;
            window.setAudioMappingConfig = (config) => {
                audioMappingConfig = config;
                // Update UI
                Object.keys(audioMappingConfig).forEach(paramName => {
                    const mappingId = `mapping-${paramName}`;
                    const config = audioMappingConfig[paramName];
                    const enabledCheckbox = document.getElementById(`${mappingId}-enabled`);
                    const sensitivitySlider = document.getElementById(`${mappingId}-sensitivity`);
                    const sensitivityNum = document.getElementById(`${mappingId}-sensitivity-num`);
                    const smoothingSlider = document.getElementById(`${mappingId}-smoothing`);
                    const smoothingNum = document.getElementById(`${mappingId}-smoothing-num`);
                    const multiplierSlider = document.getElementById(`${mappingId}-multiplier`);
                    const multiplierNum = document.getElementById(`${mappingId}-multiplier-num`);
                    const offsetSlider = document.getElementById(`${mappingId}-offset`);
                    const offsetNum = document.getElementById(`${mappingId}-offset-num`);
                    
                    if (enabledCheckbox) enabledCheckbox.checked = config.enabled;
                    if (sensitivitySlider) sensitivitySlider.value = config.sensitivity;
                    if (sensitivityNum) sensitivityNum.value = config.sensitivity;
                    if (smoothingSlider) smoothingSlider.value = config.smoothing;
                    if (smoothingNum) smoothingNum.value = config.smoothing;
                    if (multiplierSlider) multiplierSlider.value = config.multiplier;
                    if (multiplierNum) multiplierNum.value = config.multiplier;
                    if (offsetSlider) offsetSlider.value = config.offset;
                    if (offsetNum) offsetNum.value = config.offset;
                });
            };
        })();

        })(); // End of main async IIFE
    </script>
</body>
</html>

