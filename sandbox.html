<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Droplet Visual Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #hotkey-legend {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            color: #fff;
            font-size: 10px;
            z-index: 1001;
            font-family: monospace;
            min-width: 220px;
        }
        
        #hotkey-legend h4 {
            margin: 0 0 8px 0;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        
        #hotkey-legend .hotkey-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            padding: 2px 0;
        }
        
        #hotkey-legend .hotkey-item:last-child {
            margin-bottom: 0;
        }
        
        #hotkey-legend .hotkey-key {
            color: #0af;
            font-weight: 600;
            min-width: 60px;
        }
        
        #hotkey-legend .hotkey-desc {
            color: #bbb;
            text-align: right;
            flex: 1;
        }
        
        #status-indicators {
            position: fixed;
            top: 10px;
            left: 10px;
            margin-top: 0;
            display: flex;
            gap: 4px;
            font-size: 9px;
            z-index: 1002;
            pointer-events: none;
        }
        
        #status-indicators span {
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        #dev-toolbox {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            color: #fff;
            min-width: 280px;
            max-width: 320px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 11px;
        }
        
        #dev-toolbox h3 {
            margin: 0 0 10px 0;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        .section-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-header::after {
            content: '▾';
            font-size: 10px;
            color: #777;
        }
        
        .section-header.collapsed::after {
            content: '▸';
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 10px;
            color: #bbb;
            font-weight: 500;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-row input[type="range"] {
            flex: 1;
            margin: 0;
        }
        
        .control-row .value {
            font-size: 10px;
            color: #888;
            font-family: monospace;
            min-width: 45px;
            text-align: right;
            padding: 2px 4px;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: text;
            user-select: text;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .control-row .value:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #555;
        }
        
        .control-row .value:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #0af;
            color: #fff;
        }
        
        .resolution-btn.active {
            background: #0af !important;
            color: #000 !important;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 2px;
        }
        
        .control-group .value {
            font-size: 10px;
            color: #888;
            font-family: monospace;
            padding: 2px 4px;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: text;
            user-select: text;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .control-group .value:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #555;
        }
        
        .control-group .value:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #0af;
            color: #fff;
        }
        
        .control-group select,
        .control-group input[type="text"],
        .control-group button {
            font-size: 10px;
            padding: 3px 6px;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .section-header {
            margin-top: 12px;
            margin-bottom: 6px;
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        
        .section-header:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        /* Curve Editor Styles */
        .curve-btn {
            display: none; /* Hidden by default */
            width: 18px;
            height: 18px;
            margin-left: 6px;
            cursor: pointer;
            vertical-align: middle;
            background: #333;
            border: 1px solid #555;
            border-radius: 3px;
            color: #aaa;
            font-size: 14px;
            line-height: 16px;
            text-align: center;
            user-select: none;
            font-weight: bold;
        }
        
        /* Show curve button on hover of control-group */
        .control-group:hover .curve-btn {
            display: inline-block;
        }
        
        .curve-btn:hover {
            background: #444;
            border-color: #0af;
            color: #0af;
        }
        
        .curve-editor-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .curve-editor-overlay.active {
            display: flex;
        }
        
        .curve-editor {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            min-width: 500px;
            max-width: 600px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        .curve-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .curve-editor-title {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
        }
        
        .curve-editor-close {
            background: none;
            border: none;
            color: #aaa;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            line-height: 1;
        }
        
        .curve-editor-close:hover {
            color: #fff;
        }
        
        .curve-canvas-container {
            position: relative;
            margin: 15px 0;
            border: 1px solid #333;
            border-radius: 4px;
            background: #0a0a0a;
        }
        
        .curve-canvas {
            display: block;
            width: 100%;
            height: 300px;
            cursor: crosshair;
        }
        
        .curve-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 15px;
        }
        
        .curve-control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .curve-control-group label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .curve-control-group input[type="number"] {
            background: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            width: 100%;
        }
        
        .curve-control-group input[type="number"]:focus {
            outline: none;
            border-color: #0af;
        }
        
        .curve-power-slider {
            margin-top: 10px;
        }
        
        .curve-power-slider label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 5px;
        }
        
        .curve-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: flex-end;
        }
        
        .curve-btn-action {
            padding: 6px 12px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .curve-btn-action:hover {
            background: #444;
            border-color: #666;
        }
        
        .curve-btn-primary {
            background: #0af;
            border-color: #0af;
        }
        
        .curve-btn-primary:hover {
            background: #1bf;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Curve Editor Overlay -->
    <div id="curve-editor-overlay" class="curve-editor-overlay">
        <div class="curve-editor">
            <div class="curve-editor-header">
                <div class="curve-editor-title" id="curve-editor-title">Parameter Curve Editor</div>
                <button class="curve-editor-close" id="curve-editor-close">&times;</button>
            </div>
            <div class="curve-canvas-container">
                <canvas id="curve-canvas" class="curve-canvas"></canvas>
            </div>
            <div class="curve-controls">
                <div class="curve-control-group">
                    <label>Min Value</label>
                    <input type="number" id="curve-min" step="any" value="0">
                </div>
                <div class="curve-control-group">
                    <label>Max Value</label>
                    <input type="number" id="curve-max" step="any" value="1">
                </div>
            </div>
            <div class="curve-power-slider">
                <label>Curve Power (exponent): <span id="curve-power-value">1.0</span></label>
                <input type="range" id="curve-power" min="0.1" max="5" step="0.1" value="1.0">
            </div>
            <div class="curve-actions">
                <button class="curve-btn-action" id="curve-reset">Reset</button>
                <button class="curve-btn-action" id="curve-apply">Apply</button>
                <button class="curve-btn-action curve-btn-primary" id="curve-close">Done</button>
            </div>
        </div>
    </div>
    
    <!-- Shader scripts (embedded to avoid CORS issues) -->
    <script id="star-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>
    
    <script id="star-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_spikiness;      // 0.0 = circle, 1.0 = maximum spikes
        uniform float u_spikeFrequency; // Continuous number of spikes (2-20)
        uniform float u_spikeSharpness; // 0.0 = rounded, 1.0 = sharp spikes
        uniform float u_hue;
        uniform float u_scale;
        uniform float u_rotation;
        uniform float u_autoRotationSpeed;
        uniform float u_blendOpacity;
        uniform float u_fillSize;       // 0.0 = no fill, 1.0 = fill to edge
        uniform float u_fillOpacity;   // 0.0 = transparent, 1.0 = opaque

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            // Normalize coordinates
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec2 center = vec2(0.5);
            
            // Convert to centered coordinates
            vec2 p = (uv - center) * vec2(u_resolution.x / u_resolution.y, 1.0);
            
            // Rotate coordinates (manual rotation + auto rotation)
            float autoRotation = -u_time * u_autoRotationSpeed; // Auto rotation in degrees (reversed direction)
            float totalRotation = u_rotation + autoRotation;
            float rotationRad = totalRotation * 3.14159 / 180.0;
            float cosRot = cos(rotationRad);
            float sinRot = sin(rotationRad);
            vec2 rotatedP = vec2(
                p.x * cosRot - p.y * sinRot,
                p.x * sinRot + p.y * cosRot
            );
            
            // Draw a morphing shape (circle to spikes)
            float angle = atan(rotatedP.y, rotatedP.x);
            float dist = length(rotatedP);
            
            // Base radius scales with u_scale
            float baseRadius = u_scale * 0.4;
            
            // Calculate shape modulation
            // Use continuous spike frequency (not discrete)
            float modulation = cos(angle * u_spikeFrequency);
            
            // Apply sharpness: sharper spikes use power function
            // When sharpness = 0: smooth cosine wave
            // When sharpness = 1: sharp peaks (using power function)
            float sharpModulation;
            if (u_spikeSharpness < 0.01) {
                // No sharpness: use smooth cosine
                sharpModulation = modulation;
            } else {
                // Apply power function to sharpen peaks
                // Higher sharpness = steeper peaks
                float power = 1.0 / (1.0 + u_spikeSharpness * 3.0); // Range: 1.0 to ~0.25
                sharpModulation = pow(abs(modulation), power) * sign(modulation);
            }
            
            // Apply spikiness: interpolate between circle (0) and spiked shape (1)
            float spikeAmount = u_scale * 0.25 * u_spikiness;
            float r = baseRadius + spikeAmount * sharpModulation;
            
            // Draw the outline - this is the primary shape definition
            float lineWidth = 0.012;
            float outline = smoothstep(lineWidth, 0.0, abs(dist - r));
            
            // Draw the fill separately - parameterized by size and opacity
            float fillRadius = r * u_fillSize; // Fill size: 0.0 = no fill, 1.0 = fill to edge
            float fill = 0.0;
            if (u_fillSize > 0.0 && dist < fillRadius) {
                // Smooth falloff for fill interior
                float fillFalloff = smoothstep(fillRadius, fillRadius * 0.8, dist);
                fill = fillFalloff * u_fillOpacity; // Apply fill opacity
            }
            
            // Combine outline and fill
            // Outline is always full brightness, fill adds to it with its opacity
            float shape = max(outline, fill);
            
            // Convert hue to RGB (hue in degrees, saturation=1.0, value=1.0)
            // Add slow automatic hue shift over time (full cycle every 30 seconds)
            float autoHueShift = u_time * 12.0; // 360 degrees / 30 seconds = 12 deg/sec
            float finalHue = mod(u_hue + autoHueShift, 360.0);
            vec3 hsv = vec3(finalHue / 360.0, 1.0, 1.0);
            vec3 color = hsv2rgb(hsv) * shape;
            
            // Apply opacity for blend control
            gl_FragColor = vec4(color, u_blendOpacity);
        }
    </script>
    
    <script id="dilation-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_uv = a_position * 0.5 + 0.5;
            v_uv.y = 1.0 - v_uv.y; // Flip Y
        }
    </script>
    
    <script id="dilation-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform sampler2D u_history;
        uniform vec2 u_resolution;
        uniform float u_expansionFactor;
        uniform float u_fadeAmount;
        uniform float u_hueShiftAmount;
        uniform float u_noiseAmount;
        uniform float u_noiseRate;
        uniform float u_blurAmount;
        uniform float u_blurRate;
        uniform float u_time;
        varying vec2 v_uv;

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        // Convert RGB to HSV
        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        void main() {
            vec2 uv = v_uv;
            vec2 center = vec2(0.5);
            vec2 dir = uv - center;
            vec2 scaledDir = dir / u_expansionFactor; // Scale inward to sample outward
            vec2 sampleUV = scaledDir + center;
            
            // Check if current pixel is at the center (within small radius)
            float distFromCenter = length(dir);
            float centerRadius = 0.002; // Very small radius around center (about 2 pixels at 1000px resolution)
            
            vec4 history;
            if (distFromCenter < centerRadius) {
                // At center: sample neighboring pixels and average them
                // Sample 8 neighboring pixels in a ring around center
                float sampleRadius = 0.003; // Slightly larger radius for neighbors
                vec4 neighborSum = vec4(0.0);
                float neighborCount = 0.0;
                
                // Sample neighbors in 8 directions
                for (float angle = 0.0; angle < 6.28318; angle += 0.785398) { // 8 directions (2*PI/8)
                    vec2 neighborDir = vec2(cos(angle), sin(angle)) * sampleRadius;
                    vec2 neighborUV = sampleUV + neighborDir;
                    vec4 neighbor = texture2D(u_history, neighborUV);
                    neighborSum += neighbor;
                    neighborCount += 1.0;
                }
                
                // Use average of neighbors, or black if no valid neighbors
                history = neighborCount > 0.0 ? neighborSum / neighborCount : vec4(0.0, 0.0, 0.0, 0.0);
            } else {
                // Check if we're sampling from the center region (prevent center pixels from propagating outward)
                vec2 sampleDir = sampleUV - center;
                float sampleDistFromCenter = length(sampleDir);
                
                if (sampleDistFromCenter < centerRadius) {
                    // If sampling from center, use black/transparent to prevent propagation
                    history = vec4(0.0, 0.0, 0.0, 0.0);
                } else {
                    // Normal sampling
                    history = texture2D(u_history, sampleUV);
                }
            }
            
            // Fade based on expansion (further from center = more faded)
            // distFromCenter already calculated above
            // Use logarithmic fade curve for smoother transitions
            // Map distance to fade using a power curve for more gradual fade
            float fadeAmount = smoothstep(0.0, 0.8, distFromCenter); // Fade as it expands
            // Apply logarithmic fade: fade = 1 - fadeAmount^fadePower
            // u_fadeAmount range: 0 to 5.0
            // Higher values create more gradual fades
            float fadePower = 1.0 + u_fadeAmount * 2.0; // Range: 1.0 to 11.0 when u_fadeAmount is 0 to 5
            float fade = 1.0 - pow(fadeAmount, fadePower);
            
            // Decay factor: reduce brightness over time to prevent accumulation
            // Estimate age based on distance (further = older = more decay)
            float ageEstimate = distFromCenter * 2.0; // Rough estimate of "age"
            float decayRate = 0.98; // Decay 2% per frame (adjustable)
            float decay = pow(decayRate, ageEstimate); // Exponential decay
            
            // Hue shift based on expansion
            float hueShift = distFromCenter * u_hueShiftAmount; // Use parameterized hue shift
            
            // Convert RGB to HSV, shift hue, convert back
            vec3 hsv = rgb2hsv(history.rgb);
            hsv.x = fract(hsv.x + hueShift); // Shift hue (wrap around)
            hsv.z *= fade * decay; // Apply both fade and decay to value
            vec3 shiftedColor = hsv2rgb(hsv);
            
            // Apply simple radial blur based on u_blurAmount (time-based application)
            if (u_blurAmount > 0.0 && u_blurRate > 0.0) {
                // Calculate interval: rate 1.0 = every 2 seconds, rate 0.5 = every 4 seconds, etc.
                float blurInterval = 2.0 / u_blurRate;
                // Apply blur during a small window (0.1 seconds) of each interval
                float blurWindow = 0.1;
                float blurPhase = mod(u_time, blurInterval);
                if (blurPhase < blurWindow) {
                    float blurRadius = 1.5 * u_blurAmount / u_resolution.x;
                    vec4 sum = vec4(shiftedColor, history.a);
                    float count = 1.0;
                    for (int i = 0; i < 6; i++) {
                        float a = float(i) / 6.0 * 6.28318;
                        vec2 offset = vec2(cos(a), sin(a)) * blurRadius;
                        sum += texture2D(u_history, uv + offset);
                        count += 1.0;
                    }
                    shiftedColor = (sum / count).rgb;
                }
            }
            
            // Apply animated noise based on u_noiseAmount and u_noiseRate (time-based application)
            if (u_noiseAmount > 0.0 && u_noiseRate > 0.0) {
                // Calculate interval: rate 1.0 = every 2 seconds, rate 0.5 = every 4 seconds, etc.
                float noiseInterval = 2.0 / u_noiseRate;
                // Apply noise during a small window (0.1 seconds) of each interval
                float noiseWindow = 0.1;
                float noisePhase = mod(u_time, noiseInterval);
                if (noisePhase < noiseWindow) {
                    float t = u_time * 10.0; // Animation speed within the window
                    float n = fract(sin(dot(uv * (t + 1.0), vec2(12.9898,78.233))) * 43758.5453);
                    vec3 grain = mix(vec3(1.0), vec3(n), u_noiseAmount);
                    shiftedColor *= grain;
                }
            }
            
            // Clamp to prevent overflow from additive blending
            shiftedColor = clamp(shiftedColor, 0.0, 1.0);
            
            gl_FragColor = vec4(shiftedColor, history.a * fade * decay);
        }
    </script>
    <script src="vendor/gif.js"></script>
    
    <div id="hotkey-legend">
        <h4>Hotkeys</h4>
        <div class="hotkey-item">
            <span class="hotkey-key">Space</span>
            <span class="hotkey-desc">Toggle Freeze</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">R</span>
            <span class="hotkey-desc">Randomize</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">← →</span>
            <span class="hotkey-desc">Cycle Presets</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">J</span>
            <span class="hotkey-desc">Toggle Jiggle</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">Esc</span>
            <span class="hotkey-desc">Clear Screen</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↑</span>
            <span class="hotkey-desc">Accelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↓</span>
            <span class="hotkey-desc">Decelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">S</span>
            <span class="hotkey-desc">Snapshot (PNG)</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">G</span>
            <span class="hotkey-desc">Record GIF (max 10s)</span>
        </div>
    </div>
    
    <div id="status-indicators">
        <span id="freeze-indicator" style="display: none; background: #0af; color: #fff;">FREEZE</span>
        <span id="jiggle-indicator" style="display: none; background: #a0a; color: #fff;">JIGGLE</span>
        <span id="unsaved-indicator" style="display: none; background: #fa0; color: #fff;">UNSAVED</span>
        <span id="record-indicator" style="display: none; background: #e33; color: #fff;">RECORD</span>
    </div>
    
    <div id="dev-toolbox">
        <h3>Controls</h3>
        
        <div class="control-group">
            <label for="preset-select">Preset</label>
            <select id="preset-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="">-- Select --</option>
            </select>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <input type="text" id="preset-name-input" placeholder="Name" style="flex: 1; font-size: 10px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <button id="save-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                <button id="delete-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #a00; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Del</button>
            </div>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <button id="export-presets-btn" style="font-size: 10px; padding: 3px 6px; background: #0a0; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Export</button>
                <label for="import-presets-input" style="font-size: 10px; padding: 3px 6px; background: #fa0; color: #fff; border: none; border-radius: 3px; cursor: pointer; display: inline-block; height: auto; line-height: normal; box-sizing: border-box;">Import</label>
                <input type="file" id="import-presets-input" accept=".json,.txt" style="display: none;">
            </div>
        </div>
        
        <div class="section-header">Resolution</div>
        <div class="control-group">
            <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                <button id="res-4k-btn" class="resolution-btn" data-resolution="4k" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">4K UHD</button>
                <button id="res-pc-btn" class="resolution-btn" data-resolution="pc" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Full HD</button>
                <button id="res-mobile-btn" class="resolution-btn" data-resolution="mobile" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Mobile</button>
                <button id="res-window-btn" class="resolution-btn" data-resolution="window" style="font-size: 10px; padding: 4px 8px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px; cursor: pointer;">Window</button>
            </div>
            <div id="current-resolution-display" style="margin-top: 4px; font-size: 9px; color: #aaa;">Current: Window Size</div>
        </div>
        
        <div class="section-header">Shape</div>
        <div class="control-group">
            <label for="spikiness-slider">Spikiness<span class="curve-btn" data-param="spikiness" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spikiness-slider" min="0" max="100" value="50" step="1">
                <div class="value" contenteditable="true" id="spikiness-value">0.50</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-frequency-slider">Frequency<span class="curve-btn" data-param="spikeFrequency" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spike-frequency-slider" min="2" max="20" value="5" step="0.1">
                <div class="value" contenteditable="true" id="spike-frequency-value">5.0</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-sharpness-slider">Sharpness<span class="curve-btn" data-param="spikeSharpness" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="spike-sharpness-slider" min="0" max="100" value="0" step="1">
                <div class="value" contenteditable="true" id="spike-sharpness-value">0.00</div>
            </div>
        </div>
        
        <div class="section-header">Appearance</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-slider">Hue<span class="curve-btn" data-param="hue" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="hue-slider" min="0" max="360" value="45" step="1">
                    <div class="value" contenteditable="true" id="hue-value">45°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="scale-slider">Scale<span class="curve-btn" data-param="scale" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="scale-slider" min="0.05" max="1.0" value="0.2" step="0.01">
                    <div class="value" contenteditable="true" id="scale-value">0.20</div>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="control-group">
                <label for="fill-size-slider">Fill Size<span class="curve-btn" data-param="fillSize" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="fill-size-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="fill-size-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="fill-opacity-slider">Fill Opacity<span class="curve-btn" data-param="fillOpacity" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="fill-opacity-slider" min="0" max="100" value="60" step="1">
                    <div class="value" contenteditable="true" id="fill-opacity-value">0.60</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Emanation</div>
        <div class="control-group">
            <label for="dilation-slider">Dilation Speed<span class="curve-btn" data-param="dilationSpeed" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="dilation-slider" min="0" max="200" value="20" step="1">
                <div class="value" contenteditable="true" id="dilation-value">1.01</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="fade-slider">Fade Amount<span class="curve-btn" data-param="fadeAmount" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="fade-slider" min="0" max="100" value="30" step="1">
                <div class="value" contenteditable="true" id="fade-value">0.30</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="emanation-rate-slider">Rate (per sec)<span class="curve-btn" data-param="emanationRate" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="emanation-rate-slider" min="2" max="200" value="2" step="0.1">
                <div class="value" contenteditable="true" id="emanation-rate-value">2.0</div>
            </div>
        </div>
        
        <div class="section-header">Filters</div>
        <div class="two-column">
            <div class="control-group">
                <label for="noise-amount-slider">Noise Amount<span class="curve-btn" data-param="noiseAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="noise-amount-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="noise-amount-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="noise-rate-slider">Noise Rate (1.0 = every 2s)<span class="curve-btn" data-param="noiseRate" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="noise-rate-slider" min="0" max="100" value="0" step="0.1">
                    <div class="value" contenteditable="true" id="noise-rate-value">0.0</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blur-amount-slider">Blur Amount<span class="curve-btn" data-param="blurAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blur-amount-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="blur-amount-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blur-rate-slider">Blur Rate (1.0 = every 2s)<span class="curve-btn" data-param="blurRate" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blur-rate-slider" min="0" max="100" value="0" step="0.1">
                    <div class="value" contenteditable="true" id="blur-rate-value">0.0</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Rotation</div>
        <div class="two-column">
            <div class="control-group">
                <label for="rotation-slider">Manual<span class="curve-btn" data-param="rotation" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="rotation-slider" min="0" max="360" value="0" step="1">
                    <div class="value" contenteditable="true" id="rotation-value">0°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="auto-rotation-slider">Auto (deg/s)<span class="curve-btn" data-param="autoRotationSpeed" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="auto-rotation-slider" min="0" max="200" value="50" step="1">
                    <div class="value" contenteditable="true" id="auto-rotation-value">30°</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Effects</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-shift-slider">Hue Shift<span class="curve-btn" data-param="hueShiftAmount" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="hue-shift-slider" min="0.0" max="0.2" value="0.05" step="0.001">
                    <div class="value" contenteditable="true" id="hue-shift-value">0.050</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blend-opacity-slider">Opacity<span class="curve-btn" data-param="blendOpacity" title="Edit curve">~</span></label>
                <div class="control-row">
                    <input type="range" id="blend-opacity-slider" min="0.0" max="1.0" value="0.3" step="0.01">
                    <div class="value" contenteditable="true" id="blend-opacity-value">0.30</div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="blend-mode-select">Blend Mode</label>
            <select id="blend-mode-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="additive">Additive</option>
                <option value="alpha" selected>Alpha Blend</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
            </select>
        </div>
        
        <div class="section-header">Actions</div>
        <div class="control-group">
            <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                <button id="randomize-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Randomize</button>
                <button id="jiggle-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #a0a; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Jiggle</button>
            </div>
            <label for="jiggle-amount-slider">Jiggle Amount<span class="curve-btn" data-param="jiggleAmount" title="Edit curve">~</span></label>
            <div class="control-row">
                <input type="range" id="jiggle-amount-slider" min="0" max="100" value="10" step="1">
                <div class="value" contenteditable="true" id="jiggle-amount-value">10%</div>
            </div>
        </div>
    </div>
    
    <script>
        // Resolution configuration
        const RESOLUTIONS = {
            '4k': { width: 3840, height: 2160, name: '4K UHD' },
            'pc': { width: 1920, height: 1080, name: 'Full HD' },
            'mobile': { width: 1080, height: 1920, name: 'Mobile' },
            'window': { width: null, height: null, name: 'Window Size' }
        };
        
        // Parse URL parameters
        function getUrlParam(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }
        
        // Get current resolution setting
        let currentResolution = getUrlParam('resolution') || 'window';
        if (!RESOLUTIONS[currentResolution]) {
            currentResolution = 'window';
        }
        
        // Simple WebGL renderer
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.program = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                const res = RESOLUTIONS[currentResolution];
                if (res.width && res.height) {
                    // Fixed resolution
                    this.canvas.width = res.width;
                    this.canvas.height = res.height;
                } else {
                    // Window size
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                }
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Resize textures if they exist
                if (this.historyTexture && this.currentTexture) {
                    this.setupFramebuffers();
                }
            }
            
            setupFramebuffers() {
                const gl = this.gl;
                
                // Create or recreate history texture
                if (this.historyTexture) {
                    gl.deleteTexture(this.historyTexture);
                }
                if (this.historyFramebuffer) {
                    gl.deleteFramebuffer(this.historyFramebuffer);
                }
                
                this.historyTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.historyFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.historyTexture, 0);
                
                // Create or recreate current texture
                if (this.currentTexture) {
                    gl.deleteTexture(this.currentTexture);
                }
                if (this.currentFramebuffer) {
                    gl.deleteFramebuffer(this.currentFramebuffer);
                }
                
                this.currentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.currentFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.currentTexture, 0);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const info = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${info}`);
                }
                
                return shader;
            }
            
            init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource) {
                const gl = this.gl;
                
                // Compile shape shader
                const vertexShader = this.compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.program);
                    throw new Error(`Program linking error: ${info}`);
                }
                
                // Compile dilation shader
                const dilationVertexShader = this.compileShader(dilationVertexSource, gl.VERTEX_SHADER);
                const dilationFragmentShader = this.compileShader(dilationFragmentSource, gl.FRAGMENT_SHADER);
                this.dilationProgram = gl.createProgram();
                gl.attachShader(this.dilationProgram, dilationVertexShader);
                gl.attachShader(this.dilationProgram, dilationFragmentShader);
                gl.linkProgram(this.dilationProgram);
                
                if (!gl.getProgramParameter(this.dilationProgram, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.dilationProgram);
                    throw new Error(`Dilation program linking error: ${info}`);
                }
                
                // Setup full-screen quad (shared buffer)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1
                ]);
                
                this.quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Setup position attribute for shape program
                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup position attribute for dilation program
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup framebuffers
                this.setupFramebuffers();
                
                // Clear history texture to black
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                gl.useProgram(this.program);
            }
            
            setUniform(name, value, program = null) {
                const gl = this.gl;
                const targetProgram = program || this.program;
                const location = gl.getUniformLocation(targetProgram, name);
                
                if (location === null) return;
                
                if (typeof value === 'number') {
                    gl.uniform1f(location, value);
                } else if (Array.isArray(value)) {
                    if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    } else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                }
            }
            
            setBlendMode(mode, opacity) {
                const gl = this.gl;
                
                switch(mode) {
                    case 'additive':
                        // Additive: src + dst (bright, accumulates)
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'alpha':
                        // Alpha blend: src * alpha + dst * (1 - alpha)
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'multiply':
                        // Multiply: src * dst (darker)
                        gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'screen':
                        // Screen: 1 - (1 - src) * (1 - dst) (lighter)
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'overlay':
                        // Overlay: if dst < 0.5: 2 * multiply, else: 2 * screen - 1
                        // True overlay requires reading destination buffer (not possible with simple blend funcs)
                        // Approximation: use a combination that's closer to overlay behavior
                        // Using DST_COLOR with ONE gives multiply-like effect for darker areas
                        gl.blendFunc(gl.DST_COLOR, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    default:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                }
                
                // Apply opacity by modifying blend color (requires shader modification)
                // For now, opacity affects the shape shader output
            }
            
            render(uniforms, dilationFactor, shouldCaptureShape, fadeAmount, hueShiftAmount, emanationRate, noiseAmount, noiseRate, blurAmount, blurRate, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation) {
                const gl = this.gl;
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                const shapePositionLocation = gl.getAttribLocation(this.program, 'a_position');
                
                // Calculate center pixel coordinates for clearing
                const centerX = Math.floor(this.canvas.width / 2);
                const centerY = Math.floor(this.canvas.height / 2);
                
                // Step 1: Dilation pass - expand history texture
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                
                // Setup vertex attributes
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Set dilation uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                const dilationHistoryLocation = gl.getUniformLocation(this.dilationProgram, 'u_history');
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', dilationFactor, this.dilationProgram);
                this.setUniform('u_fadeAmount', fadeAmount, this.dilationProgram);
                this.setUniform('u_hueShiftAmount', hueShiftAmount, this.dilationProgram);
                this.setUniform('u_noiseAmount', noiseAmount, this.dilationProgram);
                this.setUniform('u_noiseRate', noiseRate, this.dilationProgram);
                this.setUniform('u_blurAmount', blurAmount, this.dilationProgram);
                this.setUniform('u_blurRate', blurRate, this.dilationProgram);
                this.setUniform('u_time', uniforms.u_time || 0.0, this.dilationProgram);
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Clear center 4 pixels to prevent white accumulation
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(centerX - 1, centerY - 1, 2, 2);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.disable(gl.SCISSOR_TEST);
                
                // Step 2: Draw current shape (only add to history if shouldCaptureShape is true)
                // This controls the emanation rate - how frequently new shapes are captured
                if (shouldCaptureShape) {
                    gl.useProgram(this.program);
                    gl.enableVertexAttribArray(shapePositionLocation);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Enable blending with configurable mode
                    gl.enable(gl.BLEND);
                    this.setBlendMode(blendMode, blendOpacity);
                    
                    Object.keys(uniforms).forEach(name => {
                        this.setUniform(name, uniforms[name]);
                    });
                    this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                    this.setUniform('u_rotation', totalRotation); // Capture total rotation at this moment
                    this.setUniform('u_autoRotationSpeed', 0.0); // Disable auto-rotation for captured shapes (they're frozen)
                    this.setUniform('u_blendOpacity', blendOpacity);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND);
                }
                
                // Step 3: Display current texture to screen
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for display
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 4: Draw current star on top of everything (always visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable blending with configurable mode
                gl.enable(gl.BLEND);
                this.setBlendMode(blendMode, blendOpacity);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                this.setUniform('u_rotation', rotation);
                this.setUniform('u_autoRotationSpeed', autoRotationSpeed);
                this.setUniform('u_blendOpacity', blendOpacity);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 5: Copy current texture to history for next frame (always, for smooth dilation)
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for copy
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        
        // Get shader from script tag
        function getShader(id) {
            const script = document.getElementById(id);
            if (!script) {
                throw new Error(`Shader script not found: ${id}`);
            }
            return script.textContent;
        }
        
        // Initialize
        function init() {
            const canvas = document.getElementById('canvas');
            const renderer = new SimpleRenderer(canvas);
            
            // Get shaders from script tags
            const vertexSource = getShader('star-vertex-shader');
            const fragmentSource = getShader('star-fragment-shader');
            const dilationVertexSource = getShader('dilation-vertex-shader');
            const dilationFragmentSource = getShader('dilation-fragment-shader');
            
            renderer.init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource);
            
            return { renderer, canvas };
        }
        
        const { renderer, canvas } = init();
        
        // Curve Editor System
        (() => {
            const curveEditorOverlay = document.getElementById('curve-editor-overlay');
            const curveEditorClose = document.getElementById('curve-editor-close');
            const curveCanvas = document.getElementById('curve-canvas');
            const curveCtx = curveCanvas.getContext('2d');
            const curveMinInput = document.getElementById('curve-min');
            const curveMaxInput = document.getElementById('curve-max');
            const curvePowerSlider = document.getElementById('curve-power');
            const curvePowerValue = document.getElementById('curve-power-value');
            const curveEditorTitle = document.getElementById('curve-editor-title');
            const curveResetBtn = document.getElementById('curve-reset');
            const curveApplyBtn = document.getElementById('curve-apply');
            const curveDoneBtn = document.getElementById('curve-close');
            
            let currentParam = null;
            let curveSettings = {}; // Store curve settings per parameter
            let isDragging = false;
            let dragStartX = 0;
            let dragStartY = 0;
            
            // Default curve settings
            function getDefaultCurveSettings() {
                return {
                    min: 0,
                    max: 1,
                    power: 1.0, // Linear by default
                    type: 'power' // 'power' for exponential, could extend to 'bezier' later
                };
            }
            
            // Parameter-specific default settings
            function getParamDefaultSettings(paramName) {
                const defaults = {
                    // Shape parameters (0-1 range)
                    'spikiness': { min: 0, max: 1, power: 1.0 },
                    'spikeSharpness': { min: 0, max: 1, power: 1.0 },
                    'fillSize': { min: 0, max: 1, power: 1.0 },
                    'fillOpacity': { min: 0, max: 1, power: 1.0 },
                    'blendOpacity': { min: 0, max: 1, power: 1.0 },
                    'jiggleAmount': { min: 0, max: 1, power: 1.0 },
                    
                    // Frequency parameters
                    'spikeFrequency': { min: 2, max: 20, power: 1.0 },
                    
                    // Angle parameters
                    'hue': { min: 0, max: 360, power: 1.0 },
                    'rotation': { min: 0, max: 360, power: 1.0 },
                    
                    // Scale parameters
                    'scale': { min: 0.05, max: 1.0, power: 1.0 },
                    
                    // Rate parameters (with exponential curves)
                    'emanationRate': { min: 2, max: 200, power: 1.0 },
                    'noiseRate': { min: 0, max: 10, power: 0.333 }, // Exponential (1/3 power)
                    'blurRate': { min: 0, max: 10, power: 0.333 }, // Exponential (1/3 power)
                    'autoRotationSpeed': { min: -1, max: 360, power: 0.5 }, // Exponential (0.5 power, range -1 to 360)
                    
                    // Amount parameters (with exponential curves)
                    'noiseAmount': { min: 0, max: 1, power: 0.25 }, // Exponential (1/4 power)
                    'blurAmount': { min: 0, max: 1, power: 0.25 }, // Exponential (1/4 power)
                    'fadeAmount': { min: 0, max: 5, power: 0.333 }, // Exponential (1/3 power, range 0-5)
                    'hueShiftAmount': { min: 0, max: 0.2, power: 1.0 },
                    
                    // Dilation speed (complex mapping - approximate with range)
                    'dilationSpeed': { min: 0.88, max: 1.22, power: 0.125 }, // Very slow exponential (1/8 power)
                };
                return defaults[paramName] || null;
            }
            
            // Get or create curve settings for a parameter
            function getCurveSettings(paramName) {
                if (!curveSettings[paramName]) {
                    // Start with parameter-specific defaults if available
                    const paramDefaults = getParamDefaultSettings(paramName);
                    curveSettings[paramName] = { ...getDefaultCurveSettings(), ...(paramDefaults || {}) };
                    // Load from localStorage if available (overrides defaults)
                    const saved = localStorage.getItem(`curve_${paramName}`);
                    if (saved) {
                        try {
                            curveSettings[paramName] = { ...curveSettings[paramName], ...JSON.parse(saved) };
                        } catch (e) {
                            console.warn('Failed to load curve settings for', paramName);
                        }
                    }
                }
                return curveSettings[paramName];
            }
            
            // Save curve settings
            function saveCurveSettings(paramName) {
                if (curveSettings[paramName]) {
                    localStorage.setItem(`curve_${paramName}`, JSON.stringify(curveSettings[paramName]));
                }
            }
            
            // Map slider value (0-100) to output using curve
            function mapValue(sliderValue, settings) {
                if (!settings) settings = getDefaultCurveSettings();
                const normalized = sliderValue / 100.0;
                const curved = Math.pow(normalized, settings.power);
                return settings.min + curved * (settings.max - settings.min);
            }
            
            // Reverse map: output value to slider (0-100)
            function reverseMapValue(outputValue, settings) {
                if (!settings) settings = getDefaultCurveSettings();
                const normalized = (outputValue - settings.min) / (settings.max - settings.min);
                if (normalized <= 0) return 0;
                if (normalized >= 1) return 100;
                const curved = Math.pow(normalized, 1.0 / settings.power);
                return curved * 100;
            }
            
            // Draw curve on canvas
            function drawCurve() {
                const width = curveCanvas.width = curveCanvas.offsetWidth;
                const height = curveCanvas.height = curveCanvas.offsetHeight;
                const padding = 40;
                const w = width - padding * 2;
                const h = height - padding * 2;
                
                curveCtx.clearRect(0, 0, width, height);
                curveCtx.fillStyle = '#0a0a0a';
                curveCtx.fillRect(0, 0, width, height);
                
                const settings = currentParam ? getCurveSettings(currentParam) : getDefaultCurveSettings();
                
                // Draw grid
                curveCtx.strokeStyle = '#222';
                curveCtx.lineWidth = 1;
                for (let i = 0; i <= 10; i++) {
                    const x = padding + (w * i / 10);
                    const y = padding + (h * i / 10);
                    curveCtx.beginPath();
                    curveCtx.moveTo(x, padding);
                    curveCtx.lineTo(x, padding + h);
                    curveCtx.stroke();
                    curveCtx.beginPath();
                    curveCtx.moveTo(padding, y);
                    curveCtx.lineTo(padding + w, y);
                    curveCtx.stroke();
                }
                
                // Draw axes
                curveCtx.strokeStyle = '#555';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                curveCtx.moveTo(padding, padding);
                curveCtx.lineTo(padding, padding + h);
                curveCtx.lineTo(padding + w, padding + h);
                curveCtx.stroke();
                
                // Draw curve
                curveCtx.strokeStyle = '#0af';
                curveCtx.lineWidth = 2;
                curveCtx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const x = padding + (w * i / 100);
                    const normalized = i / 100.0;
                    const curved = Math.pow(normalized, settings.power);
                    const outputValue = settings.min + curved * (settings.max - settings.min);
                    const normalizedOutput = (outputValue - settings.min) / (settings.max - settings.min);
                    const y = padding + h - (normalizedOutput * h);
                    if (i === 0) {
                        curveCtx.moveTo(x, y);
                    } else {
                        curveCtx.lineTo(x, y);
                    }
                }
                curveCtx.stroke();
                
                // Draw current slider position if applicable
                if (currentParam) {
                    const slider = document.getElementById(`${currentParam}-slider`);
                    if (slider) {
                        const sliderValue = parseFloat(slider.value);
                        const x = padding + (w * sliderValue / 100);
                        const output = mapValue(sliderValue, settings);
                        const normalizedOutput = (output - settings.min) / (settings.max - settings.min);
                        const y = padding + h - (normalizedOutput * h);
                        
                        curveCtx.fillStyle = '#ff0';
                        curveCtx.beginPath();
                        curveCtx.arc(x, y, 5, 0, Math.PI * 2);
                        curveCtx.fill();
                    }
                }
                
                // Draw labels
                curveCtx.fillStyle = '#aaa';
                curveCtx.font = '10px monospace';
                curveCtx.textAlign = 'center';
                curveCtx.fillText('Input (0-100)', padding + w / 2, height - 10);
                curveCtx.save();
                curveCtx.translate(15, padding + h / 2);
                curveCtx.rotate(-Math.PI / 2);
                curveCtx.fillText('Output', 0, 0);
                curveCtx.restore();
                
                // Draw min/max labels
                curveCtx.fillStyle = '#888';
                curveCtx.font = '9px monospace';
                curveCtx.textAlign = 'right';
                curveCtx.fillText(settings.max.toFixed(2), padding - 10, padding + 5);
                curveCtx.fillText(settings.min.toFixed(2), padding - 10, padding + h + 5);
                curveCtx.textAlign = 'left';
                curveCtx.fillText('0', padding + 5, height - 10);
                curveCtx.fillText('100', padding + w - 25, height - 10);
            }
            
            // Open curve editor for a parameter
            function openCurveEditor(paramName) {
                currentParam = paramName;
                const settings = getCurveSettings(paramName);
                
                // Update UI
                const paramLabel = document.querySelector(`[data-param="${paramName}"]`)?.parentElement?.textContent || paramName;
                curveEditorTitle.textContent = `Curve Editor: ${paramLabel}`;
                curveMinInput.value = settings.min;
                curveMaxInput.value = settings.max;
                curvePowerSlider.value = settings.power;
                curvePowerValue.textContent = settings.power.toFixed(2);
                
                // Show editor
                curveEditorOverlay.classList.add('active');
                drawCurve();
                
                // Update canvas on resize
                window.addEventListener('resize', drawCurve);
            }
            
            // Close curve editor
            function closeCurveEditor() {
                curveEditorOverlay.classList.remove('active');
                currentParam = null;
                window.removeEventListener('resize', drawCurve);
            }
            
            // Apply curve settings
            function applyCurveSettings() {
                if (!currentParam) return;
                
                const settings = getCurveSettings(currentParam);
                settings.min = parseFloat(curveMinInput.value) || 0;
                settings.max = parseFloat(curveMaxInput.value) || 1;
                settings.power = parseFloat(curvePowerSlider.value) || 1.0;
                
                // Ensure min < max
                if (settings.min >= settings.max) {
                    settings.max = settings.min + 0.01;
                    curveMaxInput.value = settings.max;
                }
                
                saveCurveSettings(currentParam);
                drawCurve();
                
                // Trigger update of current slider value
                const slider = document.getElementById(`${currentParam}-slider`);
                if (slider && slider.oninput) {
                    slider.oninput({ target: slider });
                }
            }
            
            // Reset curve to default
            function resetCurve() {
                if (!currentParam) return;
                curveSettings[currentParam] = getDefaultCurveSettings();
                curveMinInput.value = curveSettings[currentParam].min;
                curveMaxInput.value = curveSettings[currentParam].max;
                curvePowerSlider.value = curveSettings[currentParam].power;
                curvePowerValue.textContent = curveSettings[currentParam].power.toFixed(2);
                drawCurve();
            }
            
            // Event listeners
            curveEditorClose.addEventListener('click', closeCurveEditor);
            curveDoneBtn.addEventListener('click', () => {
                applyCurveSettings();
                closeCurveEditor();
            });
            curveApplyBtn.addEventListener('click', applyCurveSettings);
            curveResetBtn.addEventListener('click', resetCurve);
            
            curveMinInput.addEventListener('input', () => {
                applyCurveSettings();
            });
            
            curveMaxInput.addEventListener('input', () => {
                applyCurveSettings();
            });
            
            curvePowerSlider.addEventListener('input', (e) => {
                curvePowerValue.textContent = parseFloat(e.target.value).toFixed(2);
                applyCurveSettings();
            });
            
            // Click outside to close
            curveEditorOverlay.addEventListener('click', (e) => {
                if (e.target === curveEditorOverlay) {
                    closeCurveEditor();
                }
            });
            
            // Make curve editor available globally
            window.CurveEditor = {
                open: openCurveEditor,
                mapValue: mapValue,
                reverseMapValue: reverseMapValue,
                getCurveSettings: getCurveSettings
            };
        })();
        
        (() => {
            // Get slider elements
            const spikinessSlider = document.getElementById('spikiness-slider');
            const spikeFrequencySlider = document.getElementById('spike-frequency-slider');
            const spikeSharpnessSlider = document.getElementById('spike-sharpness-slider');
            const hueSlider = document.getElementById('hue-slider');
            const scaleSlider = document.getElementById('scale-slider');
            const dilationSlider = document.getElementById('dilation-slider');
            const fadeSlider = document.getElementById('fade-slider');
            const hueShiftSlider = document.getElementById('hue-shift-slider');
            const rotationSlider = document.getElementById('rotation-slider');
            const spikinessValue = document.getElementById('spikiness-value');
            const spikeFrequencyValue = document.getElementById('spike-frequency-value');
            const spikeSharpnessValue = document.getElementById('spike-sharpness-value');
            const hueValue = document.getElementById('hue-value');
            const scaleValue = document.getElementById('scale-value');
            const dilationValue = document.getElementById('dilation-value');
            const fadeValue = document.getElementById('fade-value');
            const hueShiftValue = document.getElementById('hue-shift-value');
            const rotationValue = document.getElementById('rotation-value');
            const blendModeSelect = document.getElementById('blend-mode-select');
            const blendOpacitySlider = document.getElementById('blend-opacity-slider');
            const blendOpacityValue = document.getElementById('blend-opacity-value');
            const fillSizeSlider = document.getElementById('fill-size-slider');
            const fillSizeValue = document.getElementById('fill-size-value');
            const fillOpacitySlider = document.getElementById('fill-opacity-slider');
            const fillOpacityValue = document.getElementById('fill-opacity-value');
            const randomizeBtn = document.getElementById('randomize-btn');
            const jiggleBtn = document.getElementById('jiggle-btn');
            const jiggleAmountSlider = document.getElementById('jiggle-amount-slider');
            const jiggleAmountValue = document.getElementById('jiggle-amount-value');
            
            // Get emanation rate slider before initializing values
            const emanationRateSlider = document.getElementById('emanation-rate-slider');
            const emanationRateValue = document.getElementById('emanation-rate-value');
            const autoRotationSlider = document.getElementById('auto-rotation-slider');
            const autoRotationValue = document.getElementById('auto-rotation-value');
            
            // Filter sliders
            const noiseAmountSlider = document.getElementById('noise-amount-slider');
            const noiseAmountValue = document.getElementById('noise-amount-value');
            const noiseRateSlider = document.getElementById('noise-rate-slider');
            const noiseRateValue = document.getElementById('noise-rate-value');
            const blurAmountSlider = document.getElementById('blur-amount-slider');
            const blurAmountValue = document.getElementById('blur-amount-value');
            const blurRateSlider = document.getElementById('blur-rate-slider');
            const blurRateValue = document.getElementById('blur-rate-value');
            
            // GIF capture state
            const captureCanvas = document.createElement('canvas');
            const captureCtx = captureCanvas.getContext('2d');
            let gifRecording = false;
            let gifCaptureFrames = [];
            let gifCaptureTimer = null;
            let gifCountdownTimer = null;
            let gifCaptureStart = 0;
            let gifCaptureWidth = 0;
            let gifCaptureHeight = 0;
            const GIF_FPS = 15;
            const GIF_MAX_MS = 10000; // 10s max
            
            // Get preset management elements before defining functions
            const presetSelect = document.getElementById('preset-select');
            const presetNameInput = document.getElementById('preset-name-input');
            const savePresetBtn = document.getElementById('save-preset-btn');
            const deletePresetBtn = document.getElementById('delete-preset-btn');
            const exportPresetsBtn = document.getElementById('export-presets-btn');
            const importPresetsInput = document.getElementById('import-presets-input');
            
            // Status indicators
            const freezeIndicator = document.getElementById('freeze-indicator');
            const jiggleIndicator = document.getElementById('jiggle-indicator');
            const unsavedIndicator = document.getElementById('unsaved-indicator');
            const statusIndicators = document.getElementById('status-indicators');
            const hotkeyLegend = document.getElementById('hotkey-legend');
            const recordIndicator = document.getElementById('record-indicator');
            
            // Position status indicators below hotkey legend
            function positionStatusIndicators() {
                if (hotkeyLegend && statusIndicators) {
                    const rect = hotkeyLegend.getBoundingClientRect();
                    statusIndicators.style.top = (rect.bottom + 6) + 'px';
                    statusIndicators.style.left = rect.left + 'px';
                }
            }
            // Position on load and resize
            positionStatusIndicators();
            window.addEventListener('resize', positionStatusIndicators);
            
            // Track last loaded preset for unsaved changes detection
            let lastLoadedPresetName = null;
            let lastLoadedPresetValues = null;
            
            // Function to update status indicators
            function updateStatusIndicators() {
                freezeIndicator.style.display = freezeEnabled ? 'inline-block' : 'none';
                jiggleIndicator.style.display = jiggleEnabled ? 'inline-block' : 'none';
                
                // Check if current values differ from last loaded preset
                if (lastLoadedPresetName && lastLoadedPresetValues) {
                    const currentValues = {
                        spikiness, spikeFrequency, spikeSharpness, hue, scale,
                        fillSize, fillOpacity, rotation, hueShiftAmount,
                        dilationSpeed, fadeAmount, emanationRate, autoRotationSpeed,
                        blendMode, blendOpacity
                    };
                    
                    // Compare values (with small tolerance for floating point)
                    let hasChanges = false;
                    for (const [key, currentValue] of Object.entries(currentValues)) {
                        const lastValue = lastLoadedPresetValues[key];
                        if (lastValue !== undefined && Math.abs(currentValue - lastValue) > 0.001) {
                            hasChanges = true;
                            break;
                        }
                    }
                    // Also check blendMode (string comparison)
                    if (currentValues.blendMode !== lastLoadedPresetValues.blendMode) {
                        hasChanges = true;
                    }
                    
                    unsavedIndicator.style.display = hasChanges ? 'inline-block' : 'none';
                } else {
                    unsavedIndicator.style.display = 'none';
                }
            }
            
            // Collapsible dev-tool sections
            const sectionHeaders = Array.from(document.querySelectorAll('#dev-toolbox .section-header'));
            sectionHeaders.forEach((header) => {
                header.addEventListener('click', () => {
                    const collapsed = header.classList.toggle('collapsed');
                    let el = header.nextElementSibling;
                    while (el && !el.classList.contains('section-header')) {
                        if (collapsed) {
                            el.dataset._display = el.style.display || '';
                            el.style.display = 'none';
                        } else {
                            el.style.display = el.dataset._display || '';
                        }
                        el = el.nextElementSibling;
                    }
                });
            });
            
            // Preset management functions (need to be defined before we try to load presets)
            // Load presets from localStorage
            function loadPresets() {
                const presets = JSON.parse(localStorage.getItem('sandboxPresets') || '{}');
                presetSelect.innerHTML = '<option value="">-- Select Preset --</option>';
                Object.keys(presets).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    presetSelect.appendChild(option);
                });
                return presets;
            }
            
            // Load preset
            function loadPreset(name) {
                const presets = loadPresets();
                if (!presets[name]) {
                    alert('Preset not found');
                    return;
                }
                
                const preset = presets[name];
                
                // Set all values
                // Handle migration from old "spikes" parameter to new shape parameters
                if (preset.spikes !== undefined) {
                    // Old preset format: convert discrete spikes to continuous parameters
                    const oldSpikes = preset.spikes;
                    spikiness = 0.8; // Default spikiness for old presets
                    spikeFrequency = Math.max(2.0, Math.min(20.0, oldSpikes)); // Use old spike count as frequency
                    spikeSharpness = 0.0; // Default sharpness
                } else {
                    // New preset format
                    spikiness = preset.spikiness !== undefined ? preset.spikiness : 0.5;
                    spikeFrequency = preset.spikeFrequency !== undefined ? preset.spikeFrequency : 5.0;
                    spikeSharpness = preset.spikeSharpness !== undefined ? preset.spikeSharpness : 0.0;
                }
                hue = preset.hue;
                scale = preset.scale;
                hueShiftAmount = preset.hueShiftAmount;
                rotation = preset.rotation;
                blendMode = preset.blendMode;
                blendOpacity = preset.blendOpacity;
                fillSize = preset.fillSize !== undefined ? preset.fillSize : 0.0;
                fillOpacity = preset.fillOpacity !== undefined ? preset.fillOpacity : 0.6;
                emanationRate = preset.emanationRate !== undefined ? preset.emanationRate : 2.0;
                noiseAmount = preset.noiseAmount !== undefined ? preset.noiseAmount : 0.0;
                noiseRate = preset.noiseRate !== undefined ? preset.noiseRate : 0.0;
                blurAmount = preset.blurAmount !== undefined ? preset.blurAmount : 0.0;
                blurRate = preset.blurRate !== undefined ? preset.blurRate : 0.0;
                autoRotationSpeed = preset.autoRotationSpeed;
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = hue;
                hueValue.textContent = hue + '°';
                scaleSlider.value = scale;
                scaleValue.textContent = scale.toFixed(2);
                dilationSlider.value = preset.dilationSlider || 20;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(parseFloat(dilationSlider.value) / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = preset.fadeSlider || 30;
                fadeAmount = Math.pow(parseFloat(fadeSlider.value) / 100.0, 1.0 / 3.0) * 5.0;
                fadeValue.textContent = fadeAmount.toFixed(3);
                hueShiftSlider.value = hueShiftAmount;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                rotationSlider.value = rotation;
                rotationValue.textContent = rotation + '°';
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                emanationRateSlider.value = emanationRate;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                noiseRateSlider.value = noiseRateToSlider(noiseRate);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                blurAmountSlider.value = blurAmountToSlider(blurAmount);
                blurAmountValue.textContent = blurAmount.toFixed(2);
                blurRateSlider.value = blurRateToSlider(blurRate);
                blurRateValue.textContent = blurRate.toFixed(2);
                // Use stored slider value if available, otherwise reverse map from speed value
                if (preset.autoRotationSlider !== undefined) {
                    autoRotationSlider.value = preset.autoRotationSlider;
                    autoRotationSpeed = -1.0 + Math.pow(preset.autoRotationSlider / 200.0, 0.5) * 361.0;
                } else {
                    // Fallback: reverse map from speed value
                    const sliderValue = Math.round(200 * Math.pow((autoRotationSpeed + 1) / 361.0, 2));
                    autoRotationSlider.value = sliderValue;
                }
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Update base values to match loaded preset
                updateBaseValues();
                
                // Update dropdown to show the loaded preset
                presetSelect.value = name;
            }
            
            // Initialize presets dropdown
            loadPresets();
            
            // Try to load last active preset BEFORE initializing default values
            const lastActivePreset = localStorage.getItem('sandboxLastActivePreset');
            let presetLoaded = false;
            if (lastActivePreset) {
                const presets = loadPresets();
                if (presets[lastActivePreset]) {
                    presetSelect.value = lastActivePreset;
                    presetLoaded = true;
                }
            }
            
            // Helper function to map slider value using curve editor
            function mapParamValue(paramName, sliderValue, sliderMax = 100) {
                const settings = window.CurveEditor?.getCurveSettings(paramName);
                if (settings && window.CurveEditor) {
                    // Normalize slider value to 0-100 range
                    const normalized = (sliderValue / sliderMax) * 100;
                    return window.CurveEditor.mapValue(normalized, settings);
                }
                return null; // Will fall back to original mapping
            }
            
            // Helper function to reverse map value to slider using curve editor
            function reverseMapParamValue(paramName, value, sliderMax = 100) {
                const settings = window.CurveEditor?.getCurveSettings(paramName);
                if (settings && window.CurveEditor) {
                    const sliderValue = window.CurveEditor.reverseMapValue(value, settings);
                    // Convert from 0-100 range to actual slider range
                    return (sliderValue / 100.0) * sliderMax;
                }
                return null; // Will fall back to original mapping
            }
            
            // Current values (initialize from sliders, or from preset if one was loaded)
            const initialSpikinessSlider = parseFloat(spikinessSlider.value);
            let spikiness = mapParamValue('spikiness', initialSpikinessSlider) ?? (initialSpikinessSlider / 100.0);
            
            const initialSpikeFrequencySlider = parseFloat(spikeFrequencySlider.value);
            let spikeFrequency = mapParamValue('spikeFrequency', initialSpikeFrequencySlider, 20) ?? initialSpikeFrequencySlider;
            
            const initialSpikeSharpnessSlider = parseFloat(spikeSharpnessSlider.value);
            let spikeSharpness = mapParamValue('spikeSharpness', initialSpikeSharpnessSlider) ?? (initialSpikeSharpnessSlider / 100.0);
            
            const initialHueSlider = parseFloat(hueSlider.value);
            let hue = mapParamValue('hue', initialHueSlider, 360) ?? initialHueSlider;
            
            const initialScaleSlider = parseFloat(scaleSlider.value);
            let scale = mapParamValue('scale', initialScaleSlider, 1.0) ?? initialScaleSlider;
            
            // Initialize dilation speed
            const initialDilationSlider = parseFloat(dilationSlider.value);
            let dilationSpeed = mapParamValue('dilationSpeed', initialDilationSlider, 200);
            if (dilationSpeed === null) {
                // Fallback to original exponential mapping
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(initialDilationSlider / 200.0, 1.0 / 8.0) * range;
            }
            
            // Initialize fade amount
            const initialFadeSlider = parseFloat(fadeSlider.value);
            fadeAmount = mapParamValue('fadeAmount', initialFadeSlider) ?? (Math.pow(initialFadeSlider / 100.0, 1.0 / 3.0) * 5.0);
            
            const initialHueShiftSlider = parseFloat(hueShiftSlider.value);
            let hueShiftAmount = mapParamValue('hueShiftAmount', initialHueShiftSlider, 0.2) ?? initialHueShiftSlider;
            
            const initialRotationSlider = parseFloat(rotationSlider.value);
            let rotation = mapParamValue('rotation', initialRotationSlider, 360) ?? initialRotationSlider;
            
            let blendMode = blendModeSelect.value;
            
            const initialBlendOpacitySlider = parseFloat(blendOpacitySlider.value);
            let blendOpacity = mapParamValue('blendOpacity', initialBlendOpacitySlider, 1.0) ?? initialBlendOpacitySlider;
            
            const initialFillSizeSlider = parseFloat(fillSizeSlider.value);
            let fillSize = mapParamValue('fillSize', initialFillSizeSlider) ?? (initialFillSizeSlider / 100.0);
            
            const initialFillOpacitySlider = parseFloat(fillOpacitySlider.value);
            let fillOpacity = mapParamValue('fillOpacity', initialFillOpacitySlider) ?? (initialFillOpacitySlider / 100.0);
            
            const initialEmanationRateSlider = parseFloat(emanationRateSlider.value);
            let emanationRate = mapParamValue('emanationRate', initialEmanationRateSlider, 200) ?? initialEmanationRateSlider;
            
            // Initialize noise amount with curve editor mapping
            const initialNoiseSlider = parseFloat(noiseAmountSlider.value);
            let noiseAmount = mapParamValue('noiseAmount', initialNoiseSlider) ?? (Math.pow(initialNoiseSlider / 100.0, 1.0 / 4.0));
            
            // Initialize noise rate
            const initialNoiseRateSlider = parseFloat(noiseRateSlider.value);
            let noiseRate = mapParamValue('noiseRate', initialNoiseRateSlider) ?? (Math.pow(initialNoiseRateSlider / 100.0, 1.0 / 3.0) * 10.0);
            
            // Initialize blur amount
            const initialBlurSlider = parseFloat(blurAmountSlider.value);
            let blurAmount = mapParamValue('blurAmount', initialBlurSlider) ?? (Math.pow(initialBlurSlider / 100.0, 1.0 / 4.0));
            
            // Initialize blur rate
            const initialBlurRateSlider = parseFloat(blurRateSlider.value);
            let blurRate = mapParamValue('blurRate', initialBlurRateSlider) ?? (Math.pow(initialBlurRateSlider / 100.0, 1.0 / 3.0) * 10.0);
            
            const initialJiggleAmountSlider = parseFloat(jiggleAmountSlider.value);
            let jiggleAmount = mapParamValue('jiggleAmount', initialJiggleAmountSlider) ?? (initialJiggleAmountSlider / 100.0);
            jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            let jiggleEnabled = false;
            
            // Hotkey / playback state
            let freezeEnabled = false;
            let originalDilationSpeed = dilationSpeed;
            
            // Store base values for jiggle (when jiggle is off, these match current values)
            let baseSpikiness = spikiness;
            let baseSpikeFrequency = spikeFrequency;
            let baseSpikeSharpness = spikeSharpness;
            let baseHue = hue;
            let baseScale = scale;
            let baseFillSize = fillSize;
            let baseFillOpacity = fillOpacity;
            let baseRotation = rotation;
            let baseHueShiftAmount = hueShiftAmount;
            let baseDilationSpeed = dilationSpeed;
            let baseFadeAmount = fadeAmount;
            let baseEmanationRate = emanationRate;
            let baseNoiseAmount = noiseAmount;
            let baseNoiseRate = noiseRate;
            let baseBlurAmount = blurAmount;
            let baseBlurRate = blurRate;
            let baseBlendOpacity = blendOpacity;
            
            // Initialize auto rotation speed
            const initialAutoRotationSlider = parseFloat(autoRotationSlider.value);
            let autoRotationSpeed = mapParamValue('autoRotationSpeed', initialAutoRotationSlider, 200);
            if (autoRotationSpeed === null) {
                // Fallback to original exponential mapping
                autoRotationSpeed = -1.0 + Math.pow(initialAutoRotationSlider / 200.0, 0.5) * 361.0;
            }
            
            // Now initialize baseAutoRotationSpeed after autoRotationSpeed is declared
            let baseAutoRotationSpeed = autoRotationSpeed;
            
            // Target origins for jiggle when user edits params during jiggle
            // Jiggle will smoothly ease its orbit center toward these targets
            let targetBaseSpikiness = baseSpikiness;
            let targetBaseSpikeFrequency = baseSpikeFrequency;
            let targetBaseSpikeSharpness = baseSpikeSharpness;
            let targetBaseHue = baseHue;
            let targetBaseScale = baseScale;
            let targetBaseFillSize = baseFillSize;
            let targetBaseFillOpacity = baseFillOpacity;
            let targetBaseRotation = baseRotation;
            let targetBaseHueShiftAmount = baseHueShiftAmount;
            let targetBaseDilationSpeed = baseDilationSpeed;
            let targetBaseFadeAmount = baseFadeAmount;
            let targetBaseEmanationRate = baseEmanationRate;
            let targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
            let targetBaseNoiseAmount = baseNoiseAmount;
            let targetBaseNoiseRate = baseNoiseRate;
            let targetBaseBlurAmount = baseBlurAmount;
            let targetBaseBlurRate = baseBlurRate;
            let targetBaseBlendOpacity = baseBlendOpacity;
            
            // Now load the preset if one was found (this will override the default values)
            if (presetLoaded) {
                loadPreset(lastActivePreset);
            } else {
                // If no preset loaded, initialize status indicators
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
        
            // Helper function to handle editable value changes
            // Direct input bypasses clamping - allows any value
            function handleValueEdit(valueElement, parseFn, formatFn, updateFn) {
                valueElement.addEventListener('blur', (e) => {
                    const text = e.target.textContent.trim();
                    const numValue = parseFn(text);
                    if (!isNaN(numValue)) {
                        // No clamping - accept the value as-is
                        const formatted = formatFn(numValue);
                        e.target.textContent = formatted;
                        updateFn(numValue);
                    } else {
                        // Restore previous value on invalid input
                        const currentValue = parseFn(e.target.textContent);
                        if (!isNaN(currentValue)) {
                            e.target.textContent = formatFn(currentValue);
                        }
                    }
                });
                
                valueElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    }
                });
            }
            
            // Update sliders
            spikinessSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                spikiness = mapParamValue('spikiness', sliderValue) ?? (sliderValue / 100.0);
                spikinessValue.textContent = spikiness.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikinessValue, 
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    spikiness = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikiness');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikinessSlider.value = reverseMapParamValue('spikiness', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        spikinessSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            spikeFrequencySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                spikeFrequency = mapParamValue('spikeFrequency', sliderValue, 20) ?? sliderValue;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                updateBaseValues();
            });
            
            handleValueEdit(spikeFrequencyValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    spikeFrequency = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikeFrequency');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikeFrequencySlider.value = reverseMapParamValue('spikeFrequency', clampedForDisplay, 20) ?? clampedForDisplay;
                    } else {
                        const clampedForSlider = Math.max(2, Math.min(20, val));
                        spikeFrequencySlider.value = clampedForSlider;
                    }
                    updateBaseValues();
                }
            );
            
            spikeSharpnessSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                spikeSharpness = mapParamValue('spikeSharpness', sliderValue) ?? (sliderValue / 100.0);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikeSharpnessValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    spikeSharpness = val;
                    const settings = window.CurveEditor?.getCurveSettings('spikeSharpness');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        spikeSharpnessSlider.value = reverseMapParamValue('spikeSharpness', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        spikeSharpnessSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            hueSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                hue = mapParamValue('hue', sliderValue, 360) ?? sliderValue;
                hueValue.textContent = Math.round(hue) + '°';
                updateBaseValues();
            });
            
            handleValueEdit(hueValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    hue = val;
                    const settings = window.CurveEditor?.getCurveSettings('hue');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        hueSlider.value = reverseMapParamValue('hue', clampedForDisplay, 360) ?? Math.round(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(360, val));
                        hueSlider.value = Math.round(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            scaleSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                scale = mapParamValue('scale', sliderValue, 1.0) ?? sliderValue;
                scaleValue.textContent = scale.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(scaleValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    scale = val;
                    const settings = window.CurveEditor?.getCurveSettings('scale');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        const sliderVal = reverseMapParamValue('scale', clampedForDisplay, 1.0) ?? clampedForDisplay;
                        scaleSlider.value = sliderVal.toFixed(2);
                        scaleValue.textContent = clampedForDisplay.toFixed(2);
                    } else {
                        const clampedForSlider = Math.max(0.05, Math.min(1.0, val));
                        scaleSlider.value = clampedForSlider.toFixed(2);
                        scaleValue.textContent = clampedForSlider.toFixed(2);
                    }
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map dilation speed to slider value
            function dilationSpeedToSlider(speed) {
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                // Reverse: speed = min + (slider/200)^(1/8) * range
                // slider = 200 * ((speed - min) / range)^8
                const normalized = (speed - min) / range;
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
            }
            
            dilationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                dilationSpeed = mapParamValue('dilationSpeed', sliderValue, 200);
                if (dilationSpeed === null) {
                    // Fallback to original exponential mapping
                    const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                    const range = (1.22 - 0.88) / (1.0 - midPower);
                    const min = 1.0 - midPower * range;
                    dilationSpeed = min + Math.pow(sliderValue / 200.0, 1.0 / 8.0) * range;
                }
                dilationValue.textContent = dilationSpeed.toFixed(4);
            });
            
            handleValueEdit(dilationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(4),
                (val) => {
                    dilationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0.88, Math.min(1.22, val));
                    dilationSlider.value = dilationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map fade amount to slider value
            function fadeAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/3) * 5.0
                // slider = 100 * (amount / 5.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount / 5.0)), 3));
            }
            
            fadeSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fadeAmount = mapParamValue('fadeAmount', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 5.0);
                fadeValue.textContent = fadeAmount.toFixed(3);
            });
            
            handleValueEdit(fadeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    fadeAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(5.0, val));
                    fadeSlider.value = fadeAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            hueShiftSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                hueShiftAmount = mapParamValue('hueShiftAmount', sliderValue, 0.2) ?? sliderValue;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                updateBaseValues();
            });
            
            handleValueEdit(hueShiftValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    hueShiftAmount = val;
                    const settings = window.CurveEditor?.getCurveSettings('hueShiftAmount');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        hueShiftSlider.value = reverseMapParamValue('hueShiftAmount', clampedForDisplay, 0.2) ?? clampedForDisplay.toFixed(3);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(0.2, val));
                        hueShiftSlider.value = clampedForSlider.toFixed(3);
                    }
                    updateBaseValues();
                }
            );
            
            rotationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                rotation = mapParamValue('rotation', sliderValue, 360) ?? sliderValue;
                rotationValue.textContent = Math.round(rotation) + '°';
                updateBaseValues();
            });
            
            handleValueEdit(rotationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    rotation = val;
                    const settings = window.CurveEditor?.getCurveSettings('rotation');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        rotationSlider.value = reverseMapParamValue('rotation', clampedForDisplay, 360) ?? Math.round(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(360, val));
                        rotationSlider.value = Math.round(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            blendModeSelect.addEventListener('change', (e) => {
                blendMode = e.target.value;
                updateStatusIndicators();
            });
            
            blendOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blendOpacity = mapParamValue('blendOpacity', sliderValue, 1.0) ?? sliderValue;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blendOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blendOpacity = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blendOpacitySlider.value = clampedForSlider.toFixed(2);
                    updateBaseValues();
                }
            );
            
            fillSizeSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fillSize = mapParamValue('fillSize', sliderValue) ?? (sliderValue / 100.0);
                fillSizeValue.textContent = fillSize.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillSizeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillSize = val;
                    const settings = window.CurveEditor?.getCurveSettings('fillSize');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        fillSizeSlider.value = reverseMapParamValue('fillSize', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        fillSizeSlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            fillOpacitySlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                fillOpacity = mapParamValue('fillOpacity', sliderValue) ?? (sliderValue / 100.0);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillOpacity = val;
                    const settings = window.CurveEditor?.getCurveSettings('fillOpacity');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        fillOpacitySlider.value = reverseMapParamValue('fillOpacity', clampedForDisplay) ?? (clampedForDisplay * 100);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        fillOpacitySlider.value = Math.round(clampedForSlider * 100);
                    }
                    updateBaseValues();
                }
            );
            
            emanationRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                emanationRate = mapParamValue('emanationRate', sliderValue, 200) ?? sliderValue;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                updateStatusIndicators();
            });
            
            handleValueEdit(emanationRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    emanationRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(2, Math.min(200, val));
                    emanationRateSlider.value = clampedForSlider;
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map noise amount to slider value
            function noiseAmountToSlider(amount) {
                // Use curve editor reverse mapping if available
                const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                if (settings && window.CurveEditor) {
                    return window.CurveEditor.reverseMapValue(amount, settings);
                }
                // Fallback to default exponential mapping
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount)), 4));
            }
            
            // Noise amount slider with curve editor mapping
            noiseAmountSlider.addEventListener('input', (e) => {
                // Map slider value (0-100) to noise amount using curve editor
                const sliderValue = parseFloat(e.target.value);
                const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                if (settings && window.CurveEditor) {
                    noiseAmount = window.CurveEditor.mapValue(sliderValue, settings);
                } else {
                    // Fallback to default exponential mapping
                    noiseAmount = Math.pow(sliderValue / 100.0, 1.0 / 4.0);
                }
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(noiseAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    noiseAmount = val;
                    // Update slider position using curve editor reverse mapping
                    // This will clamp the slider display to the curve's min/max range
                    const settings = window.CurveEditor?.getCurveSettings('noiseAmount');
                    if (settings) {
                        const clampedForDisplay = Math.max(settings.min, Math.min(settings.max, val));
                        noiseAmountSlider.value = noiseAmountToSlider(clampedForDisplay);
                    } else {
                        const clampedForSlider = Math.max(0, Math.min(1, val));
                        noiseAmountSlider.value = noiseAmountToSlider(clampedForSlider);
                    }
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map noise rate to slider value (slow exponential curve)
            function noiseRateToSlider(rate) {
                // Map rate (0-10) to slider (0-100) with exponential curve
                // rate = (slider / 100)^(1/3) * 10.0
                // slider = 100 * (rate / 10.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, rate / 10.0)), 3) * 10) / 10; // Round to 0.1
            }
            
            // Noise rate slider (0-100 slider maps to 0-10 rate with slow exponential curve, where 1.0 = every 2 seconds)
            noiseRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                noiseRate = mapParamValue('noiseRate', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 10.0);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(noiseRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    noiseRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(10, val));
                    noiseRateSlider.value = noiseRateToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Blur amount slider
            // Helper function to reverse-map blur amount to slider value
            function blurAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/4)
                // slider = 100 * amount^4
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount)), 4));
            }
            
            // Blur amount slider with exponential mapping (0-100 slider to 0-1, granular near 0)
            blurAmountSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blurAmount = mapParamValue('blurAmount', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 4.0));
                blurAmountValue.textContent = blurAmount.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blurAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blurAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blurAmountSlider.value = blurAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map blur rate to slider value (slow exponential curve)
            function blurRateToSlider(rate) {
                // Map rate (0-10) to slider (0-100) with exponential curve
                // rate = (slider / 100)^(1/3) * 10.0
                // slider = 100 * (rate / 10.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, rate / 10.0)), 3) * 10) / 10; // Round to 0.1
            }
            
            // Blur rate slider (0-100 slider maps to 0-10 rate with slow exponential curve, where 1.0 = every 2 seconds)
            blurRateSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                blurRate = mapParamValue('blurRate', sliderValue) ?? (Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 10.0);
                blurRateValue.textContent = blurRate.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blurRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blurRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(10, val));
                    blurRateSlider.value = blurRateToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map auto rotation speed to slider value
            function autoRotationSpeedToSlider(speed) {
                // Reverse: speed = -1 + (slider/200)^0.5 * 361
                // slider = 200 * ((speed + 1) / 361)^2
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, (speed + 1) / 361.0)), 2));
            }
            
            autoRotationSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                autoRotationSpeed = mapParamValue('autoRotationSpeed', sliderValue, 200);
                if (autoRotationSpeed === null) {
                    // Fallback to original exponential mapping
                    autoRotationSpeed = -1.0 + Math.pow(sliderValue / 200.0, 0.5) * 361.0;
                }
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                updateStatusIndicators();
            });
            
            handleValueEdit(autoRotationValue,
                (text) => parseFloat(text.replace(/[^0-9.-]/g, '')),
                (val) => val.toFixed(1) + '°',
                (val) => {
                    autoRotationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(-1, Math.min(360, val));
                    autoRotationSlider.value = autoRotationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Wire up curve editor buttons
            document.querySelectorAll('.curve-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paramName = btn.getAttribute('data-param');
                    if (paramName && window.CurveEditor) {
                        window.CurveEditor.open(paramName);
                    }
                });
            });
            
            // Save current state as preset
            function savePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please enter a preset name');
                    return;
                }
                
                const preset = {
                    spikiness: spikiness,
                    spikeFrequency: spikeFrequency,
                    spikeSharpness: spikeSharpness,
                    hue: hue,
                    scale: scale,
                    fillSize: fillSize,
                    fillOpacity: fillOpacity,
                    dilationSlider: parseFloat(dilationSlider.value), // Store slider value for proper restoration
                    fadeSlider: parseFloat(fadeSlider.value), // Store slider value for proper restoration
                    hueShiftAmount: hueShiftAmount,
                    rotation: rotation,
                    blendMode: blendMode,
                    blendOpacity: blendOpacity,
                    emanationRate: emanationRate,
                    noiseAmount: noiseAmount,
                    noiseRate: noiseRate,
                    blurAmount: blurAmount,
                    blurRate: blurRate,
                    autoRotationSpeed: autoRotationSpeed, // Store actual value (will reverse map to slider on load)
                    autoRotationSlider: parseFloat(autoRotationSlider.value) // Also store slider for easier restoration
                };
                
                const presets = loadPresets();
                presets[name] = preset;
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetNameInput.value = '';
                alert(`Preset "${name}" saved!`);
            }
            
            // Delete preset
            function deletePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please select a preset to delete');
                    return;
                }
                
                if (!confirm(`Delete preset "${name}"?`)) {
                    return;
                }
                
                const presets = loadPresets();
                delete presets[name];
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetSelect.value = '';
            }
            
            // Event listeners
            presetSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadPreset(e.target.value);
                    localStorage.setItem('sandboxLastActivePreset', e.target.value);
                }
            });
            
            savePresetBtn.addEventListener('click', () => {
                const presetName = presetNameInput.value.trim();
                savePreset(presetName);
                if (presetName) {
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                    presetSelect.value = presetName;
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            deletePresetBtn.addEventListener('click', () => {
                const presetToDelete = presetSelect.value;
                deletePreset(presetToDelete);
                if (localStorage.getItem('sandboxLastActivePreset') === presetToDelete) {
                    localStorage.removeItem('sandboxLastActivePreset');
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            // Export presets to JSON file
            exportPresetsBtn.addEventListener('click', () => {
                const presets = loadPresets();
                const jsonString = JSON.stringify(presets, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sandbox-presets.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(`Exported ${Object.keys(presets).length} preset(s) to sandbox-presets.json`);
            });
            
            // Import presets from JSON file
            importPresetsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        
                        if (typeof importedPresets !== 'object' || Array.isArray(importedPresets)) {
                            alert('Invalid preset file format. Expected an object with preset names as keys.');
                            return;
                        }
                        
                        // Load current presets
                        const currentPresets = loadPresets();
                        
                        // Merge imported presets with current presets (imported presets take precedence for conflicts)
                        let importedCount = 0;
                        let overwrittenCount = 0;
                        for (const [name, preset] of Object.entries(importedPresets)) {
                            if (currentPresets[name]) {
                                overwrittenCount++;
                            } else {
                                importedCount++;
                            }
                            currentPresets[name] = preset;
                        }
                        
                        // Save merged presets
                        localStorage.setItem('sandboxPresets', JSON.stringify(currentPresets));
                        loadPresets();
                        
                        // Update preset names list for hotkeys (if updatePresetNames is defined)
                        if (typeof updatePresetNames === 'function') {
                            updatePresetNames();
                        }
                        
                        // Reset file input
                        e.target.value = '';
                        
                        const message = `Imported ${importedCount} new preset(s)${overwrittenCount > 0 ? ` and overwrote ${overwrittenCount} existing preset(s)` : ''}.`;
                        alert(message);
                    } catch (error) {
                        alert(`Error importing presets: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            });
            
            // Randomize function
            function randomizeAll() {
                // Randomize all parameters within their valid ranges
                
                // Shape parameters
                spikiness = Math.random();
                spikeFrequency = 2 + Math.random() * 18; // 2-20
                spikeSharpness = Math.random();
                hue = Math.random() * 360;
                scale = 0.05 + Math.random() * 0.95; // 0.05-1.0
                fillSize = Math.random();
                fillOpacity = Math.random();
                rotation = Math.random() * 360;
                hueShiftAmount = Math.random() * 0.2; // 0-0.2
                
                // Blend parameters
                const blendModes = ['additive', 'alpha', 'multiply', 'screen', 'overlay'];
                blendMode = blendModes[Math.floor(Math.random() * blendModes.length)];
                blendOpacity = Math.random();
                
                // Emanation parameters
                // Dilation speed: 0.88-1.22 (use slider range 0-200, map to actual value)
                const randomDilationSlider = Math.random() * 200;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(randomDilationSlider / 200.0, 1.0 / 8.0) * range;
                
                // Fade amount: 0-5.0 (use slider range 0-100, map to actual value)
                const randomFadeSlider = Math.random() * 100;
                fadeAmount = Math.pow(randomFadeSlider / 100.0, 1.0 / 3.0) * 5.0;
                
                // Emanation rate: 2-200
                emanationRate = 2 + Math.random() * 198;
                
                // Filter parameters
                noiseAmount = Math.random(); // 0-1
                noiseRate = Math.random() * 10.0; // 0-10 (time-based: interval = 2.0 / rate)
                blurAmount = Math.random(); // 0-1
                blurRate = Math.random() * 10.0; // 0-10 (time-based: interval = 2.0 / rate)
                
                // Auto rotation speed: -1 to 360 (use slider range 0-200, map to actual value)
                const randomAutoRotationSlider = Math.random() * 200;
                autoRotationSpeed = -1.0 + Math.pow(randomAutoRotationSlider / 200.0, 0.5) * 361.0;
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = Math.round(hue);
                hueValue.textContent = Math.round(hue) + '°';
                scaleSlider.value = scale.toFixed(2);
                scaleValue.textContent = scale.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                rotationSlider.value = Math.round(rotation);
                rotationValue.textContent = Math.round(rotation) + '°';
                hueShiftSlider.value = hueShiftAmount.toFixed(3);
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                
                // Update blend controls
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity.toFixed(2);
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                
                // Update emanation controls
                dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = fadeAmountToSlider(fadeAmount);
                fadeValue.textContent = fadeAmount.toFixed(3);
                emanationRateSlider.value = emanationRate.toFixed(1);
                emanationRateValue.textContent = emanationRate.toFixed(1);
                
                // Update filter controls
                noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                noiseAmountValue.textContent = noiseAmount.toFixed(2);
                noiseRateSlider.value = noiseRateToSlider(noiseRate);
                noiseRateValue.textContent = noiseRate.toFixed(2);
                blurAmountSlider.value = blurAmountToSlider(blurAmount);
                blurAmountValue.textContent = blurAmount.toFixed(2);
                blurRateSlider.value = blurRateToSlider(blurRate);
                blurRateValue.textContent = blurRate.toFixed(2);
                
                // Update auto rotation
                autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Update base values
                baseSpikiness = spikiness;
                baseSpikeFrequency = spikeFrequency;
                baseSpikeSharpness = spikeSharpness;
                baseHue = hue;
                baseScale = scale;
                baseFillSize = fillSize;
                baseFillOpacity = fillOpacity;
                baseRotation = rotation;
                baseHueShiftAmount = hueShiftAmount;
                baseDilationSpeed = dilationSpeed;
                baseFadeAmount = fadeAmount;
                baseEmanationRate = emanationRate;
                baseAutoRotationSpeed = autoRotationSpeed;
                baseNoiseAmount = noiseAmount;
                baseNoiseRate = noiseRate;
                baseBlurAmount = blurAmount;
                baseBlurRate = blurRate;
                baseBlendOpacity = blendOpacity;
                
                // Update target bases to match
                targetBaseSpikiness = baseSpikiness;
                targetBaseSpikeFrequency = baseSpikeFrequency;
                targetBaseSpikeSharpness = baseSpikeSharpness;
                targetBaseHue = baseHue;
                targetBaseScale = baseScale;
                targetBaseFillSize = baseFillSize;
                targetBaseFillOpacity = baseFillOpacity;
                targetBaseRotation = baseRotation;
                targetBaseHueShiftAmount = baseHueShiftAmount;
                targetBaseDilationSpeed = baseDilationSpeed;
                targetBaseFadeAmount = baseFadeAmount;
                targetBaseEmanationRate = baseEmanationRate;
                targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                targetBaseNoiseAmount = baseNoiseAmount;
                targetBaseNoiseRate = baseNoiseRate;
                targetBaseBlurAmount = baseBlurAmount;
                targetBaseBlurRate = baseBlurRate;
                targetBaseBlendOpacity = baseBlendOpacity;
            }
            
            // Resolution controls
            function updateResolution(resolutionKey) {
                currentResolution = resolutionKey;
                const res = RESOLUTIONS[resolutionKey];
                
                // Update URL without page reload
                const url = new URL(window.location);
                if (resolutionKey === 'window') {
                    url.searchParams.delete('resolution');
                } else {
                    url.searchParams.set('resolution', resolutionKey);
                }
                window.history.replaceState({}, '', url);
                
                // Update UI
                document.querySelectorAll('.resolution-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector(`[data-resolution="${resolutionKey}"]`).classList.add('active');
                
                // Update display
                const display = document.getElementById('current-resolution-display');
                if (res.width && res.height) {
                    display.textContent = `Current: ${res.name} (${res.width}×${res.height})`;
                } else {
                    display.textContent = `Current: ${res.name}`;
                }
                
                // Resize canvas
                renderer.resize();
            }
            
            // Set initial active button
            document.querySelector(`[data-resolution="${currentResolution}"]`).classList.add('active');
            updateResolution(currentResolution); // Update display
            
            // Resolution button event listeners
            document.querySelectorAll('.resolution-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const resolution = e.target.dataset.resolution;
                    updateResolution(resolution);
                });
            });
            
            randomizeBtn.addEventListener('click', randomizeAll);
            
            // Jiggle functionality
            jiggleAmountSlider.addEventListener('input', (e) => {
                const sliderValue = parseFloat(e.target.value);
                jiggleAmount = mapParamValue('jiggleAmount', sliderValue) ?? (sliderValue / 100.0);
                jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            });
            
            handleValueEdit(jiggleAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')) / 100.0, // Convert percentage to 0-1
                (val) => Math.round(val * 100) + '%',
                (val) => {
                    jiggleAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    jiggleAmountSlider.value = Math.round(clampedForSlider * 100);
                }
            );
            
            jiggleBtn.addEventListener('click', () => {
                jiggleEnabled = !jiggleEnabled;
                jiggleBtn.textContent = jiggleEnabled ? 'Stop Jiggle' : 'Jiggle';
                jiggleBtn.style.background = jiggleEnabled ? '#a00' : '#a0a';
                
                if (!jiggleEnabled) {
                    // Keep current jiggled values and update base values to match
                    // This way the values persist when jiggle is turned off
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    // Targets match new bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                    
                    // Update sliders to reflect current values (they should already match, but ensure sync)
                    spikinessSlider.value = Math.round(spikiness * 100);
                    spikeFrequencySlider.value = spikeFrequency;
                    spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                    hueSlider.value = Math.round(hue);
                    scaleSlider.value = scale.toFixed(2);
                    fillSizeSlider.value = Math.round(fillSize * 100);
                    fillOpacitySlider.value = Math.round(fillOpacity * 100);
                    rotationSlider.value = Math.round(rotation);
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                    fadeSlider.value = fadeAmountToSlider(fadeAmount);
                    emanationRateSlider.value = emanationRate.toFixed(1);
                    autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                    noiseAmountSlider.value = noiseAmountToSlider(noiseAmount);
                    noiseRateSlider.value = noiseRateToSlider(noiseRate);
                    blurAmountSlider.value = blurAmountToSlider(blurAmount);
                    blurRateSlider.value = blurRateToSlider(blurRate);
                    blendOpacitySlider.value = blendOpacity.toFixed(2);
                    
                    // Update status indicators (unsaved state may have changed)
                    updateStatusIndicators();
                } else {
                    // Store current values as base when starting jiggle
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    // Targets start at current bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                }
                
                // Update jiggle indicator
                updateStatusIndicators();
            });
            
            // Update base values when sliders change
            function updateBaseValues() {
                if (!jiggleEnabled) {
                    // When jiggle is off, bases track current values directly
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    baseDilationSpeed = dilationSpeed;
                    baseFadeAmount = fadeAmount;
                    baseEmanationRate = emanationRate;
                    baseAutoRotationSpeed = autoRotationSpeed;
                    baseNoiseAmount = noiseAmount;
                    baseNoiseRate = noiseRate;
                    baseBlurAmount = blurAmount;
                    baseBlurRate = blurRate;
                    baseBlendOpacity = blendOpacity;
                    
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    targetBaseDilationSpeed = baseDilationSpeed;
                    targetBaseFadeAmount = baseFadeAmount;
                    targetBaseEmanationRate = baseEmanationRate;
                    targetBaseAutoRotationSpeed = baseAutoRotationSpeed;
                    targetBaseNoiseAmount = baseNoiseAmount;
                    targetBaseNoiseRate = baseNoiseRate;
                    targetBaseBlurAmount = baseBlurAmount;
                    targetBaseBlurRate = baseBlurRate;
                    targetBaseBlendOpacity = baseBlendOpacity;
                } else {
                    // When jiggle is on, treat current values as new desired origins
                    // Jiggle will smoothly ease its orbit center toward these targets
                    targetBaseSpikiness = spikiness;
                    targetBaseSpikeFrequency = spikeFrequency;
                    targetBaseSpikeSharpness = spikeSharpness;
                    targetBaseHue = hue;
                    targetBaseScale = scale;
                    targetBaseFillSize = fillSize;
                    targetBaseFillOpacity = fillOpacity;
                    targetBaseRotation = rotation;
                    targetBaseHueShiftAmount = hueShiftAmount;
                    targetBaseDilationSpeed = dilationSpeed;
                    targetBaseFadeAmount = fadeAmount;
                    targetBaseEmanationRate = emanationRate;
                    targetBaseAutoRotationSpeed = autoRotationSpeed;
                    targetBaseNoiseAmount = noiseAmount;
                    targetBaseNoiseRate = noiseRate;
                    targetBaseBlurAmount = blurAmount;
                    targetBaseBlurRate = blurRate;
                    targetBaseBlendOpacity = blendOpacity;
                }
                // Update status indicators to check for unsaved changes
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
            
            let startTime = Date.now();
            let lastCaptureTime = 0;
            const TARGET_FPS = 60;
            const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
            
            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;
                
                // Apply jiggle if enabled
                if (jiggleEnabled && jiggleAmount > 0) {
                    // Ease bases toward targets so jiggle orbits move smoothly when user edits params
                    const originLerp = 0.1;
                    baseSpikiness += (targetBaseSpikiness - baseSpikiness) * originLerp;
                    baseSpikeFrequency += (targetBaseSpikeFrequency - baseSpikeFrequency) * originLerp;
                    baseSpikeSharpness += (targetBaseSpikeSharpness - baseSpikeSharpness) * originLerp;
                    baseHue += (targetBaseHue - baseHue) * originLerp;
                    baseScale += (targetBaseScale - baseScale) * originLerp;
                    baseFillSize += (targetBaseFillSize - baseFillSize) * originLerp;
                    baseFillOpacity += (targetBaseFillOpacity - baseFillOpacity) * originLerp;
                    baseRotation += (targetBaseRotation - baseRotation) * originLerp;
                    baseHueShiftAmount += (targetBaseHueShiftAmount - baseHueShiftAmount) * originLerp;
                    baseDilationSpeed += (targetBaseDilationSpeed - baseDilationSpeed) * originLerp;
                    baseFadeAmount += (targetBaseFadeAmount - baseFadeAmount) * originLerp;
                    baseEmanationRate += (targetBaseEmanationRate - baseEmanationRate) * originLerp;
                    baseAutoRotationSpeed += (targetBaseAutoRotationSpeed - baseAutoRotationSpeed) * originLerp;
                    baseNoiseAmount += (targetBaseNoiseAmount - baseNoiseAmount) * originLerp;
                    baseNoiseRate += (targetBaseNoiseRate - baseNoiseRate) * originLerp;
                    baseBlurAmount += (targetBaseBlurAmount - baseBlurAmount) * originLerp;
                    baseBlurRate += (targetBaseBlurRate - baseBlurRate) * originLerp;
                    baseBlendOpacity += (targetBaseBlendOpacity - baseBlendOpacity) * originLerp;
                    
                    // Use time-based seed for smooth jiggle
                    const seed = currentTime * 2.0; // Speed of jiggle
                    
                    // Apply random offsets to each parameter based on jiggle amount
                    // Using sin/cos with different frequencies for each parameter for smooth variation
                    spikiness = baseSpikiness + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    spikiness = Math.max(0, Math.min(1, spikiness));
                    
                    spikeFrequency = baseSpikeFrequency + (Math.sin(seed * 1.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 9.0; // ±9 range
                    spikeFrequency = Math.max(2, Math.min(20, spikeFrequency));
                    
                    spikeSharpness = baseSpikeSharpness + (Math.sin(seed * 1.1) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    spikeSharpness = Math.max(0, Math.min(1, spikeSharpness));
                    
                    hue = baseHue + (Math.sin(seed * 0.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 180.0; // ±180 range
                    hue = ((hue % 360) + 360) % 360; // Wrap around
                    
                    scale = baseScale + (Math.sin(seed * 1.5) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.3; // ±0.3 range
                    scale = Math.max(0.05, Math.min(1.0, scale));
                    
                    fillSize = baseFillSize + (Math.sin(seed * 1.2) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    fillSize = Math.max(0, Math.min(1, fillSize));
                    
                    fillOpacity = baseFillOpacity + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                    
                    // Manual rotation does not jiggle; keep rotation from user / auto-rotation
                    
                    hueShiftAmount = baseHueShiftAmount + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1; // ±0.1 range
                    hueShiftAmount = Math.max(0, Math.min(0.2, hueShiftAmount));
                    
                    // Dilation speed: jiggle around base, range ~0.88-1.22, so use ±0.1 range
                    dilationSpeed = baseDilationSpeed + (Math.sin(seed * 0.9) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1;
                    dilationSpeed = Math.max(0.88, Math.min(1.22, dilationSpeed));
                    
                    // Fade amount: jiggle around base, range 0-5, so use ±1.0 range
                    fadeAmount = baseFadeAmount + (Math.sin(seed * 1.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 1.0;
                    fadeAmount = Math.max(0, Math.min(5.0, fadeAmount));
                    
                    // Emanation rate: jiggle around base, range 2-200, so use ±20 range
                    emanationRate = baseEmanationRate + (Math.sin(seed * 1.0) * 0.5 + 0.5 - 0.5) * jiggleAmount * 20.0;
                    emanationRate = Math.max(2, Math.min(200, emanationRate));
                    
                    // Auto rotation speed: jiggle around base, range -1 to 360, so use ±30 range
                    autoRotationSpeed = baseAutoRotationSpeed + (Math.sin(seed * 0.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 30.0;
                    autoRotationSpeed = Math.max(-1, Math.min(360, autoRotationSpeed));
                    
                    // Noise amount: jiggle around base, range 0-1, so use ±0.2 range
                    noiseAmount = baseNoiseAmount + (Math.sin(seed * 1.9) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.2;
                    noiseAmount = Math.max(0, Math.min(1, noiseAmount));
                    
                    // Noise rate: jiggle around base, range 0-10, so use ±2.0 range
                    noiseRate = baseNoiseRate + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount * 2.0;
                    noiseRate = Math.max(0, Math.min(10, noiseRate));
                    
                    // Blur amount: jiggle around base, range 0-1, so use ±0.2 range
                    blurAmount = baseBlurAmount + (Math.sin(seed * 2.0) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.2;
                    blurAmount = Math.max(0, Math.min(1, blurAmount));
                    
                    // Blur rate: jiggle around base, range 0-10, so use ±2.0 range
                    blurRate = baseBlurRate + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount * 2.0;
                    blurRate = Math.max(0, Math.min(10, blurRate));
                    
                    // Blend opacity: jiggle around base, range 0-1, so use ±0.1 range
                    blendOpacity = baseBlendOpacity + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1;
                    blendOpacity = Math.max(0, Math.min(1, blendOpacity));
                }
                
                // Calculate capture interval from emanation rate (emanations per second)
                const captureInterval = 1.0 / emanationRate;
                
                // Check if it's time to capture a new shape
                const shouldCaptureShape = (currentTime - lastCaptureTime) >= captureInterval;
                if (shouldCaptureShape) {
                    lastCaptureTime = currentTime;
                }
                
                // Calculate total rotation (manual + auto) for capturing
                // This ensures captured shapes preserve their rotation at capture time
                const totalRotation = rotation + (currentTime * autoRotationSpeed);
                
                // Apply freeze: if frozen, set dilation to 1.0 (no expansion)
                const effectiveDilationSpeed = freezeEnabled ? 1.0 : dilationSpeed;
                
                renderer.render({
                    u_time: currentTime,
                    u_spikiness: spikiness,
                    u_spikeFrequency: spikeFrequency,
                    u_spikeSharpness: spikeSharpness,
                    u_hue: hue,
                    u_scale: scale,
                    u_fillSize: fillSize,
                    u_fillOpacity: fillOpacity
                }, effectiveDilationSpeed, shouldCaptureShape, fadeAmount, hueShiftAmount, emanationRate, noiseAmount, noiseRate, blurAmount, blurRate, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation);
            }
            
            // Use setInterval for fixed 60fps instead of requestAnimationFrame
            setInterval(render, FRAME_TIME);
            render(); // Initial render
            
            // Hotkey handlers
            let presetNames = [];
            
            // Store reference to original loadPresets before it gets wrapped
            const originalLoadPresetsForHotkeys = loadPresets;
            
            // Update preset names list (use original function to avoid circular reference)
            function updatePresetNames() {
                const presets = originalLoadPresetsForHotkeys();
                presetNames = Object.keys(presets);
            }
            updatePresetNames();
            
            // Track current preset index
            let currentPresetIndex = -1;
            
            // Find current preset index
            function findCurrentPresetIndex() {
                const currentPreset = presetSelect.value;
                currentPresetIndex = presetNames.indexOf(currentPreset);
                if (currentPresetIndex === -1 && presetNames.length > 0) {
                    currentPresetIndex = 0;
                }
            }
            
            function downloadSnapshot() {
                try {
                    if (!canvas) return;
                    const dataUrl = canvas.toDataURL('image/png');
                    const a = document.createElement('a');
                    const ts = new Date();
                    const pad = (n) => String(n).padStart(2, '0');
                    const timestamp = `${ts.getFullYear()}-${pad(ts.getMonth() + 1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}`;
                    a.href = dataUrl;
                    a.download = `coherence-sandbox-${timestamp}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } catch (err) {
                    console.error('Snapshot failed', err);
                }
            }

	    function toggleFullScreen() {
		let devtool = document.querySelector('#dev-toolbox');
		let hotleg = document.querySelector('#hotkey-legend');

		devtool.hidden = !devtool.hidden;
		hotleg.hidden = !hotleg.hidden;
	    }
            
            // GIF capture helpers
            function startGifCapture() {
                if (gifRecording) return;
                gifRecording = true;
                gifCaptureFrames = [];
                gifCaptureStart = Date.now();
                
                const maxWidth = 720;
                gifCaptureWidth = Math.min(maxWidth, canvas.width);
                gifCaptureHeight = Math.round(gifCaptureWidth * (canvas.height / canvas.width));
                captureCanvas.width = gifCaptureWidth;
                captureCanvas.height = gifCaptureHeight;
                
                if (recordIndicator) {
                    recordIndicator.style.display = 'inline-block';
                    recordIndicator.textContent = 'RECORD 10.0s';
                    positionStatusIndicators();
                }
                
                const captureFrame = () => {
                    try {
                        captureCtx.clearRect(0, 0, gifCaptureWidth, gifCaptureHeight);
                        captureCtx.drawImage(canvas, 0, 0, gifCaptureWidth, gifCaptureHeight);
                        const frame = captureCtx.getImageData(0, 0, gifCaptureWidth, gifCaptureHeight);
                        gifCaptureFrames.push(frame);
                    } catch (err) {
                        console.error('GIF capture frame failed', err);
                    }
                };
                
                captureFrame();
                
                gifCaptureTimer = setInterval(() => {
                    captureFrame();
                    if (Date.now() - gifCaptureStart >= GIF_MAX_MS) {
                        stopGifCapture(true);
                    }
                }, 1000 / GIF_FPS);
                
                gifCountdownTimer = setInterval(() => {
                    if (!gifRecording) return;
                    const elapsed = Date.now() - gifCaptureStart;
                    const remaining = Math.max(0, GIF_MAX_MS - elapsed);
                    const seconds = (remaining / 1000).toFixed(1);
                    if (recordIndicator) {
                        recordIndicator.textContent = `RECORD ${seconds}s`;
                    }
                }, 100);
            }
            
            function stopGifCapture(autoStop = false) {
                if (!gifRecording) return;
                gifRecording = false;
                if (gifCaptureTimer) {
                    clearInterval(gifCaptureTimer);
                    gifCaptureTimer = null;
                }
                if (gifCountdownTimer) {
                    clearInterval(gifCountdownTimer);
                    gifCountdownTimer = null;
                }
                if (recordIndicator) {
                    recordIndicator.style.display = 'none';
                    recordIndicator.textContent = 'RECORD';
                }
                
                if (gifCaptureFrames.length < 2) {
                    gifCaptureFrames = [];
                    return;
                }
                
                let gif;
                try {
                    gif = new GIF({
                        workers: 2,
                        quality: 10,
                        workerScript: 'vendor/gif.worker.js',
                        width: gifCaptureWidth,
                        height: gifCaptureHeight
                    });
                } catch (err) {
                    console.warn('GIF capture is not supported in this environment.', err);
                    gifCaptureFrames = [];
                    return;
                }
                
                const combinedFrames = gifCaptureFrames.concat(
                    gifCaptureFrames.length > 2 ? gifCaptureFrames.slice(1, -1).reverse() : []
                );
                
                combinedFrames.forEach((frame) => {
                    gif.addFrame(frame, { delay: 1000 / GIF_FPS });
                });
                
                gif.on('finished', (blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    const ts = new Date();
                    const pad = (n) => String(n).padStart(2, '0');
                    const timestamp = `${ts.getFullYear()}-${pad(ts.getMonth() + 1)}-${pad(ts.getDate())}_${pad(ts.getHours())}-${pad(ts.getMinutes())}-${pad(ts.getSeconds())}`;
                    a.href = url;
                    a.download = `coherence-loop-${timestamp}.gif`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
                
                gif.render();
                gifCaptureFrames = [];
            }
            
            // Keyboard event listeners
            document.addEventListener('keydown', (e) => {
                // Ignore hotkeys while typing in text inputs or editable fields
                const active = document.activeElement;
                if (active) {
                    const tag = active.tagName;
                    const type = active.type;
                    const isTextInput = tag === 'INPUT' && type !== 'range' && type !== 'checkbox' && type !== 'radio';
                    const isTextArea = tag === 'TEXTAREA';
                    const isEditable = active.isContentEditable;
                    if (isTextInput || isTextArea || isEditable) {
                        return;
                    }
                }
                
                // Prevent default for our hotkeys (but allow shift for future use)
                if (e.key === ' ' || e.key === 'r' || e.key === 'R' || 
                    e.key === 'j' || e.key === 'J' || e.key === 'Escape' ||
                    e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                    e.key === 'ArrowUp' || e.key === 'ArrowDown' ||
                    e.key === 's' || e.key === 'S' ||
                    e.key === 'g' || e.key === 'G') {
                    e.preventDefault();
                }
                
                // Space: Toggle freeze (set dilation to 1.0 = no expansion)
                if (e.key === ' ') {
                    freezeEnabled = !freezeEnabled;
                    if (freezeEnabled) {
                        // Store original dilation speed
                        originalDilationSpeed = dilationSpeed;
                        dilationSpeed = 1.0; // No dilation when frozen (1.0 = no expansion)
                    } else {
                        // Restore original dilation speed
                        dilationSpeed = originalDilationSpeed;
                    }
                    updateStatusIndicators();
                }
                
                // R: Randomize
                if (e.key === 'r' || e.key === 'R') {
                    randomizeAll();
                }
                
                // S: Snapshot PNG
                if (e.key === 's' || e.key === 'S') {
                    downloadSnapshot();
                }

                if (e.key === 'h' || e.key === 'H') {
		    toggleFullScreen();
                }
                
                // G: Toggle GIF recording (max 10s, forward + reverse loop)
                if (e.key === 'g' || e.key === 'G') {
                    if (gifRecording) {
                        stopGifCapture(false);
                    } else {
                        startGifCapture();
                    }
                }

                
                // Left/Right arrows: Cycle presets (stub)
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    console.log('Preset cycling via arrow keys: TODO refine behavior');
                }
                
                // Up arrow: accelerate auto params (rotation, hue shift, dilation)
                if (e.key === 'ArrowUp') {
                    // Increase auto rotation speed (up to a max) - slower step
                    autoRotationSpeed = Math.min(360.0, autoRotationSpeed + 0.5);
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (autoRotationSpeed + 1) / 361.0)), 2));
                    autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                    
                    // Increase hue shift amount (up to max 0.2) - slower step
                    hueShiftAmount = Math.min(0.2, hueShiftAmount + 0.0002);
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                    
                    // Push dilation further away from 1.0 - slower step
                    const delta = dilationSpeed >= 1.0 ? 0.001 : -0.001;
                    dilationSpeed = Math.max(0.88, Math.min(1.22, dilationSpeed + delta));
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(dilationSpeed);
                    dilationValue.textContent = dilationSpeed.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // Down arrow: decelerate auto params towards neutral
                if (e.key === 'ArrowDown') {
                    // Gently damp auto rotation towards 0 - slower step
                    autoRotationSpeed *= 0.98;
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (autoRotationSpeed + 1) / 361.0)), 2));
                    autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                    
                    // Gently damp hue shift towards 0 - slower step
                    hueShiftAmount *= 0.98;
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                    
                    // Bring dilation towards 1.0 (never snapping) - slower easing
                    dilationSpeed = dilationSpeed + (1.0 - dilationSpeed) * 0.02;
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(dilationSpeed);
                    dilationValue.textContent = dilationSpeed.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // J: Toggle jiggle
                if (e.key === 'j' || e.key === 'J') {
                    jiggleBtn.click();
                }
                
                // Esc: Clear screen
                if (e.key === 'Escape') {
                    // Clear both framebuffers
                    const gl = renderer.gl;
                    
                    // Clear history framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.historyFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Clear current framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.currentFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
            });
            
            // Note: We don't wrap loadPresets here because updatePresetNames
            // already calls the original function directly to avoid circular references.
            // If you need to update preset names after loading, call updatePresetNames() explicitly.
        })();
    </script>
</body>
</html>

