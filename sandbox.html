<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Droplet Visual Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #hotkey-legend {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 10px;
            color: #fff;
            font-size: 10px;
            z-index: 1001;
            font-family: monospace;
            min-width: 220px;
        }
        
        #hotkey-legend h4 {
            margin: 0 0 8px 0;
            font-size: 10px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            border-bottom: 1px solid #333;
            padding-bottom: 6px;
        }
        
        #hotkey-legend .hotkey-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            padding: 2px 0;
        }
        
        #hotkey-legend .hotkey-item:last-child {
            margin-bottom: 0;
        }
        
        #hotkey-legend .hotkey-key {
            color: #0af;
            font-weight: 600;
            min-width: 60px;
        }
        
        #hotkey-legend .hotkey-desc {
            color: #bbb;
            text-align: right;
            flex: 1;
        }
        
        #status-indicators {
            position: fixed;
            top: 10px;
            left: 10px;
            margin-top: 0;
            display: flex;
            gap: 4px;
            font-size: 9px;
            z-index: 1002;
            pointer-events: none;
        }
        
        #status-indicators span {
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        #dev-toolbox {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid #444;
            border-radius: 6px;
            padding: 12px;
            color: #fff;
            min-width: 280px;
            max-width: 320px;
            max-height: calc(100vh - 20px);
            overflow-y: auto;
            z-index: 1000;
            font-size: 11px;
        }
        
        #dev-toolbox h3 {
            margin: 0 0 10px 0;
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 4px;
            font-size: 10px;
            color: #bbb;
            font-weight: 500;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-row input[type="range"] {
            flex: 1;
            margin: 0;
        }
        
        .control-row .value {
            font-size: 10px;
            color: #888;
            font-family: monospace;
            min-width: 45px;
            text-align: right;
            padding: 2px 4px;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: text;
            user-select: text;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .control-row .value:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #555;
        }
        
        .control-row .value:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #0af;
            color: #fff;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 2px;
        }
        
        .control-group .value {
            font-size: 10px;
            color: #888;
            font-family: monospace;
            padding: 2px 4px;
            border: 1px solid transparent;
            border-radius: 2px;
            cursor: text;
            user-select: text;
            background: rgba(255, 255, 255, 0.05);
        }
        
        .control-group .value:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #555;
        }
        
        .control-group .value:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
            border-color: #0af;
            color: #fff;
        }
        
        .control-group select,
        .control-group input[type="text"],
        .control-group button {
            font-size: 10px;
            padding: 3px 6px;
        }
        
        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .section-header {
            margin-top: 12px;
            margin-bottom: 6px;
            font-size: 9px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            border-top: 1px solid #333;
            padding-top: 8px;
        }
        
        .section-header:first-child {
            border-top: none;
            padding-top: 0;
            margin-top: 0;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Shader scripts (embedded to avoid CORS issues) -->
    <script id="star-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>
    
    <script id="star-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_spikiness;      // 0.0 = circle, 1.0 = maximum spikes
        uniform float u_spikeFrequency; // Continuous number of spikes (2-20)
        uniform float u_spikeSharpness; // 0.0 = rounded, 1.0 = sharp spikes
        uniform float u_hue;
        uniform float u_scale;
        uniform float u_rotation;
        uniform float u_autoRotationSpeed;
        uniform float u_blendOpacity;
        uniform float u_fillSize;       // 0.0 = no fill, 1.0 = fill to edge
        uniform float u_fillOpacity;   // 0.0 = transparent, 1.0 = opaque

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            // Normalize coordinates
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec2 center = vec2(0.5);
            
            // Convert to centered coordinates
            vec2 p = (uv - center) * vec2(u_resolution.x / u_resolution.y, 1.0);
            
            // Rotate coordinates (manual rotation + auto rotation)
            float autoRotation = -u_time * u_autoRotationSpeed; // Auto rotation in degrees (reversed direction)
            float totalRotation = u_rotation + autoRotation;
            float rotationRad = totalRotation * 3.14159 / 180.0;
            float cosRot = cos(rotationRad);
            float sinRot = sin(rotationRad);
            vec2 rotatedP = vec2(
                p.x * cosRot - p.y * sinRot,
                p.x * sinRot + p.y * cosRot
            );
            
            // Draw a morphing shape (circle to spikes)
            float angle = atan(rotatedP.y, rotatedP.x);
            float dist = length(rotatedP);
            
            // Base radius scales with u_scale
            float baseRadius = u_scale * 0.4;
            
            // Calculate shape modulation
            // Use continuous spike frequency (not discrete)
            float modulation = cos(angle * u_spikeFrequency);
            
            // Apply sharpness: sharper spikes use power function
            // When sharpness = 0: smooth cosine wave
            // When sharpness = 1: sharp peaks (using power function)
            float sharpModulation;
            if (u_spikeSharpness < 0.01) {
                // No sharpness: use smooth cosine
                sharpModulation = modulation;
            } else {
                // Apply power function to sharpen peaks
                // Higher sharpness = steeper peaks
                float power = 1.0 / (1.0 + u_spikeSharpness * 3.0); // Range: 1.0 to ~0.25
                sharpModulation = pow(abs(modulation), power) * sign(modulation);
            }
            
            // Apply spikiness: interpolate between circle (0) and spiked shape (1)
            float spikeAmount = u_scale * 0.25 * u_spikiness;
            float r = baseRadius + spikeAmount * sharpModulation;
            
            // Draw the outline - this is the primary shape definition
            float lineWidth = 0.012;
            float outline = smoothstep(lineWidth, 0.0, abs(dist - r));
            
            // Draw the fill separately - parameterized by size and opacity
            float fillRadius = r * u_fillSize; // Fill size: 0.0 = no fill, 1.0 = fill to edge
            float fill = 0.0;
            if (u_fillSize > 0.0 && dist < fillRadius) {
                // Smooth falloff for fill interior
                float fillFalloff = smoothstep(fillRadius, fillRadius * 0.8, dist);
                fill = fillFalloff * u_fillOpacity; // Apply fill opacity
            }
            
            // Combine outline and fill
            // Outline is always full brightness, fill adds to it with its opacity
            float shape = max(outline, fill);
            
            // Convert hue to RGB (hue in degrees, saturation=1.0, value=1.0)
            // Add slow automatic hue shift over time (full cycle every 30 seconds)
            float autoHueShift = u_time * 12.0; // 360 degrees / 30 seconds = 12 deg/sec
            float finalHue = mod(u_hue + autoHueShift, 360.0);
            vec3 hsv = vec3(finalHue / 360.0, 1.0, 1.0);
            vec3 color = hsv2rgb(hsv) * shape;
            
            // Apply opacity for blend control
            gl_FragColor = vec4(color, u_blendOpacity);
        }
    </script>
    
    <script id="dilation-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_uv = a_position * 0.5 + 0.5;
            v_uv.y = 1.0 - v_uv.y; // Flip Y
        }
    </script>
    
    <script id="dilation-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform sampler2D u_history;
        uniform vec2 u_resolution;
        uniform float u_expansionFactor;
        uniform float u_fadeAmount;
        uniform float u_hueShiftAmount;
        varying vec2 v_uv;

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        // Convert RGB to HSV
        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        void main() {
            vec2 uv = v_uv;
            vec2 center = vec2(0.5);
            vec2 dir = uv - center;
            vec2 scaledDir = dir / u_expansionFactor; // Scale inward to sample outward
            vec2 sampleUV = scaledDir + center;
            
            // Check if current pixel is at the center (within small radius)
            float distFromCenter = length(dir);
            float centerRadius = 0.002; // Very small radius around center (about 2 pixels at 1000px resolution)
            
            vec4 history;
            if (distFromCenter < centerRadius) {
                // At center: sample neighboring pixels and average them
                // Sample 8 neighboring pixels in a ring around center
                float sampleRadius = 0.003; // Slightly larger radius for neighbors
                vec4 neighborSum = vec4(0.0);
                float neighborCount = 0.0;
                
                // Sample neighbors in 8 directions
                for (float angle = 0.0; angle < 6.28318; angle += 0.785398) { // 8 directions (2*PI/8)
                    vec2 neighborDir = vec2(cos(angle), sin(angle)) * sampleRadius;
                    vec2 neighborUV = sampleUV + neighborDir;
                    vec4 neighbor = texture2D(u_history, neighborUV);
                    neighborSum += neighbor;
                    neighborCount += 1.0;
                }
                
                // Use average of neighbors, or black if no valid neighbors
                history = neighborCount > 0.0 ? neighborSum / neighborCount : vec4(0.0, 0.0, 0.0, 0.0);
            } else {
                // Check if we're sampling from the center region (prevent center pixels from propagating outward)
                vec2 sampleDir = sampleUV - center;
                float sampleDistFromCenter = length(sampleDir);
                
                if (sampleDistFromCenter < centerRadius) {
                    // If sampling from center, use black/transparent to prevent propagation
                    history = vec4(0.0, 0.0, 0.0, 0.0);
                } else {
                    // Normal sampling
                    history = texture2D(u_history, sampleUV);
                }
            }
            
            // Fade based on expansion (further from center = more faded)
            // distFromCenter already calculated above
            // Use logarithmic fade curve for smoother transitions
            // Map distance to fade using a power curve for more gradual fade
            float fadeAmount = smoothstep(0.0, 0.8, distFromCenter); // Fade as it expands
            // Apply logarithmic fade: fade = 1 - fadeAmount^fadePower
            // u_fadeAmount range: 0 to 5.0
            // Higher values create more gradual fades
            float fadePower = 1.0 + u_fadeAmount * 2.0; // Range: 1.0 to 11.0 when u_fadeAmount is 0 to 5
            float fade = 1.0 - pow(fadeAmount, fadePower);
            
            // Decay factor: reduce brightness over time to prevent accumulation
            // Estimate age based on distance (further = older = more decay)
            float ageEstimate = distFromCenter * 2.0; // Rough estimate of "age"
            float decayRate = 0.98; // Decay 2% per frame (adjustable)
            float decay = pow(decayRate, ageEstimate); // Exponential decay
            
            // Hue shift based on expansion
            float hueShift = distFromCenter * u_hueShiftAmount; // Use parameterized hue shift
            
            // Convert RGB to HSV, shift hue, convert back
            vec3 hsv = rgb2hsv(history.rgb);
            hsv.x = fract(hsv.x + hueShift); // Shift hue (wrap around)
            hsv.z *= fade * decay; // Apply both fade and decay to value
            vec3 shiftedColor = hsv2rgb(hsv);
            
            // Clamp to prevent overflow from additive blending
            shiftedColor = clamp(shiftedColor, 0.0, 1.0);
            
            gl_FragColor = vec4(shiftedColor, history.a * fade * decay);
        }
    </script>
    
    <div id="hotkey-legend">
        <h4>Hotkeys</h4>
        <div class="hotkey-item">
            <span class="hotkey-key">Space</span>
            <span class="hotkey-desc">Toggle Freeze</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">R</span>
            <span class="hotkey-desc">Randomize</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">← →</span>
            <span class="hotkey-desc">Cycle Presets</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">J</span>
            <span class="hotkey-desc">Toggle Jiggle</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">Esc</span>
            <span class="hotkey-desc">Clear Screen</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↑</span>
            <span class="hotkey-desc">Accelerate</span>
        </div>
        <div class="hotkey-item">
            <span class="hotkey-key">↓</span>
            <span class="hotkey-desc">Decelerate</span>
        </div>
    </div>
    
    <div id="status-indicators">
        <span id="freeze-indicator" style="display: none; background: #0af; color: #fff;">FREEZE</span>
        <span id="jiggle-indicator" style="display: none; background: #a0a; color: #fff;">JIGGLE</span>
        <span id="unsaved-indicator" style="display: none; background: #fa0; color: #fff;">UNSAVED</span>
    </div>
    
    <div id="dev-toolbox">
        <h3>Controls</h3>
        
        <div class="control-group">
            <label for="preset-select">Preset</label>
            <select id="preset-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="">-- Select --</option>
            </select>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <input type="text" id="preset-name-input" placeholder="Name" style="flex: 1; font-size: 10px; padding: 3px 6px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <button id="save-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                <button id="delete-preset-btn" style="font-size: 10px; padding: 3px 6px; background: #a00; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Del</button>
            </div>
            <div style="margin-top: 6px; display: flex; gap: 4px;">
                <button id="export-presets-btn" style="font-size: 10px; padding: 3px 6px; background: #0a0; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Export</button>
                <label for="import-presets-input" style="font-size: 10px; padding: 3px 6px; background: #fa0; color: #fff; border: none; border-radius: 3px; cursor: pointer; display: inline-block; height: auto; line-height: normal; box-sizing: border-box;">Import</label>
                <input type="file" id="import-presets-input" accept=".json,.txt" style="display: none;">
            </div>
        </div>
        
        <div class="section-header">Shape</div>
        <div class="control-group">
            <label for="spikiness-slider">Spikiness</label>
            <div class="control-row">
                <input type="range" id="spikiness-slider" min="0" max="100" value="50" step="1">
                <div class="value" contenteditable="true" id="spikiness-value">0.50</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-frequency-slider">Frequency</label>
            <div class="control-row">
                <input type="range" id="spike-frequency-slider" min="2" max="20" value="5" step="0.1">
                <div class="value" contenteditable="true" id="spike-frequency-value">5.0</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spike-sharpness-slider">Sharpness</label>
            <div class="control-row">
                <input type="range" id="spike-sharpness-slider" min="0" max="100" value="0" step="1">
                <div class="value" contenteditable="true" id="spike-sharpness-value">0.00</div>
            </div>
        </div>
        
        <div class="section-header">Appearance</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-slider">Hue</label>
                <div class="control-row">
                    <input type="range" id="hue-slider" min="0" max="360" value="45" step="1">
                    <div class="value" contenteditable="true" id="hue-value">45°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="scale-slider">Scale</label>
                <div class="control-row">
                    <input type="range" id="scale-slider" min="0.05" max="1.0" value="0.2" step="0.01">
                    <div class="value" contenteditable="true" id="scale-value">0.20</div>
                </div>
            </div>
        </div>
        
        <div class="two-column">
            <div class="control-group">
                <label for="fill-size-slider">Fill Size</label>
                <div class="control-row">
                    <input type="range" id="fill-size-slider" min="0" max="100" value="0" step="1">
                    <div class="value" contenteditable="true" id="fill-size-value">0.00</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="fill-opacity-slider">Fill Opacity</label>
                <div class="control-row">
                    <input type="range" id="fill-opacity-slider" min="0" max="100" value="60" step="1">
                    <div class="value" contenteditable="true" id="fill-opacity-value">0.60</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Emanation</div>
        <div class="control-group">
            <label for="dilation-slider">Dilation Speed</label>
            <div class="control-row">
                <input type="range" id="dilation-slider" min="0" max="200" value="20" step="1">
                <div class="value" contenteditable="true" id="dilation-value">1.01</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="fade-slider">Fade Amount</label>
            <div class="control-row">
                <input type="range" id="fade-slider" min="0" max="100" value="30" step="1">
                <div class="value" contenteditable="true" id="fade-value">0.30</div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="emanation-rate-slider">Rate (per sec)</label>
            <div class="control-row">
                <input type="range" id="emanation-rate-slider" min="2" max="30" value="2" step="0.1">
                <div class="value" contenteditable="true" id="emanation-rate-value">2.0</div>
            </div>
        </div>
        
        <div class="section-header">Rotation</div>
        <div class="two-column">
            <div class="control-group">
                <label for="rotation-slider">Manual</label>
                <div class="control-row">
                    <input type="range" id="rotation-slider" min="0" max="360" value="0" step="1">
                    <div class="value" contenteditable="true" id="rotation-value">0°</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="auto-rotation-slider">Auto (deg/s)</label>
                <div class="control-row">
                    <input type="range" id="auto-rotation-slider" min="0" max="200" value="50" step="1">
                    <div class="value" contenteditable="true" id="auto-rotation-value">30°</div>
                </div>
            </div>
        </div>
        
        <div class="section-header">Effects</div>
        <div class="two-column">
            <div class="control-group">
                <label for="hue-shift-slider">Hue Shift</label>
                <div class="control-row">
                    <input type="range" id="hue-shift-slider" min="0.0" max="0.2" value="0.05" step="0.001">
                    <div class="value" contenteditable="true" id="hue-shift-value">0.050</div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="blend-opacity-slider">Opacity</label>
                <div class="control-row">
                    <input type="range" id="blend-opacity-slider" min="0.0" max="1.0" value="0.3" step="0.01">
                    <div class="value" contenteditable="true" id="blend-opacity-value">0.30</div>
                </div>
            </div>
        </div>
        
        <div class="control-group">
            <label for="blend-mode-select">Blend Mode</label>
            <select id="blend-mode-select" style="width: 100%; font-size: 10px; padding: 3px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <option value="additive">Additive</option>
                <option value="alpha" selected>Alpha Blend</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
            </select>
        </div>
        
        <div class="section-header">Actions</div>
        <div class="control-group">
            <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                <button id="randomize-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Randomize</button>
                <button id="jiggle-btn" style="flex: 1; font-size: 10px; padding: 6px; background: #a0a; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-weight: 500;">Jiggle</button>
            </div>
            <label for="jiggle-amount-slider">Jiggle Amount</label>
            <div class="control-row">
                <input type="range" id="jiggle-amount-slider" min="0" max="100" value="10" step="1">
                <div class="value" contenteditable="true" id="jiggle-amount-value">10%</div>
            </div>
        </div>
    </div>
    
    <script>
        // Simple WebGL renderer
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.program = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Resize textures if they exist
                if (this.historyTexture && this.currentTexture) {
                    this.setupFramebuffers();
                }
            }
            
            setupFramebuffers() {
                const gl = this.gl;
                
                // Create or recreate history texture
                if (this.historyTexture) {
                    gl.deleteTexture(this.historyTexture);
                }
                if (this.historyFramebuffer) {
                    gl.deleteFramebuffer(this.historyFramebuffer);
                }
                
                this.historyTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.historyFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.historyTexture, 0);
                
                // Create or recreate current texture
                if (this.currentTexture) {
                    gl.deleteTexture(this.currentTexture);
                }
                if (this.currentFramebuffer) {
                    gl.deleteFramebuffer(this.currentFramebuffer);
                }
                
                this.currentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.currentFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.currentTexture, 0);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const info = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${info}`);
                }
                
                return shader;
            }
            
            init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource) {
                const gl = this.gl;
                
                // Compile shape shader
                const vertexShader = this.compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.program);
                    throw new Error(`Program linking error: ${info}`);
                }
                
                // Compile dilation shader
                const dilationVertexShader = this.compileShader(dilationVertexSource, gl.VERTEX_SHADER);
                const dilationFragmentShader = this.compileShader(dilationFragmentSource, gl.FRAGMENT_SHADER);
                this.dilationProgram = gl.createProgram();
                gl.attachShader(this.dilationProgram, dilationVertexShader);
                gl.attachShader(this.dilationProgram, dilationFragmentShader);
                gl.linkProgram(this.dilationProgram);
                
                if (!gl.getProgramParameter(this.dilationProgram, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.dilationProgram);
                    throw new Error(`Dilation program linking error: ${info}`);
                }
                
                // Setup full-screen quad (shared buffer)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1
                ]);
                
                this.quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Setup position attribute for shape program
                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup position attribute for dilation program
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup framebuffers
                this.setupFramebuffers();
                
                // Clear history texture to black
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                gl.useProgram(this.program);
            }
            
            setUniform(name, value, program = null) {
                const gl = this.gl;
                const targetProgram = program || this.program;
                const location = gl.getUniformLocation(targetProgram, name);
                
                if (location === null) return;
                
                if (typeof value === 'number') {
                    gl.uniform1f(location, value);
                } else if (Array.isArray(value)) {
                    if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    } else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                }
            }
            
            setBlendMode(mode, opacity) {
                const gl = this.gl;
                
                switch(mode) {
                    case 'additive':
                        // Additive: src + dst (bright, accumulates)
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'alpha':
                        // Alpha blend: src * alpha + dst * (1 - alpha)
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'multiply':
                        // Multiply: src * dst (darker)
                        gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'screen':
                        // Screen: 1 - (1 - src) * (1 - dst) (lighter)
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'overlay':
                        // Overlay: if dst < 0.5: 2 * multiply, else: 2 * screen - 1
                        // True overlay requires reading destination buffer (not possible with simple blend funcs)
                        // Approximation: use a combination that's closer to overlay behavior
                        // Using DST_COLOR with ONE gives multiply-like effect for darker areas
                        gl.blendFunc(gl.DST_COLOR, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    default:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                }
                
                // Apply opacity by modifying blend color (requires shader modification)
                // For now, opacity affects the shape shader output
            }
            
            render(uniforms, dilationFactor, shouldCaptureShape, fadeAmount, hueShiftAmount, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation) {
                const gl = this.gl;
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                const shapePositionLocation = gl.getAttribLocation(this.program, 'a_position');
                
                // Calculate center pixel coordinates for clearing
                const centerX = Math.floor(this.canvas.width / 2);
                const centerY = Math.floor(this.canvas.height / 2);
                
                // Step 1: Dilation pass - expand history texture
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                
                // Setup vertex attributes
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Set dilation uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                const dilationHistoryLocation = gl.getUniformLocation(this.dilationProgram, 'u_history');
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', dilationFactor, this.dilationProgram);
                this.setUniform('u_fadeAmount', fadeAmount, this.dilationProgram);
                this.setUniform('u_hueShiftAmount', hueShiftAmount, this.dilationProgram);
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Clear center 4 pixels to prevent white accumulation
                gl.enable(gl.SCISSOR_TEST);
                gl.scissor(centerX - 1, centerY - 1, 2, 2);
                gl.clearColor(0, 0, 0, 0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.disable(gl.SCISSOR_TEST);
                
                // Step 2: Draw current shape (only add to history if shouldCaptureShape is true)
                // This controls the emanation rate - how frequently new shapes are captured
                if (shouldCaptureShape) {
                    gl.useProgram(this.program);
                    gl.enableVertexAttribArray(shapePositionLocation);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Enable blending with configurable mode
                    gl.enable(gl.BLEND);
                    this.setBlendMode(blendMode, blendOpacity);
                    
                    Object.keys(uniforms).forEach(name => {
                        this.setUniform(name, uniforms[name]);
                    });
                    this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                    this.setUniform('u_rotation', totalRotation); // Capture total rotation at this moment
                    this.setUniform('u_autoRotationSpeed', 0.0); // Disable auto-rotation for captured shapes (they're frozen)
                    this.setUniform('u_blendOpacity', blendOpacity);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND);
                }
                
                // Step 3: Display current texture to screen
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for display
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 4: Draw current star on top of everything (always visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable blending with configurable mode
                gl.enable(gl.BLEND);
                this.setBlendMode(blendMode, blendOpacity);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                this.setUniform('u_rotation', rotation);
                this.setUniform('u_autoRotationSpeed', autoRotationSpeed);
                this.setUniform('u_blendOpacity', blendOpacity);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 5: Copy current texture to history for next frame (always, for smooth dilation)
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for copy
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        
        // Get shader from script tag
        function getShader(id) {
            const script = document.getElementById(id);
            if (!script) {
                throw new Error(`Shader script not found: ${id}`);
            }
            return script.textContent;
        }
        
        // Initialize
        function init() {
            const canvas = document.getElementById('canvas');
            const renderer = new SimpleRenderer(canvas);
            
            // Get shaders from script tags
            const vertexSource = getShader('star-vertex-shader');
            const fragmentSource = getShader('star-fragment-shader');
            const dilationVertexSource = getShader('dilation-vertex-shader');
            const dilationFragmentSource = getShader('dilation-fragment-shader');
            
            renderer.init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource);
            
            return renderer;
        }
        
        const renderer = init();
        
        (() => {
            // Get slider elements
            const spikinessSlider = document.getElementById('spikiness-slider');
            const spikeFrequencySlider = document.getElementById('spike-frequency-slider');
            const spikeSharpnessSlider = document.getElementById('spike-sharpness-slider');
            const hueSlider = document.getElementById('hue-slider');
            const scaleSlider = document.getElementById('scale-slider');
            const dilationSlider = document.getElementById('dilation-slider');
            const fadeSlider = document.getElementById('fade-slider');
            const hueShiftSlider = document.getElementById('hue-shift-slider');
            const rotationSlider = document.getElementById('rotation-slider');
            const spikinessValue = document.getElementById('spikiness-value');
            const spikeFrequencyValue = document.getElementById('spike-frequency-value');
            const spikeSharpnessValue = document.getElementById('spike-sharpness-value');
            const hueValue = document.getElementById('hue-value');
            const scaleValue = document.getElementById('scale-value');
            const dilationValue = document.getElementById('dilation-value');
            const fadeValue = document.getElementById('fade-value');
            const hueShiftValue = document.getElementById('hue-shift-value');
            const rotationValue = document.getElementById('rotation-value');
            const blendModeSelect = document.getElementById('blend-mode-select');
            const blendOpacitySlider = document.getElementById('blend-opacity-slider');
            const blendOpacityValue = document.getElementById('blend-opacity-value');
            const fillSizeSlider = document.getElementById('fill-size-slider');
            const fillSizeValue = document.getElementById('fill-size-value');
            const fillOpacitySlider = document.getElementById('fill-opacity-slider');
            const fillOpacityValue = document.getElementById('fill-opacity-value');
            const randomizeBtn = document.getElementById('randomize-btn');
            const jiggleBtn = document.getElementById('jiggle-btn');
            const jiggleAmountSlider = document.getElementById('jiggle-amount-slider');
            const jiggleAmountValue = document.getElementById('jiggle-amount-value');
            
            // Get emanation rate slider before initializing values
            const emanationRateSlider = document.getElementById('emanation-rate-slider');
            const emanationRateValue = document.getElementById('emanation-rate-value');
            const autoRotationSlider = document.getElementById('auto-rotation-slider');
            const autoRotationValue = document.getElementById('auto-rotation-value');
            
            // Get preset management elements before defining functions
            const presetSelect = document.getElementById('preset-select');
            const presetNameInput = document.getElementById('preset-name-input');
            const savePresetBtn = document.getElementById('save-preset-btn');
            const deletePresetBtn = document.getElementById('delete-preset-btn');
            const exportPresetsBtn = document.getElementById('export-presets-btn');
            const importPresetsInput = document.getElementById('import-presets-input');
            
            // Status indicators
            const freezeIndicator = document.getElementById('freeze-indicator');
            const jiggleIndicator = document.getElementById('jiggle-indicator');
            const unsavedIndicator = document.getElementById('unsaved-indicator');
            const statusIndicators = document.getElementById('status-indicators');
            const hotkeyLegend = document.getElementById('hotkey-legend');
            
            // Position status indicators below hotkey legend
            function positionStatusIndicators() {
                if (hotkeyLegend && statusIndicators) {
                    const rect = hotkeyLegend.getBoundingClientRect();
                    statusIndicators.style.top = (rect.bottom + 6) + 'px';
                    statusIndicators.style.left = rect.left + 'px';
                }
            }
            // Position on load and resize
            positionStatusIndicators();
            window.addEventListener('resize', positionStatusIndicators);
            
            // Track last loaded preset for unsaved changes detection
            let lastLoadedPresetName = null;
            let lastLoadedPresetValues = null;
            
            // Function to update status indicators
            function updateStatusIndicators() {
                freezeIndicator.style.display = freezeEnabled ? 'inline-block' : 'none';
                jiggleIndicator.style.display = jiggleEnabled ? 'inline-block' : 'none';
                
                // Check if current values differ from last loaded preset
                if (lastLoadedPresetName && lastLoadedPresetValues) {
                    const currentValues = {
                        spikiness, spikeFrequency, spikeSharpness, hue, scale,
                        fillSize, fillOpacity, rotation, hueShiftAmount,
                        dilationSpeed, fadeAmount, emanationRate, autoRotationSpeed,
                        blendMode, blendOpacity
                    };
                    
                    // Compare values (with small tolerance for floating point)
                    let hasChanges = false;
                    for (const [key, currentValue] of Object.entries(currentValues)) {
                        const lastValue = lastLoadedPresetValues[key];
                        if (lastValue !== undefined && Math.abs(currentValue - lastValue) > 0.001) {
                            hasChanges = true;
                            break;
                        }
                    }
                    // Also check blendMode (string comparison)
                    if (currentValues.blendMode !== lastLoadedPresetValues.blendMode) {
                        hasChanges = true;
                    }
                    
                    unsavedIndicator.style.display = hasChanges ? 'inline-block' : 'none';
                } else {
                    unsavedIndicator.style.display = 'none';
                }
            }
            
            // Preset management functions (need to be defined before we try to load presets)
            // Load presets from localStorage
            function loadPresets() {
                const presets = JSON.parse(localStorage.getItem('sandboxPresets') || '{}');
                presetSelect.innerHTML = '<option value="">-- Select Preset --</option>';
                Object.keys(presets).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    presetSelect.appendChild(option);
                });
                return presets;
            }
            
            // Load preset
            function loadPreset(name) {
                const presets = loadPresets();
                if (!presets[name]) {
                    alert('Preset not found');
                    return;
                }
                
                const preset = presets[name];
                
                // Set all values
                // Handle migration from old "spikes" parameter to new shape parameters
                if (preset.spikes !== undefined) {
                    // Old preset format: convert discrete spikes to continuous parameters
                    const oldSpikes = preset.spikes;
                    spikiness = 0.8; // Default spikiness for old presets
                    spikeFrequency = Math.max(2.0, Math.min(20.0, oldSpikes)); // Use old spike count as frequency
                    spikeSharpness = 0.0; // Default sharpness
                } else {
                    // New preset format
                    spikiness = preset.spikiness !== undefined ? preset.spikiness : 0.5;
                    spikeFrequency = preset.spikeFrequency !== undefined ? preset.spikeFrequency : 5.0;
                    spikeSharpness = preset.spikeSharpness !== undefined ? preset.spikeSharpness : 0.0;
                }
                hue = preset.hue;
                scale = preset.scale;
                hueShiftAmount = preset.hueShiftAmount;
                rotation = preset.rotation;
                blendMode = preset.blendMode;
                blendOpacity = preset.blendOpacity;
                fillSize = preset.fillSize !== undefined ? preset.fillSize : 0.0;
                fillOpacity = preset.fillOpacity !== undefined ? preset.fillOpacity : 0.6;
                emanationRate = preset.emanationRate;
                autoRotationSpeed = preset.autoRotationSpeed;
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = hue;
                hueValue.textContent = hue + '°';
                scaleSlider.value = scale;
                scaleValue.textContent = scale.toFixed(2);
                dilationSlider.value = preset.dilationSlider || 20;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(parseFloat(dilationSlider.value) / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = preset.fadeSlider || 30;
                fadeAmount = Math.pow(parseFloat(fadeSlider.value) / 100.0, 1.0 / 3.0) * 5.0;
                fadeValue.textContent = fadeAmount.toFixed(3);
                hueShiftSlider.value = hueShiftAmount;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                rotationSlider.value = rotation;
                rotationValue.textContent = rotation + '°';
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                emanationRateSlider.value = emanationRate;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                // Use stored slider value if available, otherwise reverse map from speed value
                if (preset.autoRotationSlider !== undefined) {
                    autoRotationSlider.value = preset.autoRotationSlider;
                    autoRotationSpeed = -1.0 + Math.pow(preset.autoRotationSlider / 200.0, 0.5) * 361.0;
                } else {
                    // Fallback: reverse map from speed value
                    const sliderValue = Math.round(200 * Math.pow((autoRotationSpeed + 1) / 361.0, 2));
                    autoRotationSlider.value = sliderValue;
                }
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Update dropdown to show the loaded preset
                presetSelect.value = name;
            }
            
            // Initialize presets dropdown
            loadPresets();
            
            // Try to load last active preset BEFORE initializing default values
            const lastActivePreset = localStorage.getItem('sandboxLastActivePreset');
            let presetLoaded = false;
            if (lastActivePreset) {
                const presets = loadPresets();
                if (presets[lastActivePreset]) {
                    presetSelect.value = lastActivePreset;
                    presetLoaded = true;
                }
            }
            
            // Current values (initialize from sliders, or from preset if one was loaded)
            let spikiness = parseFloat(spikinessSlider.value) / 100.0; // Convert 0-100 to 0-1
            let spikeFrequency = parseFloat(spikeFrequencySlider.value);
            let spikeSharpness = parseFloat(spikeSharpnessSlider.value) / 100.0; // Convert 0-100 to 0-1
            let hue = parseFloat(hueSlider.value);
            let scale = parseFloat(scaleSlider.value);
            // Initialize dilation speed with exponential mapping
            // Map slider (0-200) to dilation speed, with middle (100) = 1.0
            const initialDilationSlider = parseFloat(dilationSlider.value);
            // Use very steep curve (1/8 power) for super granular control near 1.0
            // Adjust range so slider value 100 maps to exactly 1.0
            const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0); // Power value at middle
            const range = (1.22 - 0.88) / (1.0 - midPower); // Adjusted range
            const min = 1.0 - midPower * range; // Adjusted minimum
            let dilationSpeed = min + Math.pow(initialDilationSlider / 200.0, 1.0 / 8.0) * range;
            // Initialize fade amount with logarithmic mapping (0 to 5.0 range)
            const initialFadeSlider = parseFloat(fadeSlider.value);
            // Map slider 0-100 to 0 to 5.0 (logarithmic curve)
            fadeAmount = Math.pow(initialFadeSlider / 100.0, 1.0 / 3.0) * 5.0;
            let hueShiftAmount = parseFloat(hueShiftSlider.value);
            let rotation = parseFloat(rotationSlider.value);
            let blendMode = blendModeSelect.value;
            let blendOpacity = parseFloat(blendOpacitySlider.value);
            let fillSize = parseFloat(fillSizeSlider.value) / 100.0; // Convert 0-100 to 0-1
            let fillOpacity = parseFloat(fillOpacitySlider.value) / 100.0; // Convert 0-100 to 0-1
            let emanationRate = parseFloat(emanationRateSlider.value); // Emanations per second
            let jiggleAmount = parseFloat(jiggleAmountSlider.value) / 100.0; // Convert 0-100 to 0-1
            jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            let jiggleEnabled = false;
            
            // Store base values for jiggle (when jiggle is off, these match current values)
            let baseSpikiness = spikiness;
            let baseSpikeFrequency = spikeFrequency;
            let baseSpikeSharpness = spikeSharpness;
            let baseHue = hue;
            let baseScale = scale;
            let baseFillSize = fillSize;
            let baseFillOpacity = fillOpacity;
            let baseRotation = rotation;
            let baseHueShiftAmount = hueShiftAmount;
            
            // Target origins for jiggle when user edits params during jiggle
            // Jiggle will smoothly ease its orbit center toward these targets
            let targetBaseSpikiness = baseSpikiness;
            let targetBaseSpikeFrequency = baseSpikeFrequency;
            let targetBaseSpikeSharpness = baseSpikeSharpness;
            let targetBaseHue = baseHue;
            let targetBaseScale = baseScale;
            let targetBaseFillSize = baseFillSize;
            let targetBaseFillOpacity = baseFillOpacity;
            let targetBaseRotation = baseRotation;
            let targetBaseHueShiftAmount = baseHueShiftAmount;
            // Initialize auto rotation speed with exponential mapping
            // Map slider (0-200) to rotation speed (-1 to 360)
            const initialAutoRotationSlider = parseFloat(autoRotationSlider.value);
            // Use exponential curve for granular control
            let autoRotationSpeed = -1.0 + Math.pow(initialAutoRotationSlider / 200.0, 0.5) * 361.0; // Range: -1 to 360
            
            // Now load the preset if one was found (this will override the default values)
            if (presetLoaded) {
                loadPreset(lastActivePreset);
            } else {
                // If no preset loaded, initialize status indicators
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
        
            // Helper function to handle editable value changes
            // Direct input bypasses clamping - allows any value
            function handleValueEdit(valueElement, parseFn, formatFn, updateFn) {
                valueElement.addEventListener('blur', (e) => {
                    const text = e.target.textContent.trim();
                    const numValue = parseFn(text);
                    if (!isNaN(numValue)) {
                        // No clamping - accept the value as-is
                        const formatted = formatFn(numValue);
                        e.target.textContent = formatted;
                        updateFn(numValue);
                    } else {
                        // Restore previous value on invalid input
                        const currentValue = parseFn(e.target.textContent);
                        if (!isNaN(currentValue)) {
                            e.target.textContent = formatFn(currentValue);
                        }
                    }
                });
                
                valueElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        e.target.blur();
                    }
                });
            }
            
            // Update sliders
            spikinessSlider.addEventListener('input', (e) => {
                spikiness = parseFloat(e.target.value) / 100.0;
                spikinessValue.textContent = spikiness.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikinessValue, 
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    spikiness = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    spikinessSlider.value = Math.round(clampedForSlider * 100);
                    updateBaseValues();
                }
            );
            
            spikeFrequencySlider.addEventListener('input', (e) => {
                spikeFrequency = parseFloat(e.target.value);
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                updateBaseValues();
            });
            
            handleValueEdit(spikeFrequencyValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    spikeFrequency = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(2, Math.min(20, val));
                    spikeFrequencySlider.value = clampedForSlider;
                    updateBaseValues();
                }
            );
            
            spikeSharpnessSlider.addEventListener('input', (e) => {
                spikeSharpness = parseFloat(e.target.value) / 100.0;
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(spikeSharpnessValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    spikeSharpness = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    spikeSharpnessSlider.value = Math.round(clampedForSlider * 100);
                    updateBaseValues();
                }
            );
            
            hueSlider.addEventListener('input', (e) => {
                hue = parseFloat(e.target.value);
                hueValue.textContent = hue + '°';
                updateBaseValues();
            });
            
            handleValueEdit(hueValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    hue = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(360, val));
                    hueSlider.value = Math.round(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            scaleSlider.addEventListener('input', (e) => {
                scale = parseFloat(e.target.value);
                scaleValue.textContent = scale.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(scaleValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    scale = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0.05, Math.min(1.0, val));
                    scaleSlider.value = clampedForSlider.toFixed(2);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map dilation speed to slider value
            function dilationSpeedToSlider(speed) {
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                // Reverse: speed = min + (slider/200)^(1/8) * range
                // slider = 200 * ((speed - min) / range)^8
                const normalized = (speed - min) / range;
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
            }
            
            dilationSlider.addEventListener('input', (e) => {
                // Map slider value (0-200) to dilation speed, with middle (100) = 1.0
                const sliderValue = parseFloat(e.target.value);
                // Use very steep curve (1/8 power) for super granular control near 1.0
                // Adjust range so slider value 100 maps to exactly 1.0
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0); // Power value at middle
                const range = (1.22 - 0.88) / (1.0 - midPower); // Adjusted range
                const min = 1.0 - midPower * range; // Adjusted minimum
                dilationSpeed = min + Math.pow(sliderValue / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4); // More decimal places for precision
            });
            
            handleValueEdit(dilationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(4),
                (val) => {
                    dilationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0.88, Math.min(1.22, val));
                    dilationSlider.value = dilationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map fade amount to slider value
            function fadeAmountToSlider(amount) {
                // Reverse: amount = (slider/100)^(1/3) * 5.0
                // slider = 100 * (amount / 5.0)^3
                return Math.round(100 * Math.pow(Math.max(0, Math.min(1, amount / 5.0)), 3));
            }
            
            fadeSlider.addEventListener('input', (e) => {
                // Map slider value (0-100) to fade amount (0 to 5.0) with logarithmic curve
                const sliderValue = parseFloat(e.target.value);
                fadeAmount = Math.pow(sliderValue / 100.0, 1.0 / 3.0) * 5.0;
                fadeValue.textContent = fadeAmount.toFixed(3);
            });
            
            handleValueEdit(fadeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    fadeAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(5.0, val));
                    fadeSlider.value = fadeAmountToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            hueShiftSlider.addEventListener('input', (e) => {
                hueShiftAmount = parseFloat(e.target.value);
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                updateBaseValues();
            });
            
            handleValueEdit(hueShiftValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(3),
                (val) => {
                    hueShiftAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(0.2, val));
                    hueShiftSlider.value = clampedForSlider.toFixed(3);
                    updateBaseValues();
                }
            );
            
            rotationSlider.addEventListener('input', (e) => {
                rotation = parseFloat(e.target.value);
                rotationValue.textContent = rotation + '°';
                updateBaseValues();
            });
            
            handleValueEdit(rotationValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => Math.round(val) + '°',
                (val) => {
                    rotation = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(360, val));
                    rotationSlider.value = Math.round(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            blendModeSelect.addEventListener('change', (e) => {
                blendMode = e.target.value;
                updateStatusIndicators();
            });
            
            blendOpacitySlider.addEventListener('input', (e) => {
                blendOpacity = parseFloat(e.target.value);
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                updateStatusIndicators();
            });
            
            handleValueEdit(blendOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    blendOpacity = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    blendOpacitySlider.value = clampedForSlider.toFixed(2);
                    updateBaseValues();
                }
            );
            
            fillSizeSlider.addEventListener('input', (e) => {
                fillSize = parseFloat(e.target.value) / 100.0;
                fillSizeValue.textContent = fillSize.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillSizeValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillSize = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    fillSizeSlider.value = Math.round(clampedForSlider * 100);
                    updateBaseValues();
                }
            );
            
            fillOpacitySlider.addEventListener('input', (e) => {
                fillOpacity = parseFloat(e.target.value) / 100.0;
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                updateBaseValues();
            });
            
            handleValueEdit(fillOpacityValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(2),
                (val) => {
                    fillOpacity = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    fillOpacitySlider.value = Math.round(clampedForSlider * 100);
                    updateBaseValues();
                }
            );
            
            emanationRateSlider.addEventListener('input', (e) => {
                emanationRate = parseFloat(e.target.value);
                emanationRateValue.textContent = emanationRate.toFixed(1);
                updateStatusIndicators();
            });
            
            handleValueEdit(emanationRateValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')),
                (val) => val.toFixed(1),
                (val) => {
                    emanationRate = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(2, Math.min(30, val));
                    emanationRateSlider.value = clampedForSlider;
                    updateBaseValues();
                }
            );
            
            // Helper function to reverse-map auto rotation speed to slider value
            function autoRotationSpeedToSlider(speed) {
                // Reverse: speed = -1 + (slider/200)^0.5 * 361
                // slider = 200 * ((speed + 1) / 361)^2
                return Math.round(200 * Math.pow(Math.max(0, Math.min(1, (speed + 1) / 361.0)), 2));
            }
            
            autoRotationSlider.addEventListener('input', (e) => {
                // Map slider value (0-200) to rotation speed (-1 to 360) with exponential curve
                const sliderValue = parseFloat(e.target.value);
                autoRotationSpeed = -1.0 + Math.pow(sliderValue / 200.0, 0.5) * 361.0;
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                updateStatusIndicators();
            });
            
            handleValueEdit(autoRotationValue,
                (text) => parseFloat(text.replace(/[^0-9.-]/g, '')),
                (val) => val.toFixed(1) + '°',
                (val) => {
                    autoRotationSpeed = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(-1, Math.min(360, val));
                    autoRotationSlider.value = autoRotationSpeedToSlider(clampedForSlider);
                    updateBaseValues();
                }
            );
            
            // Save current state as preset
            function savePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please enter a preset name');
                    return;
                }
                
                const preset = {
                    spikiness: spikiness,
                    spikeFrequency: spikeFrequency,
                    spikeSharpness: spikeSharpness,
                    hue: hue,
                    scale: scale,
                    fillSize: fillSize,
                    fillOpacity: fillOpacity,
                    dilationSlider: parseFloat(dilationSlider.value), // Store slider value for proper restoration
                    fadeSlider: parseFloat(fadeSlider.value), // Store slider value for proper restoration
                    hueShiftAmount: hueShiftAmount,
                    rotation: rotation,
                    blendMode: blendMode,
                    blendOpacity: blendOpacity,
                    emanationRate: emanationRate,
                    autoRotationSpeed: autoRotationSpeed, // Store actual value (will reverse map to slider on load)
                    autoRotationSlider: parseFloat(autoRotationSlider.value) // Also store slider for easier restoration
                };
                
                const presets = loadPresets();
                presets[name] = preset;
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetNameInput.value = '';
                alert(`Preset "${name}" saved!`);
            }
            
            // Delete preset
            function deletePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please select a preset to delete');
                    return;
                }
                
                if (!confirm(`Delete preset "${name}"?`)) {
                    return;
                }
                
                const presets = loadPresets();
                delete presets[name];
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetSelect.value = '';
            }
            
            // Event listeners
            presetSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadPreset(e.target.value);
                    localStorage.setItem('sandboxLastActivePreset', e.target.value);
                }
            });
            
            savePresetBtn.addEventListener('click', () => {
                const presetName = presetNameInput.value.trim();
                savePreset(presetName);
                if (presetName) {
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                    presetSelect.value = presetName;
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            deletePresetBtn.addEventListener('click', () => {
                const presetToDelete = presetSelect.value;
                deletePreset(presetToDelete);
                if (localStorage.getItem('sandboxLastActivePreset') === presetToDelete) {
                    localStorage.removeItem('sandboxLastActivePreset');
                }
                // Update preset names list for hotkeys (if updatePresetNames is defined)
                if (typeof updatePresetNames === 'function') {
                    updatePresetNames();
                }
            });
            
            // Export presets to JSON file
            exportPresetsBtn.addEventListener('click', () => {
                const presets = loadPresets();
                const jsonString = JSON.stringify(presets, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sandbox-presets.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(`Exported ${Object.keys(presets).length} preset(s) to sandbox-presets.json`);
            });
            
            // Import presets from JSON file
            importPresetsInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importedPresets = JSON.parse(event.target.result);
                        
                        if (typeof importedPresets !== 'object' || Array.isArray(importedPresets)) {
                            alert('Invalid preset file format. Expected an object with preset names as keys.');
                            return;
                        }
                        
                        // Load current presets
                        const currentPresets = loadPresets();
                        
                        // Merge imported presets with current presets (imported presets take precedence for conflicts)
                        let importedCount = 0;
                        let overwrittenCount = 0;
                        for (const [name, preset] of Object.entries(importedPresets)) {
                            if (currentPresets[name]) {
                                overwrittenCount++;
                            } else {
                                importedCount++;
                            }
                            currentPresets[name] = preset;
                        }
                        
                        // Save merged presets
                        localStorage.setItem('sandboxPresets', JSON.stringify(currentPresets));
                        loadPresets();
                        
                        // Update preset names list for hotkeys (if updatePresetNames is defined)
                        if (typeof updatePresetNames === 'function') {
                            updatePresetNames();
                        }
                        
                        // Reset file input
                        e.target.value = '';
                        
                        const message = `Imported ${importedCount} new preset(s)${overwrittenCount > 0 ? ` and overwrote ${overwrittenCount} existing preset(s)` : ''}.`;
                        alert(message);
                    } catch (error) {
                        alert(`Error importing presets: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            });
            
            // Randomize function
            function randomizeAll() {
                // Randomize all parameters within their valid ranges
                
                // Shape parameters
                spikiness = Math.random();
                spikeFrequency = 2 + Math.random() * 18; // 2-20
                spikeSharpness = Math.random();
                hue = Math.random() * 360;
                scale = 0.05 + Math.random() * 0.95; // 0.05-1.0
                fillSize = Math.random();
                fillOpacity = Math.random();
                rotation = Math.random() * 360;
                hueShiftAmount = Math.random() * 0.2; // 0-0.2
                
                // Blend parameters
                const blendModes = ['additive', 'alpha', 'multiply', 'screen', 'overlay'];
                blendMode = blendModes[Math.floor(Math.random() * blendModes.length)];
                blendOpacity = Math.random();
                
                // Emanation parameters
                // Dilation speed: 0.88-1.22 (use slider range 0-200, map to actual value)
                const randomDilationSlider = Math.random() * 200;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(randomDilationSlider / 200.0, 1.0 / 8.0) * range;
                
                // Fade amount: 0-5.0 (use slider range 0-100, map to actual value)
                const randomFadeSlider = Math.random() * 100;
                fadeAmount = Math.pow(randomFadeSlider / 100.0, 1.0 / 3.0) * 5.0;
                
                // Emanation rate: 2-30
                emanationRate = 2 + Math.random() * 28;
                
                // Auto rotation speed: -1 to 360 (use slider range 0-200, map to actual value)
                const randomAutoRotationSlider = Math.random() * 200;
                autoRotationSpeed = -1.0 + Math.pow(randomAutoRotationSlider / 200.0, 0.5) * 361.0;
                
                // Update sliders
                spikinessSlider.value = Math.round(spikiness * 100);
                spikinessValue.textContent = spikiness.toFixed(2);
                spikeFrequencySlider.value = spikeFrequency;
                spikeFrequencyValue.textContent = spikeFrequency.toFixed(1);
                spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                spikeSharpnessValue.textContent = spikeSharpness.toFixed(2);
                hueSlider.value = Math.round(hue);
                hueValue.textContent = Math.round(hue) + '°';
                scaleSlider.value = scale.toFixed(2);
                scaleValue.textContent = scale.toFixed(2);
                fillSizeSlider.value = Math.round(fillSize * 100);
                fillSizeValue.textContent = fillSize.toFixed(2);
                fillOpacitySlider.value = Math.round(fillOpacity * 100);
                fillOpacityValue.textContent = fillOpacity.toFixed(2);
                rotationSlider.value = Math.round(rotation);
                rotationValue.textContent = Math.round(rotation) + '°';
                hueShiftSlider.value = hueShiftAmount.toFixed(3);
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                
                // Update blend controls
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity.toFixed(2);
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                
                // Update emanation controls
                dilationSlider.value = dilationSpeedToSlider(dilationSpeed);
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = fadeAmountToSlider(fadeAmount);
                fadeValue.textContent = fadeAmount.toFixed(3);
                emanationRateSlider.value = emanationRate.toFixed(1);
                emanationRateValue.textContent = emanationRate.toFixed(1);
                
                // Update auto rotation
                autoRotationSlider.value = autoRotationSpeedToSlider(autoRotationSpeed);
                autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                
                // Update base values
                baseSpikiness = spikiness;
                baseSpikeFrequency = spikeFrequency;
                baseSpikeSharpness = spikeSharpness;
                baseHue = hue;
                baseScale = scale;
                baseFillSize = fillSize;
                baseFillOpacity = fillOpacity;
                baseRotation = rotation;
                baseHueShiftAmount = hueShiftAmount;
            }
            
            randomizeBtn.addEventListener('click', randomizeAll);
            
            // Jiggle functionality
            jiggleAmountSlider.addEventListener('input', (e) => {
                jiggleAmount = parseFloat(e.target.value) / 100.0;
                jiggleAmountValue.textContent = Math.round(jiggleAmount * 100) + '%';
            });
            
            handleValueEdit(jiggleAmountValue,
                (text) => parseFloat(text.replace(/[^0-9.]/g, '')) / 100.0, // Convert percentage to 0-1
                (val) => Math.round(val * 100) + '%',
                (val) => {
                    jiggleAmount = val;
                    // Update slider with clamping for slider display only
                    const clampedForSlider = Math.max(0, Math.min(1, val));
                    jiggleAmountSlider.value = Math.round(clampedForSlider * 100);
                }
            );
            
            jiggleBtn.addEventListener('click', () => {
                jiggleEnabled = !jiggleEnabled;
                jiggleBtn.textContent = jiggleEnabled ? 'Stop Jiggle' : 'Jiggle';
                jiggleBtn.style.background = jiggleEnabled ? '#a00' : '#a0a';
                
                if (!jiggleEnabled) {
                    // Keep current jiggled values and update base values to match
                    // This way the values persist when jiggle is turned off
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    // Targets match new bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                    
                    // Update sliders to reflect current values (they should already match, but ensure sync)
                    spikinessSlider.value = Math.round(spikiness * 100);
                    spikeFrequencySlider.value = spikeFrequency;
                    spikeSharpnessSlider.value = Math.round(spikeSharpness * 100);
                    hueSlider.value = Math.round(hue);
                    scaleSlider.value = scale.toFixed(2);
                    fillSizeSlider.value = Math.round(fillSize * 100);
                    fillOpacitySlider.value = Math.round(fillOpacity * 100);
                    rotationSlider.value = Math.round(rotation);
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    
                    // Update status indicators (unsaved state may have changed)
                    updateStatusIndicators();
                } else {
                    // Store current values as base when starting jiggle
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    // Targets start at current bases
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                }
                
                // Update jiggle indicator
                updateStatusIndicators();
            });
            
            // Update base values when sliders change
            function updateBaseValues() {
                if (!jiggleEnabled) {
                    // When jiggle is off, bases track current values directly
                    baseSpikiness = spikiness;
                    baseSpikeFrequency = spikeFrequency;
                    baseSpikeSharpness = spikeSharpness;
                    baseHue = hue;
                    baseScale = scale;
                    baseFillSize = fillSize;
                    baseFillOpacity = fillOpacity;
                    baseRotation = rotation;
                    baseHueShiftAmount = hueShiftAmount;
                    
                    targetBaseSpikiness = baseSpikiness;
                    targetBaseSpikeFrequency = baseSpikeFrequency;
                    targetBaseSpikeSharpness = baseSpikeSharpness;
                    targetBaseHue = baseHue;
                    targetBaseScale = baseScale;
                    targetBaseFillSize = baseFillSize;
                    targetBaseFillOpacity = baseFillOpacity;
                    targetBaseRotation = baseRotation;
                    targetBaseHueShiftAmount = baseHueShiftAmount;
                } else {
                    // When jiggle is on, treat current values as new desired origins
                    // Jiggle will smoothly ease its orbit center toward these targets
                    targetBaseSpikiness = spikiness;
                    targetBaseSpikeFrequency = spikeFrequency;
                    targetBaseSpikeSharpness = spikeSharpness;
                    targetBaseHue = hue;
                    targetBaseScale = scale;
                    targetBaseFillSize = fillSize;
                    targetBaseFillOpacity = fillOpacity;
                    targetBaseRotation = rotation;
                    targetBaseHueShiftAmount = hueShiftAmount;
                }
                // Update status indicators to check for unsaved changes
                if (typeof updateStatusIndicators === 'function') {
                    updateStatusIndicators();
                }
            }
            
            // Hotkey state variables (declared before render function)
            let freezeEnabled = false;
            let originalDilationSpeed = dilationSpeed;
            
            let startTime = Date.now();
            let lastCaptureTime = 0;
            const TARGET_FPS = 60;
            const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
            
            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;
                
                // Apply jiggle if enabled
                if (jiggleEnabled && jiggleAmount > 0) {
                    // Ease bases toward targets so jiggle orbits move smoothly when user edits params
                    const originLerp = 0.1;
                    baseSpikiness += (targetBaseSpikiness - baseSpikiness) * originLerp;
                    baseSpikeFrequency += (targetBaseSpikeFrequency - baseSpikeFrequency) * originLerp;
                    baseSpikeSharpness += (targetBaseSpikeSharpness - baseSpikeSharpness) * originLerp;
                    baseHue += (targetBaseHue - baseHue) * originLerp;
                    baseScale += (targetBaseScale - baseScale) * originLerp;
                    baseFillSize += (targetBaseFillSize - baseFillSize) * originLerp;
                    baseFillOpacity += (targetBaseFillOpacity - baseFillOpacity) * originLerp;
                    baseRotation += (targetBaseRotation - baseRotation) * originLerp;
                    baseHueShiftAmount += (targetBaseHueShiftAmount - baseHueShiftAmount) * originLerp;
                    
                    // Use time-based seed for smooth jiggle
                    const seed = currentTime * 2.0; // Speed of jiggle
                    
                    // Apply random offsets to each parameter based on jiggle amount
                    // Using sin/cos with different frequencies for each parameter for smooth variation
                    spikiness = baseSpikiness + (Math.sin(seed * 1.3) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    spikiness = Math.max(0, Math.min(1, spikiness));
                    
                    spikeFrequency = baseSpikeFrequency + (Math.sin(seed * 1.7) * 0.5 + 0.5 - 0.5) * jiggleAmount * 9.0; // ±9 range
                    spikeFrequency = Math.max(2, Math.min(20, spikeFrequency));
                    
                    spikeSharpness = baseSpikeSharpness + (Math.sin(seed * 1.1) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    spikeSharpness = Math.max(0, Math.min(1, spikeSharpness));
                    
                    hue = baseHue + (Math.sin(seed * 0.8) * 0.5 + 0.5 - 0.5) * jiggleAmount * 180.0; // ±180 range
                    hue = ((hue % 360) + 360) % 360; // Wrap around
                    
                    scale = baseScale + (Math.sin(seed * 1.5) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.3; // ±0.3 range
                    scale = Math.max(0.05, Math.min(1.0, scale));
                    
                    fillSize = baseFillSize + (Math.sin(seed * 1.2) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    fillSize = Math.max(0, Math.min(1, fillSize));
                    
                    fillOpacity = baseFillOpacity + (Math.sin(seed * 1.4) * 0.5 + 0.5 - 0.5) * jiggleAmount;
                    fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                    
                    // Manual rotation does not jiggle; keep rotation from user / auto-rotation
                    
                    hueShiftAmount = baseHueShiftAmount + (Math.sin(seed * 1.6) * 0.5 + 0.5 - 0.5) * jiggleAmount * 0.1; // ±0.1 range
                    hueShiftAmount = Math.max(0, Math.min(0.2, hueShiftAmount));
                }
                
                // Calculate capture interval from emanation rate (emanations per second)
                const captureInterval = 1.0 / emanationRate;
                
                // Check if it's time to capture a new shape
                const shouldCaptureShape = (currentTime - lastCaptureTime) >= captureInterval;
                if (shouldCaptureShape) {
                    lastCaptureTime = currentTime;
                }
                
                // Calculate total rotation (manual + auto) for capturing
                // This ensures captured shapes preserve their rotation at capture time
                const totalRotation = rotation + (currentTime * autoRotationSpeed);
                
                // Apply freeze: if frozen, set dilation to 1.0 (no expansion)
                const effectiveDilationSpeed = freezeEnabled ? 1.0 : dilationSpeed;
                
                renderer.render({
                    u_time: currentTime,
                    u_spikiness: spikiness,
                    u_spikeFrequency: spikeFrequency,
                    u_spikeSharpness: spikeSharpness,
                    u_hue: hue,
                    u_scale: scale,
                    u_fillSize: fillSize,
                    u_fillOpacity: fillOpacity
                }, effectiveDilationSpeed, shouldCaptureShape, fadeAmount, hueShiftAmount, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation);
            }
            
            // Use setInterval for fixed 60fps instead of requestAnimationFrame
            setInterval(render, FRAME_TIME);
            render(); // Initial render
            
            // Hotkey handlers
            let presetNames = [];
            
            // Store reference to original loadPresets before it gets wrapped
            const originalLoadPresetsForHotkeys = loadPresets;
            
            // Update preset names list (use original function to avoid circular reference)
            function updatePresetNames() {
                const presets = originalLoadPresetsForHotkeys();
                presetNames = Object.keys(presets);
            }
            updatePresetNames();
            
            // Track current preset index
            let currentPresetIndex = -1;
            
            // Find current preset index
            function findCurrentPresetIndex() {
                const currentPreset = presetSelect.value;
                currentPresetIndex = presetNames.indexOf(currentPreset);
                if (currentPresetIndex === -1 && presetNames.length > 0) {
                    currentPresetIndex = 0;
                }
            }
            
            // Keyboard event listeners
            document.addEventListener('keydown', (e) => {
                // Ignore hotkeys while typing in text inputs or editable fields
                const active = document.activeElement;
                if (active) {
                    const tag = active.tagName;
                    const type = active.type;
                    const isTextInput = tag === 'INPUT' && type !== 'range' && type !== 'checkbox' && type !== 'radio';
                    const isTextArea = tag === 'TEXTAREA';
                    const isEditable = active.isContentEditable;
                    if (isTextInput || isTextArea || isEditable) {
                        return;
                    }
                }
                
                // Prevent default for our hotkeys (but allow shift for future use)
                if (e.key === ' ' || e.key === 'r' || e.key === 'R' || 
                    e.key === 'j' || e.key === 'J' || e.key === 'Escape' ||
                    e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
                    e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                }
                
                // Space: Toggle freeze (set dilation to 1.0 = no expansion)
                if (e.key === ' ') {
                    freezeEnabled = !freezeEnabled;
                    if (freezeEnabled) {
                        // Store original dilation speed
                        originalDilationSpeed = dilationSpeed;
                        dilationSpeed = 1.0; // No dilation when frozen (1.0 = no expansion)
                    } else {
                        // Restore original dilation speed
                        dilationSpeed = originalDilationSpeed;
                    }
                    updateStatusIndicators();
                }
                
                // R: Randomize
                if (e.key === 'r' || e.key === 'R') {
                    randomizeAll();
                }
                
                // Left/Right arrows: Cycle presets (stub for future refinement)
                if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                    console.log('Preset cycling via arrow keys: TODO refine behavior');
                }
                
                // Up arrow: accelerate auto params (rotation, hue shift, dilation)
                if (e.key === 'ArrowUp') {
                    // Increase auto rotation speed (up to a max) - slower step
                    autoRotationSpeed = Math.min(360.0, autoRotationSpeed + 0.5);
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (autoRotationSpeed + 1) / 361.0)), 2));
                    autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                    
                    // Increase hue shift amount (up to max 0.2) - slower step
                    hueShiftAmount = Math.min(0.2, hueShiftAmount + 0.0002);
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                    
                    // Push dilation further away from 1.0 - slower step
                    const delta = dilationSpeed >= 1.0 ? 0.001 : -0.001;
                    dilationSpeed = Math.max(0.88, Math.min(1.22, dilationSpeed + delta));
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(dilationSpeed);
                    dilationValue.textContent = dilationSpeed.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // Down arrow: decelerate auto params towards neutral
                if (e.key === 'ArrowDown') {
                    // Gently damp auto rotation towards 0 - slower step
                    autoRotationSpeed *= 0.98;
                    autoRotationSlider.value = Math.round(200 * Math.pow(Math.max(0, Math.min(1, (autoRotationSpeed + 1) / 361.0)), 2));
                    autoRotationValue.textContent = autoRotationSpeed.toFixed(1) + '°';
                    
                    // Gently damp hue shift towards 0 - slower step
                    hueShiftAmount *= 0.98;
                    hueShiftSlider.value = hueShiftAmount.toFixed(3);
                    hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                    
                    // Bring dilation towards 1.0 (never snapping) - slower easing
                    dilationSpeed = dilationSpeed + (1.0 - dilationSpeed) * 0.02;
                    dilationSlider.value = (function dilationSpeedToSlider(speed) {
                        const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                        const range = (1.22 - 0.88) / (1.0 - midPower);
                        const min = 1.0 - midPower * range;
                        const normalized = (speed - min) / range;
                        return Math.round(200 * Math.pow(Math.max(0, Math.min(1, normalized)), 8));
                    })(dilationSpeed);
                    dilationValue.textContent = dilationSpeed.toFixed(4);
                    
                    updateBaseValues();
                    updateStatusIndicators();
                }
                
                // J: Toggle jiggle
                if (e.key === 'j' || e.key === 'J') {
                    jiggleBtn.click();
                }
                
                // Esc: Clear screen
                if (e.key === 'Escape') {
                    // Clear both framebuffers
                    const gl = renderer.gl;
                    
                    // Clear history framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.historyFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    // Clear current framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, renderer.currentFramebuffer);
                    gl.viewport(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
            });
            
            // Note: We don't wrap loadPresets here because updatePresetNames
            // already calls the original function directly to avoid circular references.
            // If you need to update preset names after loading, call updatePresetNames() explicitly.
        })();
    </script>
</body>
</html>

