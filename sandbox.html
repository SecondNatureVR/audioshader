<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Droplet Visual Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #dev-toolbox {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            color: #fff;
            min-width: 250px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            z-index: 1000;
        }
        
        #dev-toolbox h3 {
            margin-bottom: 15px;
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group .value {
            font-size: 11px;
            color: #888;
            font-family: monospace;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Shader scripts (embedded to avoid CORS issues) -->
    <script id="star-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>
    
    <script id="star-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform float u_spikes;
        uniform float u_hue;
        uniform float u_scale;
        uniform float u_rotation;
        uniform float u_autoRotationSpeed;
        uniform float u_blendOpacity;

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            // Normalize coordinates
            vec2 uv = gl_FragCoord.xy / u_resolution.xy;
            vec2 center = vec2(0.5);
            
            // Convert to centered coordinates
            vec2 p = (uv - center) * vec2(u_resolution.x / u_resolution.y, 1.0);
            
            // Rotate coordinates (manual rotation + auto rotation)
            float autoRotation = -u_time * u_autoRotationSpeed; // Auto rotation in degrees (reversed direction)
            float totalRotation = u_rotation + autoRotation;
            float rotationRad = totalRotation * 3.14159 / 180.0;
            float cosRot = cos(rotationRad);
            float sinRot = sin(rotationRad);
            vec2 rotatedP = vec2(
                p.x * cosRot - p.y * sinRot,
                p.x * sinRot + p.y * cosRot
            );
            
            // Draw a star
            float angle = atan(rotatedP.y, rotatedP.x);
            float dist = length(rotatedP);
            
            // Star shape with configurable number of spikes
            float numSpikes = floor(u_spikes);
            
            // Calculate star radius pattern (varies with angle to create spikes)
            // Base radius scales with u_scale, then adds spikes
            float baseRadius = u_scale * 0.4;
            float spikeAmount = u_scale * 0.25;
            float r = baseRadius + spikeAmount * cos(angle * numSpikes);
            
            // Draw the star - use a smooth falloff
            float lineWidth = 0.012;
            float star = smoothstep(lineWidth, 0.0, abs(dist - r));
            
            // Fill the star interior for better visibility
            float innerRadius = r * 0.65;
            if (dist < innerRadius) {
                star = max(star, 0.6);
            }
            
            // Make it brighter
            star = min(star, 1.0);
            
            // Convert hue to RGB (hue in degrees, saturation=1.0, value=1.0)
            // Add slow automatic hue shift over time (full cycle every 30 seconds)
            float autoHueShift = u_time * 12.0; // 360 degrees / 30 seconds = 12 deg/sec
            float finalHue = mod(u_hue + autoHueShift, 360.0);
            vec3 hsv = vec3(finalHue / 360.0, 1.0, 1.0);
            vec3 color = hsv2rgb(hsv) * star;
            
            // Apply opacity for blend control
            gl_FragColor = vec4(color, u_blendOpacity);
        }
    </script>
    
    <script id="dilation-vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_uv;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_uv = a_position * 0.5 + 0.5;
            v_uv.y = 1.0 - v_uv.y; // Flip Y
        }
    </script>
    
    <script id="dilation-fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform sampler2D u_history;
        uniform vec2 u_resolution;
        uniform float u_expansionFactor;
        uniform float u_fadeAmount;
        uniform float u_hueShiftAmount;
        varying vec2 v_uv;

        // Convert HSV to RGB
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        // Convert RGB to HSV
        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        void main() {
            vec2 uv = v_uv;
            vec2 center = vec2(0.5);
            vec2 dir = uv - center;
            vec2 scaledDir = dir / u_expansionFactor; // Scale inward to sample outward
            vec2 sampleUV = scaledDir + center;
            
            vec4 history = texture2D(u_history, sampleUV);
            
            // Fade based on expansion (further from center = more faded)
            float distFromCenter = length(dir);
            // Use logarithmic fade curve for smoother transitions
            // Map distance to fade using a power curve for more gradual fade
            float fadeAmount = smoothstep(0.0, 0.8, distFromCenter); // Fade as it expands
            // Apply logarithmic fade: fade = 1 - fadeAmount^fadePower
            // Higher fadeAmount values create more gradual fades
            float fadePower = 1.0 + u_fadeAmount * 2.0; // Range: 1.0 to 3.0
            float fade = 1.0 - pow(fadeAmount, fadePower);
            
            // Decay factor: reduce brightness over time to prevent accumulation
            // Estimate age based on distance (further = older = more decay)
            float ageEstimate = distFromCenter * 2.0; // Rough estimate of "age"
            float decayRate = 0.98; // Decay 2% per frame (adjustable)
            float decay = pow(decayRate, ageEstimate); // Exponential decay
            
            // Hue shift based on expansion
            float hueShift = distFromCenter * u_hueShiftAmount; // Use parameterized hue shift
            
            // Convert RGB to HSV, shift hue, convert back
            vec3 hsv = rgb2hsv(history.rgb);
            hsv.x = fract(hsv.x + hueShift); // Shift hue (wrap around)
            hsv.z *= fade * decay; // Apply both fade and decay to value
            vec3 shiftedColor = hsv2rgb(hsv);
            
            // Clamp to prevent overflow from additive blending
            shiftedColor = clamp(shiftedColor, 0.0, 1.0);
            
            gl_FragColor = vec4(shiftedColor, history.a * fade * decay);
        }
    </script>
    
    <div id="dev-toolbox">
        <h3>Dev Controls</h3>
        
        <div class="control-group">
            <label for="preset-select">Preset</label>
            <select id="preset-select" style="width: 100%; font-size: 11px; padding: 2px; background: #333; color: #eee; border: 1px solid #555;">
                <option value="">-- Select Preset --</option>
            </select>
            <div style="margin-top: 8px; display: flex; gap: 5px;">
                <input type="text" id="preset-name-input" placeholder="Preset name" style="flex: 1; font-size: 11px; padding: 4px; background: #333; color: #eee; border: 1px solid #555; border-radius: 3px;">
                <button id="save-preset-btn" style="font-size: 11px; padding: 4px 8px; background: #0af; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Save</button>
                <button id="delete-preset-btn" style="font-size: 11px; padding: 4px 8px; background: #a00; color: #fff; border: none; border-radius: 3px; cursor: pointer;">Delete</button>
            </div>
        </div>
        
        <div class="control-group">
            <label for="spikes-slider">Number of Spikes</label>
            <input type="range" id="spikes-slider" min="3" max="20" value="5" step="1">
            <div class="value" id="spikes-value">5</div>
        </div>
        
        <div class="control-group">
            <label for="hue-slider">Hue</label>
            <input type="range" id="hue-slider" min="0" max="360" value="45" step="1">
            <div class="value" id="hue-value">45°</div>
        </div>
        
        <div class="control-group">
            <label for="scale-slider">Scale</label>
            <input type="range" id="scale-slider" min="0.05" max="1.0" value="0.2" step="0.01">
            <div class="value" id="scale-value">0.20</div>
        </div>
        
        <div class="control-group">
            <label for="dilation-slider">Dilation Speed</label>
            <input type="range" id="dilation-slider" min="0" max="200" value="20" step="1">
            <div class="value" id="dilation-value">1.01</div>
        </div>
        
        <div class="control-group">
            <label for="fade-slider">Fade Amount</label>
            <input type="range" id="fade-slider" min="0" max="100" value="30" step="1">
            <div class="value" id="fade-value">0.30</div>
        </div>
        
        <div class="control-group">
            <label for="emanation-rate-slider">Emanation Rate (per second)</label>
            <input type="range" id="emanation-rate-slider" min="2" max="30" value="2" step="0.1">
            <div class="value" id="emanation-rate-value">2.0</div>
        </div>
        
        <div class="control-group">
            <label for="auto-rotation-slider">Auto Rotation Speed (deg/sec)</label>
            <input type="range" id="auto-rotation-slider" min="0" max="30" value="30" step="1">
            <div class="value" id="auto-rotation-value">30°</div>
        </div>
        
        <div class="control-group">
            <label for="hue-shift-slider">Hue Shift</label>
            <input type="range" id="hue-shift-slider" min="0.0" max="0.2" value="0.05" step="0.001">
            <div class="value" id="hue-shift-value">0.050</div>
        </div>
        
        <div class="control-group">
            <label for="rotation-slider">Star Rotation</label>
            <input type="range" id="rotation-slider" min="0" max="360" value="0" step="1">
            <div class="value" id="rotation-value">0°</div>
        </div>
        
        <div class="control-group">
            <label for="blend-mode-select">Blend Mode</label>
            <select id="blend-mode-select" style="width: 100%; font-size: 11px; padding: 2px; background: #333; color: #eee; border: 1px solid #555;">
                <option value="additive">Additive</option>
                <option value="alpha" selected>Alpha Blend</option>
                <option value="multiply">Multiply</option>
                <option value="screen">Screen</option>
                <option value="overlay">Overlay</option>
            </select>
        </div>
        
        <div class="control-group">
            <label for="blend-opacity-slider">Blend Opacity</label>
            <input type="range" id="blend-opacity-slider" min="0.0" max="1.0" value="0.3" step="0.01">
            <div class="value" id="blend-opacity-value">0.30</div>
        </div>
    </div>
    
    <script>
        // Simple WebGL renderer
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.program = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Resize textures if they exist
                if (this.historyTexture && this.currentTexture) {
                    this.setupFramebuffers();
                }
            }
            
            setupFramebuffers() {
                const gl = this.gl;
                
                // Create or recreate history texture
                if (this.historyTexture) {
                    gl.deleteTexture(this.historyTexture);
                }
                if (this.historyFramebuffer) {
                    gl.deleteFramebuffer(this.historyFramebuffer);
                }
                
                this.historyTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.historyFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.historyTexture, 0);
                
                // Create or recreate current texture
                if (this.currentTexture) {
                    gl.deleteTexture(this.currentTexture);
                }
                if (this.currentFramebuffer) {
                    gl.deleteFramebuffer(this.currentFramebuffer);
                }
                
                this.currentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.currentFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.currentTexture, 0);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const info = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${info}`);
                }
                
                return shader;
            }
            
            init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource) {
                const gl = this.gl;
                
                // Compile shape shader
                const vertexShader = this.compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.program);
                    throw new Error(`Program linking error: ${info}`);
                }
                
                // Compile dilation shader
                const dilationVertexShader = this.compileShader(dilationVertexSource, gl.VERTEX_SHADER);
                const dilationFragmentShader = this.compileShader(dilationFragmentSource, gl.FRAGMENT_SHADER);
                this.dilationProgram = gl.createProgram();
                gl.attachShader(this.dilationProgram, dilationVertexShader);
                gl.attachShader(this.dilationProgram, dilationFragmentShader);
                gl.linkProgram(this.dilationProgram);
                
                if (!gl.getProgramParameter(this.dilationProgram, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.dilationProgram);
                    throw new Error(`Dilation program linking error: ${info}`);
                }
                
                // Setup full-screen quad (shared buffer)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1
                ]);
                
                this.quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Setup position attribute for shape program
                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup position attribute for dilation program
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup framebuffers
                this.setupFramebuffers();
                
                // Clear history texture to black
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                gl.useProgram(this.program);
            }
            
            setUniform(name, value, program = null) {
                const gl = this.gl;
                const targetProgram = program || this.program;
                const location = gl.getUniformLocation(targetProgram, name);
                
                if (location === null) return;
                
                if (typeof value === 'number') {
                    gl.uniform1f(location, value);
                } else if (Array.isArray(value)) {
                    if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    } else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                }
            }
            
            setBlendMode(mode, opacity) {
                const gl = this.gl;
                
                switch(mode) {
                    case 'additive':
                        // Additive: src + dst (bright, accumulates)
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'alpha':
                        // Alpha blend: src * alpha + dst * (1 - alpha)
                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'multiply':
                        // Multiply: src * dst (darker)
                        gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'screen':
                        // Screen: 1 - (1 - src) * (1 - dst) (lighter)
                        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    case 'overlay':
                        // Overlay: if dst < 0.5: 2 * multiply, else: 2 * screen - 1
                        // True overlay requires reading destination buffer (not possible with simple blend funcs)
                        // Approximation: use a combination that's closer to overlay behavior
                        // Using DST_COLOR with ONE gives multiply-like effect for darker areas
                        gl.blendFunc(gl.DST_COLOR, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                        break;
                    default:
                        gl.blendFunc(gl.ONE, gl.ONE);
                        gl.blendEquation(gl.FUNC_ADD);
                }
                
                // Apply opacity by modifying blend color (requires shader modification)
                // For now, opacity affects the shape shader output
            }
            
            render(uniforms, dilationFactor, shouldCaptureShape, fadeAmount, hueShiftAmount, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation) {
                const gl = this.gl;
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                const shapePositionLocation = gl.getAttribLocation(this.program, 'a_position');
                
                // Step 1: Dilation pass - expand history texture
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                
                // Setup vertex attributes
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Set dilation uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                const dilationHistoryLocation = gl.getUniformLocation(this.dilationProgram, 'u_history');
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', dilationFactor, this.dilationProgram);
                this.setUniform('u_fadeAmount', fadeAmount, this.dilationProgram);
                this.setUniform('u_hueShiftAmount', hueShiftAmount, this.dilationProgram);
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 2: Draw current shape (only add to history if shouldCaptureShape is true)
                // This controls the emanation rate - how frequently new shapes are captured
                if (shouldCaptureShape) {
                    gl.useProgram(this.program);
                    gl.enableVertexAttribArray(shapePositionLocation);
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                    gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                    
                    // Enable blending with configurable mode
                    gl.enable(gl.BLEND);
                    this.setBlendMode(blendMode, blendOpacity);
                    
                    Object.keys(uniforms).forEach(name => {
                        this.setUniform(name, uniforms[name]);
                    });
                    this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                    // For captured shapes: use manual rotation as base offset (no auto-rotation)
                    // This preserves the rotation offset while freezing the shape
                    this.setUniform('u_rotation', rotation); // Manual rotation offset
                    this.setUniform('u_autoRotationSpeed', 0.0); // Disable auto-rotation for captured shapes (they're frozen)
                    this.setUniform('u_blendOpacity', blendOpacity);
                    
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                    gl.disable(gl.BLEND);
                }
                
                // Step 3: Display current texture to screen
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for display
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 4: Draw current star on top of everything (always visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable blending with configurable mode
                gl.enable(gl.BLEND);
                this.setBlendMode(blendMode, blendOpacity);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                this.setUniform('u_rotation', rotation);
                this.setUniform('u_autoRotationSpeed', autoRotationSpeed);
                this.setUniform('u_blendOpacity', blendOpacity);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 5: Copy current texture to history for next frame (always, for smooth dilation)
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for copy
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        
        // Get shader from script tag
        function getShader(id) {
            const script = document.getElementById(id);
            if (!script) {
                throw new Error(`Shader script not found: ${id}`);
            }
            return script.textContent;
        }
        
        // Initialize
        function init() {
            const canvas = document.getElementById('canvas');
            const renderer = new SimpleRenderer(canvas);
            
            // Get shaders from script tags
            const vertexSource = getShader('star-vertex-shader');
            const fragmentSource = getShader('star-fragment-shader');
            const dilationVertexSource = getShader('dilation-vertex-shader');
            const dilationFragmentSource = getShader('dilation-fragment-shader');
            
            renderer.init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource);
            
            return renderer;
        }
        
        const renderer = init();
        
        (() => {
            // Get slider elements
            const spikesSlider = document.getElementById('spikes-slider');
            const hueSlider = document.getElementById('hue-slider');
            const scaleSlider = document.getElementById('scale-slider');
            const dilationSlider = document.getElementById('dilation-slider');
            const fadeSlider = document.getElementById('fade-slider');
            const hueShiftSlider = document.getElementById('hue-shift-slider');
            const rotationSlider = document.getElementById('rotation-slider');
            const spikesValue = document.getElementById('spikes-value');
            const hueValue = document.getElementById('hue-value');
            const scaleValue = document.getElementById('scale-value');
            const dilationValue = document.getElementById('dilation-value');
            const fadeValue = document.getElementById('fade-value');
            const hueShiftValue = document.getElementById('hue-shift-value');
            const rotationValue = document.getElementById('rotation-value');
            const blendModeSelect = document.getElementById('blend-mode-select');
            const blendOpacitySlider = document.getElementById('blend-opacity-slider');
            const blendOpacityValue = document.getElementById('blend-opacity-value');
            
            // Current values (initialize from sliders)
            let spikes = parseFloat(spikesSlider.value);
            let hue = parseFloat(hueSlider.value);
            let scale = parseFloat(scaleSlider.value);
            // Initialize dilation speed with exponential mapping
            // Map slider (0-200) to dilation speed, with middle (100) = 1.0
            const initialDilationSlider = parseFloat(dilationSlider.value);
            // Use very steep curve (1/8 power) for super granular control near 1.0
            // Adjust range so slider value 100 maps to exactly 1.0
            const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0); // Power value at middle
            const range = (1.22 - 0.88) / (1.0 - midPower); // Adjusted range
            const min = 1.0 - midPower * range; // Adjusted minimum
            let dilationSpeed = min + Math.pow(initialDilationSlider / 200.0, 1.0 / 8.0) * range;
            // Initialize fade amount with logarithmic mapping
            const initialFadeSlider = parseFloat(fadeSlider.value);
            let fadeAmount = Math.pow(initialFadeSlider / 100.0, 1.0 / 3.0);
            let hueShiftAmount = parseFloat(hueShiftSlider.value);
            let rotation = parseFloat(rotationSlider.value);
            let blendMode = blendModeSelect.value;
            let blendOpacity = parseFloat(blendOpacitySlider.value);
            const emanationRateSlider = document.getElementById('emanation-rate-slider');
            const emanationRateValue = document.getElementById('emanation-rate-value');
            let emanationRate = parseFloat(emanationRateSlider.value); // Emanations per second
            const autoRotationSlider = document.getElementById('auto-rotation-slider');
            const autoRotationValue = document.getElementById('auto-rotation-value');
            let autoRotationSpeed = parseFloat(autoRotationSlider.value); // Degrees per second
        
            // Update sliders
            spikesSlider.addEventListener('input', (e) => {
                spikes = parseFloat(e.target.value);
                spikesValue.textContent = spikes;
            });
            
            hueSlider.addEventListener('input', (e) => {
                hue = parseFloat(e.target.value);
                hueValue.textContent = hue + '°';
            });
            
            scaleSlider.addEventListener('input', (e) => {
                scale = parseFloat(e.target.value);
                scaleValue.textContent = scale.toFixed(2);
            });
            
            dilationSlider.addEventListener('input', (e) => {
                // Map slider value (0-200) to dilation speed, with middle (100) = 1.0
                const sliderValue = parseFloat(e.target.value);
                // Use very steep curve (1/8 power) for super granular control near 1.0
                // Adjust range so slider value 100 maps to exactly 1.0
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0); // Power value at middle
                const range = (1.22 - 0.88) / (1.0 - midPower); // Adjusted range
                const min = 1.0 - midPower * range; // Adjusted minimum
                dilationSpeed = min + Math.pow(sliderValue / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4); // More decimal places for precision
            });
            
            fadeSlider.addEventListener('input', (e) => {
                // Map slider value (0-100) to logarithmic fade amount (0-1)
                // More granular near 0, less granular near 1
                const sliderValue = parseFloat(e.target.value);
                // Use exponential mapping: fadeAmount = (sliderValue/100)^(1/3)
                // This gives more precision near 0
                fadeAmount = Math.pow(sliderValue / 100.0, 1.0 / 3.0);
                fadeValue.textContent = fadeAmount.toFixed(3);
            });
            
            hueShiftSlider.addEventListener('input', (e) => {
                hueShiftAmount = parseFloat(e.target.value);
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
            });
            
            rotationSlider.addEventListener('input', (e) => {
                rotation = parseFloat(e.target.value);
                rotationValue.textContent = rotation + '°';
            });
            
            blendModeSelect.addEventListener('change', (e) => {
                blendMode = e.target.value;
            });
            
            blendOpacitySlider.addEventListener('input', (e) => {
                blendOpacity = parseFloat(e.target.value);
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
            });
            
            emanationRateSlider.addEventListener('input', (e) => {
                emanationRate = parseFloat(e.target.value);
                emanationRateValue.textContent = emanationRate.toFixed(1);
            });
            
            autoRotationSlider.addEventListener('input', (e) => {
                autoRotationSpeed = parseFloat(e.target.value);
                autoRotationValue.textContent = autoRotationSpeed + '°';
            });
            
            // Preset management
            const presetSelect = document.getElementById('preset-select');
            const presetNameInput = document.getElementById('preset-name-input');
            const savePresetBtn = document.getElementById('save-preset-btn');
            const deletePresetBtn = document.getElementById('delete-preset-btn');
            
            // Load presets from localStorage
            function loadPresets() {
                const presets = JSON.parse(localStorage.getItem('sandboxPresets') || '{}');
                presetSelect.innerHTML = '<option value="">-- Select Preset --</option>';
                Object.keys(presets).forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    presetSelect.appendChild(option);
                });
                return presets;
            }
            
            // Save current state as preset
            function savePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please enter a preset name');
                    return;
                }
                
                const preset = {
                    spikes: spikes,
                    hue: hue,
                    scale: scale,
                    dilationSlider: parseFloat(dilationSlider.value), // Store slider value for proper restoration
                    fadeSlider: parseFloat(fadeSlider.value), // Store slider value for proper restoration
                    hueShiftAmount: hueShiftAmount,
                    rotation: rotation,
                    blendMode: blendMode,
                    blendOpacity: blendOpacity,
                    emanationRate: emanationRate,
                    autoRotationSpeed: autoRotationSpeed
                };
                
                const presets = loadPresets();
                presets[name] = preset;
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetNameInput.value = '';
                alert(`Preset "${name}" saved!`);
            }
            
            // Load preset
            function loadPreset(name) {
                const presets = loadPresets();
                if (!presets[name]) {
                    alert('Preset not found');
                    return;
                }
                
                const preset = presets[name];
                
                // Set all values
                spikes = preset.spikes;
                hue = preset.hue;
                scale = preset.scale;
                hueShiftAmount = preset.hueShiftAmount;
                rotation = preset.rotation;
                blendMode = preset.blendMode;
                blendOpacity = preset.blendOpacity;
                emanationRate = preset.emanationRate;
                autoRotationSpeed = preset.autoRotationSpeed;
                
                // Update sliders
                spikesSlider.value = spikes;
                spikesValue.textContent = spikes;
                hueSlider.value = hue;
                hueValue.textContent = hue + '°';
                scaleSlider.value = scale;
                scaleValue.textContent = scale.toFixed(2);
                dilationSlider.value = preset.dilationSlider || 20;
                const midPower = Math.pow(100.0 / 200.0, 1.0 / 8.0);
                const range = (1.22 - 0.88) / (1.0 - midPower);
                const min = 1.0 - midPower * range;
                dilationSpeed = min + Math.pow(parseFloat(dilationSlider.value) / 200.0, 1.0 / 8.0) * range;
                dilationValue.textContent = dilationSpeed.toFixed(4);
                fadeSlider.value = preset.fadeSlider || 30;
                fadeAmount = Math.pow(parseFloat(fadeSlider.value) / 100.0, 1.0 / 3.0);
                fadeValue.textContent = fadeAmount.toFixed(3);
                hueShiftSlider.value = hueShiftAmount;
                hueShiftValue.textContent = hueShiftAmount.toFixed(3);
                rotationSlider.value = rotation;
                rotationValue.textContent = rotation + '°';
                blendModeSelect.value = blendMode;
                blendOpacitySlider.value = blendOpacity;
                blendOpacityValue.textContent = blendOpacity.toFixed(2);
                emanationRateSlider.value = emanationRate;
                emanationRateValue.textContent = emanationRate.toFixed(1);
                autoRotationSlider.value = autoRotationSpeed;
                autoRotationValue.textContent = autoRotationSpeed + '°';
            }
            
            // Delete preset
            function deletePreset(name) {
                if (!name || name.trim() === '') {
                    alert('Please select a preset to delete');
                    return;
                }
                
                if (!confirm(`Delete preset "${name}"?`)) {
                    return;
                }
                
                const presets = loadPresets();
                delete presets[name];
                localStorage.setItem('sandboxPresets', JSON.stringify(presets));
                loadPresets();
                presetSelect.value = '';
            }
            
            // Initialize presets
            loadPresets();
            
            // Load last active preset on page load
            const lastActivePreset = localStorage.getItem('sandboxLastActivePreset');
            if (lastActivePreset) {
                const presets = loadPresets();
                if (presets[lastActivePreset]) {
                    presetSelect.value = lastActivePreset;
                    loadPreset(lastActivePreset);
                }
            }
            
            // Event listeners
            presetSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadPreset(e.target.value);
                    localStorage.setItem('sandboxLastActivePreset', e.target.value);
                }
            });
            
            savePresetBtn.addEventListener('click', () => {
                const presetName = presetNameInput.value.trim();
                savePreset(presetName);
                if (presetName) {
                    localStorage.setItem('sandboxLastActivePreset', presetName);
                    presetSelect.value = presetName;
                }
            });
            
            deletePresetBtn.addEventListener('click', () => {
                const presetToDelete = presetSelect.value;
                deletePreset(presetToDelete);
                if (localStorage.getItem('sandboxLastActivePreset') === presetToDelete) {
                    localStorage.removeItem('sandboxLastActivePreset');
                }
            });
            
            let startTime = Date.now();
            let lastCaptureTime = 0;
            const TARGET_FPS = 60;
            const FRAME_TIME = 1000 / TARGET_FPS; // ~16.67ms per frame
            
            function render() {
                const currentTime = (Date.now() - startTime) / 1000.0;
                
                // Calculate capture interval from emanation rate (emanations per second)
                const captureInterval = 1.0 / emanationRate;
                
                // Check if it's time to capture a new shape
                const shouldCaptureShape = (currentTime - lastCaptureTime) >= captureInterval;
                if (shouldCaptureShape) {
                    lastCaptureTime = currentTime;
                }
                
                // Calculate total rotation (manual + auto) for capturing
                // This ensures captured shapes preserve their rotation at capture time
                const totalRotation = rotation + (currentTime * autoRotationSpeed);
                
                renderer.render({
                    u_time: currentTime,
                    u_spikes: spikes,
                    u_hue: hue,
                    u_scale: scale
                }, dilationSpeed, shouldCaptureShape, fadeAmount, hueShiftAmount, rotation, blendMode, blendOpacity, autoRotationSpeed, totalRotation);
            }
            
            // Use setInterval for fixed 60fps instead of requestAnimationFrame
            setInterval(render, FRAME_TIME);
            render(); // Initial render
        })();
    </script>
</body>
</html>

