<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Droplet Visual Sandbox</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #dev-toolbox {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
            color: #fff;
            min-width: 250px;
            z-index: 1000;
        }
        
        #dev-toolbox h3 {
            margin-bottom: 15px;
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        .control-group .value {
            font-size: 11px;
            color: #888;
            font-family: monospace;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #0af;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="dev-toolbox">
        <h3>Dev Controls</h3>
        
        <div class="control-group">
            <label for="spikes-slider">Number of Spikes</label>
            <input type="range" id="spikes-slider" min="3" max="20" value="5" step="1">
            <div class="value" id="spikes-value">5</div>
        </div>
        
        <div class="control-group">
            <label for="hue-slider">Hue</label>
            <input type="range" id="hue-slider" min="0" max="360" value="45" step="1">
            <div class="value" id="hue-value">45°</div>
        </div>
        
        <div class="control-group">
            <label for="scale-slider">Scale</label>
            <input type="range" id="scale-slider" min="0.05" max="1.0" value="0.2" step="0.01">
            <div class="value" id="scale-value">0.20</div>
        </div>
        
        <div class="control-group">
            <label for="dilation-slider">Dilation Speed</label>
            <input type="range" id="dilation-slider" min="1.0" max="1.05" value="1.01" step="0.001">
            <div class="value" id="dilation-value">1.010</div>
        </div>
    </div>
    
    <script>
        // Simple WebGL renderer
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl');
                
                if (!this.gl) {
                    throw new Error('WebGL not supported');
                }
                
                this.program = null;
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                
                // Resize textures if they exist
                if (this.historyTexture && this.currentTexture) {
                    this.setupFramebuffers();
                }
            }
            
            setupFramebuffers() {
                const gl = this.gl;
                
                // Create or recreate history texture
                if (this.historyTexture) {
                    gl.deleteTexture(this.historyTexture);
                }
                if (this.historyFramebuffer) {
                    gl.deleteFramebuffer(this.historyFramebuffer);
                }
                
                this.historyTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.historyFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.historyTexture, 0);
                
                // Create or recreate current texture
                if (this.currentTexture) {
                    gl.deleteTexture(this.currentTexture);
                }
                if (this.currentFramebuffer) {
                    gl.deleteFramebuffer(this.currentFramebuffer);
                }
                
                this.currentTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.canvas.width, this.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                
                this.currentFramebuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.currentTexture, 0);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const info = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error(`Shader compilation error: ${info}`);
                }
                
                return shader;
            }
            
            init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource) {
                const gl = this.gl;
                
                // Compile shape shader
                const vertexShader = this.compileShader(vertexSource, gl.VERTEX_SHADER);
                const fragmentShader = this.compileShader(fragmentSource, gl.FRAGMENT_SHADER);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                
                if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.program);
                    throw new Error(`Program linking error: ${info}`);
                }
                
                // Compile dilation shader
                const dilationVertexShader = this.compileShader(dilationVertexSource, gl.VERTEX_SHADER);
                const dilationFragmentShader = this.compileShader(dilationFragmentSource, gl.FRAGMENT_SHADER);
                this.dilationProgram = gl.createProgram();
                gl.attachShader(this.dilationProgram, dilationVertexShader);
                gl.attachShader(this.dilationProgram, dilationFragmentShader);
                gl.linkProgram(this.dilationProgram);
                
                if (!gl.getProgramParameter(this.dilationProgram, gl.LINK_STATUS)) {
                    const info = gl.getProgramInfoLog(this.dilationProgram);
                    throw new Error(`Dilation program linking error: ${info}`);
                }
                
                // Setup full-screen quad (shared buffer)
                const positions = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1
                ]);
                
                this.quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Setup position attribute for shape program
                const positionLocation = gl.getAttribLocation(this.program, 'a_position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup position attribute for dilation program
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Setup framebuffers
                this.setupFramebuffers();
                
                // Clear history texture to black
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                
                gl.useProgram(this.program);
            }
            
            setUniform(name, value, program = null) {
                const gl = this.gl;
                const targetProgram = program || this.program;
                const location = gl.getUniformLocation(targetProgram, name);
                
                if (location === null) return;
                
                if (typeof value === 'number') {
                    gl.uniform1f(location, value);
                } else if (Array.isArray(value)) {
                    if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    } else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                }
            }
            
            render(uniforms, dilationFactor, shouldCaptureShape) {
                const gl = this.gl;
                const dilationPositionLocation = gl.getAttribLocation(this.dilationProgram, 'a_position');
                const shapePositionLocation = gl.getAttribLocation(this.program, 'a_position');
                
                // Step 1: Dilation pass - expand history texture
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.currentFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                
                // Setup vertex attributes
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Set dilation uniforms
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.historyTexture);
                const dilationHistoryLocation = gl.getUniformLocation(this.dilationProgram, 'u_history');
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', dilationFactor, this.dilationProgram);
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 2: Always draw current shape on top (current star stays visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable additive blending for shape
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 3: Display current texture to screen
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for display
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                // Step 4: Draw current star on top of everything (always visible)
                gl.useProgram(this.program);
                gl.enableVertexAttribArray(shapePositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(shapePositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // Enable additive blending for shape
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE);
                
                Object.keys(uniforms).forEach(name => {
                    this.setUniform(name, uniforms[name]);
                });
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height]);
                
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disable(gl.BLEND);
                
                // Step 5: Copy current texture to history for next frame (always, for smooth dilation)
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.historyFramebuffer);
                gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                gl.useProgram(this.dilationProgram);
                gl.enableVertexAttribArray(dilationPositionLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.quadBuffer);
                gl.vertexAttribPointer(dilationPositionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.currentTexture);
                gl.uniform1i(dilationHistoryLocation, 0);
                this.setUniform('u_expansionFactor', 1.0, this.dilationProgram); // No expansion for copy
                this.setUniform('u_resolution', [this.canvas.width, this.canvas.height], this.dilationProgram);
                
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
        }
        
        // Vertex shader
        const vertexSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        // Fragment shader - draws a star
        const fragmentSource = `
            #ifdef GL_ES
            precision mediump float;
            #endif
            
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_spikes;
            uniform float u_hue;
            uniform float u_scale;
            
            // Convert HSV to RGB
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            void main() {
                // Normalize coordinates
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                vec2 center = vec2(0.5);
                
                // Convert to centered coordinates
                vec2 p = (uv - center) * vec2(u_resolution.x / u_resolution.y, 1.0);
                
                // Draw a star
                float angle = atan(p.y, p.x);
                float dist = length(p);
                
                // Star shape with configurable number of spikes
                float numSpikes = floor(u_spikes);
                
                // Calculate star radius pattern (varies with angle to create spikes)
                // Base radius scales with u_scale, then adds spikes
                float baseRadius = u_scale * 0.4;
                float spikeAmount = u_scale * 0.25;
                float r = baseRadius + spikeAmount * cos(angle * numSpikes);
                
                // Draw the star - use a smooth falloff
                float lineWidth = 0.012;
                float star = smoothstep(lineWidth, 0.0, abs(dist - r));
                
                // Fill the star interior for better visibility
                float innerRadius = r * 0.65;
                if (dist < innerRadius) {
                    star = max(star, 0.6);
                }
                
                // Make it brighter
                star = min(star, 1.0);
                
                // Convert hue to RGB (hue in degrees, saturation=1.0, value=1.0)
                vec3 hsv = vec3(u_hue / 360.0, 1.0, 1.0);
                vec3 color = hsv2rgb(hsv) * star;
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        // Dilation shader - expands history texture
        const dilationVertexSource = `
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                v_uv = a_position * 0.5 + 0.5;
                v_uv.y = 1.0 - v_uv.y; // Flip Y
            }
        `;
        
        const dilationFragmentSource = `
            #ifdef GL_ES
            precision mediump float;
            #endif
            
            uniform sampler2D u_history;
            uniform vec2 u_resolution;
            uniform float u_expansionFactor;
            varying vec2 v_uv;
            
            // Convert HSV to RGB
            vec3 hsv2rgb(vec3 c) {
                vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
                vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
                return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
            }
            
            // Convert RGB to HSV
            vec3 rgb2hsv(vec3 c) {
                vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
                vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
                vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
                float d = q.x - min(q.w, q.y);
                float e = 1.0e-10;
                return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
            }
            
            void main() {
                vec2 uv = v_uv;
                vec2 center = vec2(0.5);
                vec2 dir = uv - center;
                vec2 scaledDir = dir / u_expansionFactor; // Scale inward to sample outward
                vec2 sampleUV = scaledDir + center;
                
                vec4 history = texture2D(u_history, sampleUV);
                
                // Fade based on expansion (further from center = more faded)
                float distFromCenter = length(dir);
                float fadeAmount = smoothstep(0.0, 0.8, distFromCenter); // Fade as it expands
                float fade = 1.0 - fadeAmount * 0.3; // Fade up to 30%
                
                // Hue shift based on expansion
                float hueShift = distFromCenter * 0.05; // Shift hue as it expands (5% per unit distance)
                
                // Convert RGB to HSV, shift hue, convert back
                vec3 hsv = rgb2hsv(history.rgb);
                hsv.x = fract(hsv.x + hueShift); // Shift hue (wrap around)
                hsv.z *= fade; // Apply fade to value
                vec3 shiftedColor = hsv2rgb(hsv);
                
                gl_FragColor = vec4(shiftedColor, history.a * fade);
            }
        `;
        
        // Initialize
        const canvas = document.getElementById('canvas');
        const renderer = new SimpleRenderer(canvas);
        renderer.init(vertexSource, fragmentSource, dilationVertexSource, dilationFragmentSource);
        
        // Get slider elements
        const spikesSlider = document.getElementById('spikes-slider');
        const hueSlider = document.getElementById('hue-slider');
        const scaleSlider = document.getElementById('scale-slider');
        const dilationSlider = document.getElementById('dilation-slider');
        const spikesValue = document.getElementById('spikes-value');
        const hueValue = document.getElementById('hue-value');
        const scaleValue = document.getElementById('scale-value');
        const dilationValue = document.getElementById('dilation-value');
        
        // Current values (initialize from sliders)
        let spikes = parseFloat(spikesSlider.value);
        let hue = parseFloat(hueSlider.value);
        let scale = parseFloat(scaleSlider.value);
        let dilationSpeed = parseFloat(dilationSlider.value);
        
        // Update sliders
        spikesSlider.addEventListener('input', (e) => {
            spikes = parseFloat(e.target.value);
            spikesValue.textContent = spikes;
        });
        
        hueSlider.addEventListener('input', (e) => {
            hue = parseFloat(e.target.value);
            hueValue.textContent = hue + '°';
        });
        
        scaleSlider.addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            scaleValue.textContent = scale.toFixed(2);
        });
        
        dilationSlider.addEventListener('input', (e) => {
            dilationSpeed = parseFloat(e.target.value);
            dilationValue.textContent = dilationSpeed.toFixed(3);
        });
        
        let startTime = Date.now();
        let lastCaptureTime = 0;
        const CAPTURE_INTERVAL = 0.5; // 2 per second
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000.0;
            
            // Check if it's time to capture a new shape
            const shouldCaptureShape = (currentTime - lastCaptureTime) >= CAPTURE_INTERVAL;
            if (shouldCaptureShape) {
                lastCaptureTime = currentTime;
            }
            
            renderer.render({
                u_time: currentTime,
                u_spikes: spikes,
                u_hue: hue,
                u_scale: scale
            }, dilationSpeed, shouldCaptureShape);
            
            requestAnimationFrame(render);
        }
        
        render();
    </script>
</body>
</html>

